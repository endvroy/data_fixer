{"src": ["define", "the", "function", "strip_tags", "with", "an", "argument", "value", "."], "cano_code": "def strip_tags ( value ) :pass", "decano_code": "def strip_tags ( value ) :", "token": ["def", "strip_tags", "(", "value", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def strip_tags ( value ) :"}
{"src": ["while", "_STR:0_", "is", "contained", "in", "value", "and", "_STR:1_", "is", "contained", "in", "value", ","], "cano_code": "while '_STR:0_' in value and '_STR:1_' in value :pass", "decano_code": "while '_STR:0_' in value and '_STR:1_' in value :", "token": ["while", "\" _STR:0_ \"", "in", "value", "and", "\" _STR:1_ \"", "in", "value", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "NAME", "KEYWORD", "STRING", "KEYWORD", "NAME", "OP"], "raw_code": "while '<' in value and '>' in value :"}
{"src": ["call", "the", "function", "_strip_once", "with", "an", "argument", "value", ",", "substitute", "the", "result", "for", "new_value", "."], "cano_code": "new_value = _strip_once ( value )", "decano_code": "new_value = _strip_once ( value )", "token": ["new_value", "=", "_strip_once", "(", "value", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "new_value = _strip_once ( value )"}
{"src": ["if", "new_value", "equals", "value", ","], "cano_code": "if new_value == value :pass", "decano_code": "if new_value == value :", "token": ["if", "new_value", "==", "value", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if new_value == value :"}
{"src": ["break", "from", "the", "loop", "execution", "."], "cano_code": "break", "decano_code": "break", "token": ["break"], "type": ["NAME"], "raw_code": "break"}
{"src": ["substitute", "new_value", "for", "value", "."], "cano_code": "value = new_value", "decano_code": "value = new_value", "token": ["value", "=", "new_value"], "type": ["NAME", "OP", "NAME"], "raw_code": "value = new_value"}
{"src": ["return", "value", "."], "cano_code": "return value", "decano_code": "return value", "token": ["return", "value"], "type": ["KEYWORD", "NAME"], "raw_code": "return value"}
{"src": ["call", "the", "function", "allow_lazy", "with", "an", "argument", "strip_tags", ",", "substitute", "the", "result", "for", "strip_tags", "."], "cano_code": "strip_tags = allow_lazy ( strip_tags )", "decano_code": "strip_tags = allow_lazy ( strip_tags )", "token": ["strip_tags", "=", "allow_lazy", "(", "strip_tags", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "strip_tags = allow_lazy ( strip_tags )"}
{"src": ["define", "the", "function", "remove_tags", "with", "2", "arguments", ":", "html", "and", "tags", "."], "cano_code": "def remove_tags ( html , tags ) :pass", "decano_code": "def remove_tags ( html , tags ) :", "token": ["def", "remove_tags", "(", "html", ",", "tags", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def remove_tags ( html , tags ) :"}
{"src": ["tags", "is", "a", "list", "containing", "results", "of", "the", "function", "re.escape", "[", "re", ".", "escape", "]", "with", "an", "argument", "tag", ",", "for", "every", "tag", "in", "tags", "split", "into", "words", "."], "cano_code": "tags = [ re . escape ( tag ) for tag in tags . split ( ) ]", "decano_code": "tags = [ re . escape ( tag ) for tag in tags . split ( ) ]", "token": ["tags", "=", "[", "re", ".", "escape", "(", "tag", ")", "for", "tag", "in", "tags", ".", "split", "(", ")", "]"], "type": ["NAME", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "tags = [ re . escape ( tag ) for tag in tags . split ( ) ]"}
{"src": ["join", "elements", "of", "tags", "into", "a", "string", ",", "separated", "with", "_STR:0_", ",", "format", "string", "_STR:1_", "with", "it", ",", "substitute", "the", "result", "for", "tags_re", "."], "cano_code": "tags_re = '_STR:1_' % '_STR:0_' . join ( tags )", "decano_code": "tags_re = '_STR:1_' % '_STR:0_' . join ( tags )", "token": ["tags_re", "=", "\" _STR:1_ \"", "%", "\" _STR:0_ \"", ".", "join", "(", "tags", ")"], "type": ["NAME", "OP", "STRING", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "tags_re = '(%s)' % '|' . join ( tags )"}
{"src": ["call", "the", "function", "re.compile", "[", "re", ".", "compile", "]", "with", "2", "arguments", ":", "raw", "string", "_STR:0_", "formated", "with", "tags_re", "and", "re.U", "[", "re", ".", "U", "]", ","], "cano_code": "starttag_re = re . compile ( r'_STR:0_' % tags_re , re . U )", "decano_code": "starttag_re = re . compile ( r'_STR:0_' % tags_re , re . U )", "token": ["starttag_re", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", "%", "tags_re", ",", "re", ".", "U", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "starttag_re = re . compile ( r'<%s(/?>|(\\s+[^>]*>))' % tags_re , re . U )"}
{"src": ["substitute", "the", "result", "for", "starttag_re", ".", "call", "the", "function", "re.compile", "[", "re", ".", "compile", "]", "with", "an", "argument", "string", "_STR:0_", "formated", "with", "tags_re", ",", "substitute", "the", "result", "for", "endtag_re", "."], "cano_code": "endtag_re = re . compile ( '_STR:0_' % tags_re )", "decano_code": "endtag_re = re . compile ( '_STR:0_' % tags_re )", "token": ["endtag_re", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", "%", "tags_re", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "endtag_re = re . compile ( '</%s>' % tags_re )"}
{"src": ["call", "the", "function", "starttag_re.sub", "[", "starttag_re", ".", "sub", "]", "with", "2", "arguments", ":", "an", "empty", "string", "and", "html", ",", "substitute", "the", "result", "for", "html", "."], "cano_code": "html = starttag_re . sub ( '' , html )", "decano_code": "html = starttag_re . sub ( '' , html )", "token": ["html", "=", "starttag_re", ".", "sub", "(", "\"  \"", ",", "html", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "html = starttag_re . sub ( '' , html )"}
{"src": ["call", "the", "function", "endtag_re.sub", "[", "endtag_re", ".", "sub", "]", "with", "2", "arguments", ":", "an", "empty", "string", "and", "html", ",", "substitute", "the", "result", "for", "html", "."], "cano_code": "html = endtag_re . sub ( '' , html )", "decano_code": "html = endtag_re . sub ( '' , html )", "token": ["html", "=", "endtag_re", ".", "sub", "(", "\"  \"", ",", "html", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "html = endtag_re . sub ( '' , html )"}
{"src": ["return", "html", "."], "cano_code": "return html", "decano_code": "return html", "token": ["return", "html"], "type": ["KEYWORD", "NAME"], "raw_code": "return html"}
{"src": ["call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "remove_tags", ",", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "remove_tags", "."], "cano_code": "remove_tags = allow_lazy ( remove_tags , six . text_type )", "decano_code": "remove_tags = allow_lazy ( remove_tags , six . text_type )", "token": ["remove_tags", "=", "allow_lazy", "(", "remove_tags", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "remove_tags = allow_lazy ( remove_tags , six . text_type )"}
{"src": ["define", "the", "function", "strip_spaces_between_tags", "with", "an", "argument", "value", "."], "cano_code": "def strip_spaces_between_tags ( value ) :pass", "decano_code": "def strip_spaces_between_tags ( value ) :", "token": ["def", "strip_spaces_between_tags", "(", "value", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def strip_spaces_between_tags ( value ) :"}
{"src": ["call", "the", "method", "re.sub", "[", "re", ".", "sub", "]", "with", "3", "arguments", ":", "raw", "string", "_STR:0_", ",", "string", "_STR:1_", "and", "result", "of", "the", "function", "force_text", ","], "cano_code": "return re . sub ( r'_STR:0_' , '_STR:1_' , force_text ( value ) )", "decano_code": "return re . sub ( r'_STR:0_' , '_STR:1_' , force_text ( value ) )", "token": ["return", "re", ".", "sub", "(", "\" _STR:0_ \"", ",", "\" _STR:1_ \"", ",", "force_text", "(", "value", ")", ")"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "return re . sub ( r'>\\s+<' , '><' , force_text ( value ) )"}
{"src": ["called", "with", "an", "argument", "value", ",", "return", "the", "result", ".", "call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "strip_spaces_between_tags", ",", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "strip_spaces_between_tags", "."], "cano_code": "strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )", "decano_code": "strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )", "token": ["strip_spaces_between_tags", "=", "allow_lazy", "(", "strip_spaces_between_tags", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )"}
{"src": ["define", "the", "function", "strip_entities", "with", "an", "argument", "value", "."], "cano_code": "def strip_entities ( value ) :pass", "decano_code": "def strip_entities ( value ) :", "token": ["def", "strip_entities", "(", "value", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def strip_entities ( value ) :"}
{"src": ["call", "the", "method", "re.sub", "[", "re", ".", "sub", "]", "with", "3", "arguments", ":", "raw", "string", "_STR:0_", ",", "empty", "string", "and", "result", "of", "the", "function", "force_text", ","], "cano_code": "return re . sub ( r'_STR:0_' , '' , force_text ( value ) )", "decano_code": "return re . sub ( r'_STR:0_' , '' , force_text ( value ) )", "token": ["return", "re", ".", "sub", "(", "\" _STR:0_ \"", ",", "\"  \"", ",", "force_text", "(", "value", ")", ")"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "return re . sub ( r'&(?:\\w+|#\\d+);' , '' , force_text ( value ) )"}
{"src": ["called", "with", "an", "argument", "value", ",", "return", "the", "result", ".", "call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "strip_entities", ",", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "strip_entities", "."], "cano_code": "strip_entities = allow_lazy ( strip_entities , six . text_type )", "decano_code": "strip_entities = allow_lazy ( strip_entities , six . text_type )", "token": ["strip_entities", "=", "allow_lazy", "(", "strip_entities", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "strip_entities = allow_lazy ( strip_entities , six . text_type )"}
{"src": ["define", "the", "function", "smart_urlquote", "with", "an", "argument", "url", "."], "cano_code": "def smart_urlquote ( url ) :pass", "decano_code": "def smart_urlquote ( url ) :", "token": ["def", "smart_urlquote", "(", "url", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def smart_urlquote ( url ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "function", "urlsplit", "with", "an", "argument", "url", ",", "assign", "the", "result", "to", "scheme", ",", "netloc", ",", "path", ",", "query", "and", "fragment", ",", "respectively", "."], "cano_code": "scheme , netloc , path , query , fragment = urlsplit ( url )", "decano_code": "scheme , netloc , path , query , fragment = urlsplit ( url )", "token": ["scheme", ",", "netloc", ",", "path", ",", "query", ",", "fragment", "=", "urlsplit", "(", "url", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "scheme , netloc , path , query , fragment = urlsplit ( url )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "method", "netloc.encode", "[", "netloc", ".", "encode", "]", "with", "an", "argument", "string", "_STR:0_", ",", "call", "the", "method", "decode", "on", "the", "result", "with", "an", "argument", "_STR:1_", ","], "cano_code": "netloc = netloc . encode ( '_STR:0_' ) . decode ( '_STR:1_' )", "decano_code": "netloc = netloc . encode ( '_STR:0_' ) . decode ( '_STR:1_' )", "token": ["netloc", "=", "netloc", ".", "encode", "(", "\" _STR:0_ \"", ")", ".", "decode", "(", "\" _STR:1_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )"}
{"src": ["substitute", "the", "result", "for", "netloc", ".", "if", "UnicodeError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept UnicodeError :pass", "decano_code": "except UnicodeError :", "token": ["except", "UnicodeError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except UnicodeError :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["call", "the", "function", "urlunsplit", "with", "an", "argument", "tuple", "with", "4", "elements", ":", "scheme", ",", "netloc", ",", "path", ",", "query", "and", "fragment", ",", "substitute", "the", "result", "for", "url", "."], "cano_code": "url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )", "decano_code": "url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )", "token": ["url", "=", "urlunsplit", "(", "(", "scheme", ",", "netloc", ",", "path", ",", "query", ",", "fragment", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )"}
{"src": ["if", "ValueError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ValueError :pass", "decano_code": "except ValueError :", "token": ["except", "ValueError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ValueError :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["call", "the", "function", "force_str", "with", "an", "argument", "url", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "unquote", ",", "substitute", "the", "result", "for", "url", "."], "cano_code": "url = unquote ( force_str ( url ) )", "decano_code": "url = unquote ( force_str ( url ) )", "token": ["url", "=", "unquote", "(", "force_str", "(", "url", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "url = unquote ( force_str ( url ) )"}
{"src": ["call", "the", "function", "quote", "with", "2", "arguments", ":", "url", "and", "safe", "as", "bytes", "string", "_STR:0_", ",", "substitute", "the", "result", "for", "url", "."], "cano_code": "url = quote ( url , safe = b'_STR:0_' )", "decano_code": "url = quote ( url , safe = b'_STR:0_' )", "token": ["url", "=", "quote", "(", "url", ",", "safe", "=", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "url = quote ( url , safe = b'!*\\'();:@&=+$,/?#[]~' )"}
{"src": ["call", "the", "function", "force_text", "with", "an", "argument", "url", ",", "return", "the", "result", "."], "cano_code": "return force_text ( url )", "decano_code": "return force_text ( url )", "token": ["return", "force_text", "(", "url", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "return force_text ( url )"}
{"src": ["define", "the", "function", "urlize", "with", "4", "arguments", ":", "text", ",", "trim_url_limit", "set", "to", "None", ",", "nofollow", "set", "to", "boolean", "False", ","], "cano_code": "def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :pass", "decano_code": "def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :", "token": ["def", "urlize", "(", "text", ",", "trim_url_limit", "=", "None", ",", "nofollow", "=", "False", ",", "autoescape", "=", "False", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :"}
{"src": ["define", "the", "function", "trim_url", "with", "2", "arguments", ":", "x", "and", "limit", "set", "to", "trim_url_limit", "."], "cano_code": "def trim_url ( x , limit = trim_url_limit ) :pass", "decano_code": "def trim_url ( x , limit = trim_url_limit ) :", "token": ["def", "trim_url", "(", "x", ",", "limit", "=", "trim_url_limit", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def trim_url ( x , limit = trim_url_limit ) :"}
{"src": ["if", "limit", "is", "None", "or", "length", "of", "x", "is", "lesser", "than", "or", "equal", "to", "limit", ","], "cano_code": "if limit is None or len ( x ) <= limit :pass", "decano_code": "if limit is None or len ( x ) <= limit :", "token": ["if", "limit", "is", "None", "or", "len", "(", "x", ")", "<=", "limit", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "if limit is None or len ( x ) <= limit :"}
{"src": ["return", "x", "."], "cano_code": "return x", "decano_code": "return x", "token": ["return", "x"], "type": ["KEYWORD", "NAME"], "raw_code": "return x"}
{"src": ["return", "a", "string", "_STR:0_", "formated", "with", "elements", "of", "x", "up", "to", "the", "index", "equal", "to", "the", "maximum", "value", "between", "integer", "0", "and", "3", "subtracted", "from", "limit", "."], "cano_code": "return '_STR:0_' % x [ : max ( 0 , limit - 3 ) ]", "decano_code": "return '_STR:0_' % x [ : max ( 0 , limit - 3 ) ]", "token": ["return", "\" _STR:0_ \"", "%", "x", "[", ":", "max", "(", "0", ",", "limit", "-", "3", ")", "]"], "type": ["KEYWORD", "STRING", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "NUMBER", "OP", "NAME", "OP", "NUMBER", "OP", "OP"], "raw_code": "return '%s...' % x [ : max ( 0 , limit - 3 ) ]"}
{"src": ["if", "text", "is", "an", "instance", "of", "SafeData", ",", "safe_input", "is", "boolean", "True", ",", "otherwise", "is", "boolean", "False", "."], "cano_code": "safe_input = isinstance ( text , SafeData )", "decano_code": "safe_input = isinstance ( text , SafeData )", "token": ["safe_input", "=", "isinstance", "(", "text", ",", "SafeData", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "safe_input = isinstance ( text , SafeData )"}
{"src": ["call", "the", "function", "force_text", "with", "an", "argument", "text", ",", "split", "by", "it", "word_split_re", ",", "substitute", "it", "for", "words", "."], "cano_code": "words = word_split_re . split ( force_text ( text ) )", "decano_code": "words = word_split_re . split ( force_text ( text ) )", "token": ["words", "=", "word_split_re", ".", "split", "(", "force_text", "(", "text", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "words = word_split_re . split ( force_text ( text ) )"}
{"src": ["for", "every", "i", "and", "word", "in", "enumerated", "iterable", "words", ","], "cano_code": "for i , word in enumerate ( words ) :pass", "decano_code": "for i , word in enumerate ( words ) :", "token": ["for", "i", ",", "word", "in", "enumerate", "(", "words", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "OP"], "raw_code": "for i , word in enumerate ( words ) :"}
{"src": ["if", "_STR:0_", "is", "contained", "in", "words", "or", "_STR:1_", "is", "contained", "in", "word", "or", "_STR:2_", "is", "contained", "in", "word", ","], "cano_code": "if '_STR:0_' in word or '_STR:1_' in word or '_STR:2_' in word :pass", "decano_code": "if '_STR:0_' in word or '_STR:1_' in word or '_STR:2_' in word :", "token": ["if", "\" _STR:0_ \"", "in", "word", "or", "\" _STR:1_ \"", "in", "word", "or", "\" _STR:2_ \"", "in", "word", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "NAME", "KEYWORD", "STRING", "KEYWORD", "NAME", "KEYWORD", "STRING", "KEYWORD", "NAME", "OP"], "raw_code": "if '.' in word or '@' in word or ':' in word :"}
{"src": ["substitute", "empty", "string", ",", "word", "an", "empty", "string", "for", "lead", ",", "middle", "and", "trail", ",", "respectively", "."], "cano_code": "lead , middle , trail = '' , word , ''", "decano_code": "lead , middle , trail = '' , word , ''", "token": ["lead", ",", "middle", ",", "trail", "=", "\"  \"", ",", "word", ",", "\"  \""], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING"], "raw_code": "lead , middle , trail = '' , word , ''"}
{"src": ["for", "every", "punctuation", "in", "TRAILING_PUNCTUATION", ","], "cano_code": "for punctuation in TRAILING_PUNCTUATION :pass", "decano_code": "for punctuation in TRAILING_PUNCTUATION :", "token": ["for", "punctuation", "in", "TRAILING_PUNCTUATION", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for punctuation in TRAILING_PUNCTUATION :"}
{"src": ["if", "middle", "ends", "with", "punctuation", ","], "cano_code": "if middle . endswith ( punctuation ) :pass", "decano_code": "if middle . endswith ( punctuation ) :", "token": ["if", "middle", ".", "endswith", "(", "punctuation", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if middle . endswith ( punctuation ) :"}
{"src": ["substitute", "elements", "of", "middle", "from", "the", "beginning", "to", "the", "negative", "length", "of", "punctuation", ",", "for", "middle", "."], "cano_code": "middle = middle [ : - len ( punctuation ) ]", "decano_code": "middle = middle [ : - len ( punctuation ) ]", "token": ["middle", "=", "middle", "[", ":", "-", "len", "(", "punctuation", ")", "]"], "type": ["NAME", "OP", "NAME", "OP", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "OP"], "raw_code": "middle = middle [ : - len ( punctuation ) ]"}
{"src": ["sum", "punctuation", "and", "trail", ",", "substitute", "the", "result", "for", "trail", "."], "cano_code": "trail = punctuation + trail", "decano_code": "trail = punctuation + trail", "token": ["trail", "=", "punctuation", "+", "trail"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "trail = punctuation + trail"}
{"src": ["for", "every", "opening", "and", "closing", "in", "WRAPPING_PUNCTUATION", ","], "cano_code": "for opening , closing in WRAPPING_PUNCTUATION :pass", "decano_code": "for opening , closing in WRAPPING_PUNCTUATION :", "token": ["for", "opening", ",", "closing", "in", "WRAPPING_PUNCTUATION", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for opening , closing in WRAPPING_PUNCTUATION :"}
{"src": ["if", "middle", "starts", "with", "opening", ","], "cano_code": "if middle . startswith ( opening ) :pass", "decano_code": "if middle . startswith ( opening ) :", "token": ["if", "middle", ".", "startswith", "(", "opening", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if middle . startswith ( opening ) :"}
{"src": ["substitute", "elements", "of", "middle", "from", "length", "of", "opening", "index", "to", "the", "end", ",", "for", "middle", "."], "cano_code": "middle = middle [ len ( opening ) : ]", "decano_code": "middle = middle [ len ( opening ) : ]", "token": ["middle", "=", "middle", "[", "len", "(", "opening", ")", ":", "]"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "middle = middle [ len ( opening ) : ]"}
{"src": ["sum", "lead", "and", "opening", ",", "substitute", "the", "result", "for", "lead", "."], "cano_code": "lead = lead + opening", "decano_code": "lead = lead + opening", "token": ["lead", "=", "lead", "+", "opening"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "lead = lead + opening"}
{"src": ["if", "middle", "ends", "with", "closing", "and", "count", "of", "occurrence", "of", "closing", "in", "middle", "equals", "count", "of", "occurrence", "of", "opening", "in", "middle", "incremented", "by", "one", ","], "cano_code": "if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :pass", "decano_code": "if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :", "token": ["if", "(", "middle", ".", "endswith", "(", "closing", ")", "and", "middle", ".", "count", "(", "closing", ")", "==", "middle", ".", "count", "(", "opening", ")", "+", "1", ")", ":"], "type": ["KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :"}
{"src": ["substitute", "elements", "of", "middle", "from", "the", "beginning", "to", "the", "negative", "length", "of", "closing", ",", "for", "middle", "."], "cano_code": "middle = middle [ : - len ( closing ) ]", "decano_code": "middle = middle [ : - len ( closing ) ]", "token": ["middle", "=", "middle", "[", ":", "-", "len", "(", "closing", ")", "]"], "type": ["NAME", "OP", "NAME", "OP", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "OP"], "raw_code": "middle = middle [ : - len ( closing ) ]"}
{"src": ["sum", "trail", "and", "closing", ",", "substitute", "the", "result", "for", "lead", "."], "cano_code": "trail = closing + trail", "decano_code": "trail = closing + trail", "token": ["trail", "=", "closing", "+", "trail"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "trail = closing + trail"}
{"src": ["url", "is", "None", "."], "cano_code": "url = None", "decano_code": "url = None", "token": ["url", "=", "None"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "url = None"}
{"src": ["if", "nofollow", "is", "true", "nofollow_attr", "is", "a", "string", "_STR:0_", ",", "otherwise", "nofollow_attr", "is", "an", "empty", "string", "."], "cano_code": "nofollow_attr = '_STR:0_' if nofollow else ''", "decano_code": "nofollow_attr = '_STR:0_' if nofollow else ''", "token": ["nofollow_attr", "=", "\" _STR:0_ \"", "if", "nofollow", "else", "\"  \""], "type": ["NAME", "OP", "STRING", "KEYWORD", "NAME", "KEYWORD", "STRING"], "raw_code": "nofollow_attr = ' rel=\"nofollow\"' if nofollow else ''"}
{"src": ["call", "the", "method", "simple_url_re.match", "[", "simple_url_re", ".", "match", "]", "with", "an", "argument", "middle", ",", "if", "it", "evaluates", "to", "true", ","], "cano_code": "if simple_url_re . match ( middle ) :pass", "decano_code": "if simple_url_re . match ( middle ) :", "token": ["if", "simple_url_re", ".", "match", "(", "middle", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if simple_url_re . match ( middle ) :"}
{"src": ["call", "the", "function", "smart_urlquote", "with", "an", "argument", "middle", ",", "substitute", "the", "result", "for", "url", "."], "cano_code": "url = smart_urlquote ( middle )", "decano_code": "url = smart_urlquote ( middle )", "token": ["url", "=", "smart_urlquote", "(", "middle", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "url = smart_urlquote ( middle )"}
{"src": ["otherwise", "if", "call", "the", "method", "simple_url_2_re.match", "[", "simple_url_2_re", ".", "match", "]", "with", "an", "argument", "middle", "evaluates", "to", "true", ","], "cano_code": "if True: pass\nelif simple_url_2_re . match ( middle ) :pass", "decano_code": "elif simple_url_2_re . match ( middle ) :", "token": ["elif", "simple_url_2_re", ".", "match", "(", "middle", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "elif simple_url_2_re . match ( middle ) :"}
{"src": ["call", "the", "function", "smart_urlquote", "with", "an", "argument", "string", "_STR:0_", "formated", "with", "an", "argument", "middle", ",", "substitute", "the", "result", "for", "url", "."], "cano_code": "url = smart_urlquote ( '_STR:0_' % middle )", "decano_code": "url = smart_urlquote ( '_STR:0_' % middle )", "token": ["url", "=", "smart_urlquote", "(", "\" _STR:0_ \"", "%", "middle", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "url = smart_urlquote ( 'http://%s' % middle )"}
{"src": ["otherwise", "if", "_STR:0_", "is", "not", "contained", "in", "middle", "and", "result", "of", "the", "function", "simple_email_re.match", "[", "simple_email_re", ".", "match", "]", "called", "with", "an", "argument", "middle", ","], "cano_code": "if True: pass\nelif '_STR:0_' not in middle and simple_email_re . match ( middle ) :pass", "decano_code": "elif '_STR:0_' not in middle and simple_email_re . match ( middle ) :", "token": ["elif", "\" _STR:0_ \"", "not", "in", "middle", "and", "simple_email_re", ".", "match", "(", "middle", ")", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "elif ':' not in middle and simple_email_re . match ( middle ) :"}
{"src": ["evaluates", "to", "true", ",", "split", "middle", "into", "two", "parts", "from", "the", "right", "by", "_STR:0_", "character", ",", "assign", "the", "resulting", "parts", "to", "local", "and", "domain", "."], "cano_code": "local , domain = middle . rsplit ( '_STR:0_' , 1 )", "decano_code": "local , domain = middle . rsplit ( '_STR:0_' , 1 )", "token": ["local", ",", "domain", "=", "middle", ".", "rsplit", "(", "\" _STR:0_ \"", ",", "1", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NUMBER", "OP"], "raw_code": "local , domain = middle . rsplit ( '@' , 1 )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "method", "domain.encode", "[", "domain", ".", "encode", "]", "with", "an", "argument", "string", "_STR:0_", ",", "call", "the", "method", "decode", "on", "the", "result", "with", "an", "argument", "string", "_STR:1_", ","], "cano_code": "domain = domain . encode ( '_STR:0_' ) . decode ( '_STR:1_' )", "decano_code": "domain = domain . encode ( '_STR:0_' ) . decode ( '_STR:1_' )", "token": ["domain", "=", "domain", ".", "encode", "(", "\" _STR:0_ \"", ")", ".", "decode", "(", "\" _STR:1_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "domain = domain . encode ( 'idna' ) . decode ( 'ascii' )"}
{"src": ["substitute", "the", "result", "for", "domain", ".", "if", "UnicodeError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept UnicodeError :pass", "decano_code": "except UnicodeError :", "token": ["except", "UnicodeError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except UnicodeError :"}
{"src": ["skip", "this", "loop", "iteration", "."], "cano_code": "continue", "decano_code": "continue", "token": ["continue"], "type": ["NAME"], "raw_code": "continue"}
{"src": ["url", "is", "a", "string", "_STR:0_", "formated", "with", "local", "and", "domain", "."], "cano_code": "url = '_STR:0_' % ( local , domain )", "decano_code": "url = '_STR:0_' % ( local , domain )", "token": ["url", "=", "\" _STR:0_ \"", "%", "(", "local", ",", "domain", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "url = 'mailto:%s@%s' % ( local , domain )"}
{"src": ["nofollow_attr", "is", "an", "empty", "string", "."], "cano_code": "nofollow_attr = ''", "decano_code": "nofollow_attr = ''", "token": ["nofollow_attr", "=", "\"  \""], "type": ["NAME", "OP", "STRING"], "raw_code": "nofollow_attr = ''"}
{"src": ["if", "url", "is", "true", ","], "cano_code": "if url :pass", "decano_code": "if url :", "token": ["if", "url", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if url :"}
{"src": ["call", "the", "function", "trim_url", "with", "an", "argument", "middle", ",", "substitute", "the", "result", "for", "trimmed", "."], "cano_code": "trimmed = trim_url ( middle )", "decano_code": "trimmed = trim_url ( middle )", "token": ["trimmed", "=", "trim_url", "(", "middle", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "trimmed = trim_url ( middle )"}
{"src": ["if", "autoescape", "is", "true", "and", "safe_input", "is", "false", ","], "cano_code": "if autoescape and not safe_input :pass", "decano_code": "if autoescape and not safe_input :", "token": ["if", "autoescape", "and", "not", "safe_input", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if autoescape and not safe_input :"}
{"src": ["call", "the", "function", "escape", "with", "an", "argument", "lead", ",", "substitute", "the", "result", "for", "lead", ",", "call", "the", "function", "escape", "with", "an", "argument", "trail", ","], "cano_code": "lead , trail = escape ( lead ) , escape ( trail )", "decano_code": "lead , trail = escape ( lead ) , escape ( trail )", "token": ["lead", ",", "trail", "=", "escape", "(", "lead", ")", ",", "escape", "(", "trail", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "lead , trail = escape ( lead ) , escape ( trail )"}
{"src": ["substitute", "the", "result", "for", "trail", ".", "call", "the", "function", "escape", "with", "an", "argument", "url", ",", "substitute", "the", "result", "for", "url", ",", "call", "the", "function", "escape", "with", "an", "argument", "trimmed", ","], "cano_code": "url , trimmed = escape ( url ) , escape ( trimmed )", "decano_code": "url , trimmed = escape ( url ) , escape ( trimmed )", "token": ["url", ",", "trimmed", "=", "escape", "(", "url", ")", ",", "escape", "(", "trimmed", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "url , trimmed = escape ( url ) , escape ( trimmed )"}
{"src": ["substitute", "the", "result", "for", "trimmed", ".", "middle", "is", "a", "string", "_STR:0_", "formated", "with", "url", ",", "nofollow_attr", "and", "trimmed", "."], "cano_code": "middle = '_STR:0_' % ( url , nofollow_attr , trimmed )", "decano_code": "middle = '_STR:0_' % ( url , nofollow_attr , trimmed )", "token": ["middle", "=", "\" _STR:0_ \"", "%", "(", "url", ",", "nofollow_attr", ",", "trimmed", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "middle = '<a href=\"%s\"%s>%s</a>' % ( url , nofollow_attr , trimmed )"}
{"src": ["format", "string", "_STR:0_", "with", "lead", ",", "middle", "and", "trail", ",", "use", "it", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "mark_safe", ","], "cano_code": "words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )", "decano_code": "words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )", "token": ["words", "[", "i", "]", "=", "mark_safe", "(", "\" %s%s%s \"", "%", "(", "lead", ",", "middle", ",", "trail", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )"}
{"src": ["substitute", "the", "result", "for", "i-th", "element", "of", "words", ".", "if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["if", "safe_input", "is", "true", ","], "cano_code": "if safe_input :pass", "decano_code": "if safe_input :", "token": ["if", "safe_input", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if safe_input :"}
{"src": ["call", "the", "function", "mark_safe", "with", "an", "argument", "word", ",", "substitute", "the", "result", "for", "i-th", "element", "of", "words", "."], "cano_code": "words [ i ] = mark_safe ( word )", "decano_code": "words [ i ] = mark_safe ( word )", "token": ["words", "[", "i", "]", "=", "mark_safe", "(", "word", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "words [ i ] = mark_safe ( word )"}
{"src": ["otherwise", "if", "autoescape", "is", "true", ","], "cano_code": "if True: pass\nelif autoescape :pass", "decano_code": "elif autoescape :", "token": ["elif", "autoescape", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "elif autoescape :"}
{"src": ["call", "the", "function", "escape", "with", "an", "argument", "word", ",", "substitute", "the", "result", "for", "i-th", "element", "of", "words", "."], "cano_code": "words [ i ] = escape ( word )", "decano_code": "words [ i ] = escape ( word )", "token": ["words", "[", "i", "]", "=", "escape", "(", "word", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "words [ i ] = escape ( word )"}
{"src": ["otherwise", "if", "safe_input", "is", "true", ","], "cano_code": "if True: pass\nelif safe_input :pass", "decano_code": "elif safe_input :", "token": ["elif", "safe_input", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "elif safe_input :"}
{"src": ["call", "the", "function", "mark_safe", "with", "an", "argument", "word", ",", "substitute", "the", "result", "for", "i-th", "element", "of", "words", "."], "cano_code": "words [ i ] = mark_safe ( word )", "decano_code": "words [ i ] = mark_safe ( word )", "token": ["words", "[", "i", "]", "=", "mark_safe", "(", "word", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "words [ i ] = mark_safe ( word )"}
{"src": ["otherwise", "if", "autoescape", "is", "true", ","], "cano_code": "if True: pass\nelif autoescape :pass", "decano_code": "elif autoescape :", "token": ["elif", "autoescape", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "elif autoescape :"}
{"src": ["call", "the", "function", "escape", "with", "an", "argument", "word", ",", "substitute", "the", "result", "for", "i-th", "element", "of", "words", "."], "cano_code": "words [ i ] = escape ( word )", "decano_code": "words [ i ] = escape ( word )", "token": ["words", "[", "i", "]", "=", "escape", "(", "word", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "words [ i ] = escape ( word )"}
{"src": ["join", "elements", "of", "words", "into", "a", "string", ",", "return", "it", "."], "cano_code": "return '' . join ( words )", "decano_code": "return '' . join ( words )", "token": ["return", "\"  \"", ".", "join", "(", "words", ")"], "type": ["KEYWORD", "STRING", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return '' . join ( words )"}
{"src": ["call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "urlize", ",", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "urlize", "."], "cano_code": "urlize = allow_lazy ( urlize , six . text_type )", "decano_code": "urlize = allow_lazy ( urlize , six . text_type )", "token": ["urlize", "=", "allow_lazy", "(", "urlize", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "urlize = allow_lazy ( urlize , six . text_type )"}
{"src": ["define", "the", "function", "avoid_wrapping", "with", "an", "argument", "value", "."], "cano_code": "def avoid_wrapping ( value ) :pass", "decano_code": "def avoid_wrapping ( value ) :", "token": ["def", "avoid_wrapping", "(", "value", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def avoid_wrapping ( value ) :"}
{"src": ["replace", "every", "occurrence", "of", "_STR:0_", "in", "value", "for", "_STR:1_", ",", "return", "the", "result", "."], "cano_code": "return value . replace ( \" \" , \"\\xa0\" )", "decano_code": "return value . replace ( \" \" , \"\\xa0\" )", "token": ["return", "value", ".", "replace", "(", "\"   \"", ",", "\" \\xa0 \"", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP"], "raw_code": "return value . replace ( \" \" , \"\\xa0\" )"}
{"src": ["from", "django.utils.six.moves", "[", "django", ".", "utils", ".", "six", ".", "moves", "]", "import", "html_parser", "as", "_html_parse", "into", "default", "name", "space", "."], "cano_code": "from django . utils . six . moves import html_parser as _html_parser", "decano_code": "from django . utils . six . moves import html_parser as _html_parser", "token": ["from", "django", ".", "utils", ".", "six", ".", "moves", "import", "html_parser", "as", "_html_parser"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . six . moves import html_parser as _html_parser"}
{"src": ["import", "module", "re", "."], "cano_code": "import re", "decano_code": "import re", "token": ["import", "re"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "import re"}
{"src": ["import", "module", "sys", "."], "cano_code": "import sys", "decano_code": "import sys", "token": ["import", "sys"], "type": ["KEYWORD", "NAME"], "raw_code": "import sys"}
{"src": ["substitute", "version_info", "from", "module", "sys", "for", "surrent_version", "."], "cano_code": "current_version = sys . version_info", "decano_code": "current_version = sys . version_info", "token": ["current_version", "=", "sys", ".", "version_info"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "current_version = sys . version_info"}
{"src": ["set", "use_workaround", "to", "boolean", "True", "if", "current_version", "tuple", "elements", "are", "smaller", "than", "the", "tuple", "(", "2,7,3", ")", ",", "respectively", ","], "cano_code": "use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )", "decano_code": "use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )", "token": ["use_workaround", "=", "(", "(", "current_version", "<", "(", "2", ",", "7", ",", "3", ")", ")", "or", "(", "current_version", ">=", "(", "3", ",", "0", ")", "and", "current_version", "<", "(", "3", ",", "2", ",", "3", ")", ")", ")"], "type": ["NAME", "OP", "OP", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "KEYWORD", "NAME", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP", "OP"], "raw_code": "use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )"}
{"src": ["or", "if", "current_version", "is", "greater", "than", "(", "3,0", ")", ",", "but", "smaller", "than", "(", "3,2,3", ")", ",", "otherwise", "set", "use_workaround", "to", "boolean", "False", ".", "substitute", "HTMLParseError", "from", "the", "module", "_html_parser", "for", "HTMLParseError", "."], "cano_code": "HTMLParseError = _html_parser . HTMLParseError", "decano_code": "HTMLParseError = _html_parser . HTMLParseError", "token": ["HTMLParseError", "=", "_html_parser", ".", "HTMLParseError"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "HTMLParseError = _html_parser . HTMLParseError"}
{"src": ["if", "use_workaround", "is", "boolean", "False", ","], "cano_code": "if not use_workaround :pass", "decano_code": "if not use_workaround :", "token": ["if", "not", "use_workaround", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not use_workaround :"}
{"src": ["if", "tuple", "current_version", "elements", "are", "greater", "or", "equal", "to", "(", "3", ",", "4", ")", ",", "respectively", ","], "cano_code": "if current_version >= ( 3 , 4 ) :pass", "decano_code": "if current_version >= ( 3 , 4 ) :", "token": ["if", "current_version", ">=", "(", "3", ",", "4", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP"], "raw_code": "if current_version >= ( 3 , 4 ) :"}
{"src": ["derive", "the", "class", "HTMLParser", "from", "the", "base", "class", "HTMLParser", "located", "in", "the", "module", "_html_parser", "."], "cano_code": "class HTMLParser ( _html_parser . HTMLParser ) :pass", "decano_code": "class HTMLParser ( _html_parser . HTMLParser ) :", "token": ["class", "HTMLParser", "(", "_html_parser", ".", "HTMLParser", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "class HTMLParser ( _html_parser . HTMLParser ) :"}
{"src": ["define", "the", "initialization", "method", "__init__", ",", "with", "self", "instance", "of", "this", "class", ",", "convert_charrefs", "set", "to", "boolean", "False", ","], "cano_code": "def __init__ ( self , convert_charrefs = False , ** kwargs ) :pass", "decano_code": "def __init__ ( self , convert_charrefs = False , ** kwargs ) :", "token": ["def", "__init__", "(", "self", ",", "convert_charrefs", "=", "False", ",", "**", "kwargs", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "def __init__ ( self , convert_charrefs = False , ** kwargs ) :"}
{"src": ["and", "dictionary", "of", "arbitrary", "length", "**kwargs", "as", "arguments", ".", "call", "the", "initialization", "method", "for", "the", "base", "class", ",", "_html_parser.HTMLParser.__init__", "[", "_html_parser", ".", "HTMLParser", ".", "__init__", "]", "with", "self", ","], "cano_code": "_html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )", "decano_code": "_html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )", "token": ["_html_parser", ".", "HTMLParser", ".", "__init__", "(", "self", ",", "convert_charrefs", "=", "convert_charrefs", ",", "**", "kwargs", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "_html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )"}
{"src": ["convert_charrefs", "set", "to", "convert_charrefs", "and", "dictionary", "**kwargs", "as", "the", "arguments", ".", "if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["substitute", "HTMLParser", "from", "the", "module", "_html_parser", "for", "HTMLParser", "."], "cano_code": "HTMLParser = _html_parser . HTMLParser", "decano_code": "HTMLParser = _html_parser . HTMLParser", "token": ["HTMLParser", "=", "_html_parser", ".", "HTMLParser"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "HTMLParser = _html_parser . HTMLParser"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["compile", "a", "regular", "expression", "pattern", "string", "_STR:0_", "into", "a", "regular", "expression", "object", "and", "assign", "it", "to", "tagfind", "."], "cano_code": "tagfind = re . compile ( '_STR:0_' )", "decano_code": "tagfind = re . compile ( '_STR:0_' )", "token": ["tagfind", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP"], "raw_code": "tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\\s|/(?!>))*' )"}
{"src": ["derive", "the", "class", "HTMLParser", "from", "the", "base", "class", "HTMLParser", "located", "in", "the", "module", "_html_parser", "."], "cano_code": "class HTMLParser ( _html_parser . HTMLParser ) :pass", "decano_code": "class HTMLParser ( _html_parser . HTMLParser ) :", "token": ["class", "HTMLParser", "(", "_html_parser", ".", "HTMLParser", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "class HTMLParser ( _html_parser . HTMLParser ) :"}
{"src": ["define", "initialization", "method", "__init__", "with", "self", "instance", "of", "the", "class", "as", "an", "argument", "."], "cano_code": "def __init__ ( self ) :pass", "decano_code": "def __init__ ( self ) :", "token": ["def", "__init__", "(", "self", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def __init__ ( self ) :"}
{"src": ["call", "the", "initialization", "method", "_html_parser.HTMLParser.__init__", "[", "_html_parser", ".", "HTMLParser", ".", "__init__", "]", "(", "self", ")", "for", "the", "base", "class", "."], "cano_code": "_html_parser . HTMLParser . __init__ ( self )", "decano_code": "_html_parser . HTMLParser . __init__ ( self )", "token": ["_html_parser", ".", "HTMLParser", ".", "__init__", "(", "self", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "_html_parser . HTMLParser . __init__ ( self )"}
{"src": ["set", "field", "cdata_tag", "for", "this", "class", "instance", "to", "None", "."], "cano_code": "self . cdata_tag = None", "decano_code": "self . cdata_tag = None", "token": ["self", ".", "cdata_tag", "=", "None"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD"], "raw_code": "self . cdata_tag = None"}
{"src": ["define", "method", "set_cdata_mode", ",", "with", "self", "class", "instance", "and", "tag", "as", "the", "arguments", "."], "cano_code": "def set_cdata_mode ( self , tag ) :pass", "decano_code": "def set_cdata_mode ( self , tag ) :", "token": ["def", "set_cdata_mode", "(", "self", ",", "tag", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def set_cdata_mode ( self , tag ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["set", "field", "interesting", "for", "this", "class", "instance", "to", "interesting_cdata", "from", "module", "_html_parser", "."], "cano_code": "self . interesting = _html_parser . interesting_cdata", "decano_code": "self . interesting = _html_parser . interesting_cdata", "token": ["self", ".", "interesting", "=", "_html_parser", ".", "interesting_cdata"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . interesting = _html_parser . interesting_cdata"}
{"src": ["if", "AttributeError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept AttributeError :pass", "decano_code": "except AttributeError :", "token": ["except", "AttributeError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except AttributeError :"}
{"src": ["replace", "'", "%", "s", "'", "in", "the", "string", "_STR:0_", "with", "the", "result", "of", "the", "function", "call", "tag.lower", "[", "tag", ".", "lower", "]", "(", ")", ","], "cano_code": "self . interesting = re . compile ( r'_STR:0_' % tag . lower ( ) , re . I )", "decano_code": "self . interesting = re . compile ( r'_STR:0_' % tag . lower ( ) , re . I )", "token": ["self", ".", "interesting", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", "%", "tag", ".", "lower", "(", ")", ",", "re", ".", "I", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "self . interesting = re . compile ( r'</\\s*%s\\s*>' % tag . lower ( ) , re . I )"}
{"src": ["use", "it", "and", "the", "re.I", "[", "re", ".", "I", "]", "as", "the", "input", "arguments", "for", "function", "re.compile", "[", "re", ".", "compile", "]", ",", "put", "the", "result", "in", "the", "self.interesting", "[", "self", ".", "interesting", "]", ".", "evaluate", "function", "tag.lower", "[", "tag", ".", "lower", "]", ",", "without", "the", "arguments", ",", "put", "the", "result", "in", "the", "self.cdata_tag", "[", "self", ".", "cdata_tag", "]", "."], "cano_code": "self . cdata_tag = tag . lower ( )", "decano_code": "self . cdata_tag = tag . lower ( )", "token": ["self", ".", "cdata_tag", "=", "tag", ".", "lower", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "self . cdata_tag = tag . lower ( )"}
{"src": ["define", "method", "clear_cdata_mode", ",", "with", "self", "class", "instance", "as", "an", "argument", "."], "cano_code": "def clear_cdata_mode ( self ) :pass", "decano_code": "def clear_cdata_mode ( self ) :", "token": ["def", "clear_cdata_mode", "(", "self", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def clear_cdata_mode ( self ) :"}
{"src": ["substitute", "_html_parser.interesting_normal", "[", "_html_parser", ".", "interesting_normal", "]", "for", "self.interesting", "[", "self", ".", "interesting", "]", "."], "cano_code": "self . interesting = _html_parser . interesting_normal", "decano_code": "self . interesting = _html_parser . interesting_normal", "token": ["self", ".", "interesting", "=", "_html_parser", ".", "interesting_normal"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . interesting = _html_parser . interesting_normal"}
{"src": ["set", "self.cdata_tag", "[", "self", ".", "cdata_tag", "]", "to", "None", "."], "cano_code": "self . cdata_tag = None", "decano_code": "self . cdata_tag = None", "token": ["self", ".", "cdata_tag", "=", "None"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD"], "raw_code": "self . cdata_tag = None"}
{"src": ["define", "method", "parse_starttag", "with", "self", "class", "instance", "and", "i", "as", "the", "arguments", "."], "cano_code": "def parse_starttag ( self , i ) :pass", "decano_code": "def parse_starttag ( self , i ) :", "token": ["def", "parse_starttag", "(", "self", ",", "i", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def parse_starttag ( self , i ) :"}
{"src": ["set", "self.__starttag_text", "[", "self", ".", "__starttag_text", "]", "to", "None", "."], "cano_code": "self . __starttag_text = None", "decano_code": "self . __starttag_text = None", "token": ["self", ".", "__starttag_text", "=", "None"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD"], "raw_code": "self . __starttag_text = None"}
{"src": ["call", "the", "method", "self.check_for_whole_start_tag", "[", "self", ".", "check_for_whole_start_tag", "]", "with", "i", "as", "an", "argument", ",", "substitute", "result", "for", "the", "endpos", "."], "cano_code": "endpos = self . check_for_whole_start_tag ( i )", "decano_code": "endpos = self . check_for_whole_start_tag ( i )", "token": ["endpos", "=", "self", ".", "check_for_whole_start_tag", "(", "i", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "endpos = self . check_for_whole_start_tag ( i )"}
{"src": ["if", "endpos", "is", "lesser", "than", "zero", ","], "cano_code": "if endpos < 0 :pass", "decano_code": "if endpos < 0 :", "token": ["if", "endpos", "<", "0", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if endpos < 0 :"}
{"src": ["return", "endpos", "."], "cano_code": "return endpos", "decano_code": "return endpos", "token": ["return", "endpos"], "type": ["KEYWORD", "NAME"], "raw_code": "return endpos"}
{"src": ["substitute", "self.rawdata", "[", "self", ".", "rawdata", "]", "for", "rawdata", "."], "cano_code": "rawdata = self . rawdata", "decano_code": "rawdata = self . rawdata", "token": ["rawdata", "=", "self", ".", "rawdata"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "rawdata = self . rawdata"}
{"src": ["slice", "the", "list", "from", "the", "i-th", "to", "the", "endpos-th", "element", ",", "substitute", "it", "for", "self.__starttag_text", "[", "self", ".", "__starttag_text", "]", "."], "cano_code": "self . __starttag_text = rawdata [ i : endpos ]", "decano_code": "self . __starttag_text = rawdata [ i : endpos ]", "token": ["self", ".", "__starttag_text", "=", "rawdata", "[", "i", ":", "endpos", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "self . __starttag_text = rawdata [ i : endpos ]"}
{"src": ["attrs", "is", "a", "empty", "list", "."], "cano_code": "attrs = [ ]", "decano_code": "attrs = [ ]", "token": ["attrs", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "attrs = [ ]"}
{"src": ["match", "the", "rawdata", "from", "the", "position", "i+1", ",", "with", "tagfind", "pattern", ",", "assign", "the", "result", "to", "the", "match", "."], "cano_code": "match = tagfind . match ( rawdata , i + 1 )", "decano_code": "match = tagfind . match ( rawdata , i + 1 )", "token": ["match", "=", "tagfind", ".", "match", "(", "rawdata", ",", "i", "+", "1", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP"], "raw_code": "match = tagfind . match ( rawdata , i + 1 )"}
{"src": ["if", "match", "evaluates", "to", "False", "throw", "an", "exception", "with", "the", "string", "message", "_STR:0_", "."], "cano_code": "assert match , '_STR:0_'", "decano_code": "assert match , '_STR:0_'", "token": ["assert", "match", ",", "\" _STR:0_ \""], "type": ["KEYWORD", "NAME", "OP", "STRING"], "raw_code": "assert match , 'unexpected call to parse_starttag()'"}
{"src": ["find", "the", "ending", "position", "of", "the", "regular", "expression", "match", "of", "the", "object", "match", ",", "substitute", "the", "result", "for", "k", "."], "cano_code": "k = match . end ( )", "decano_code": "k = match . end ( )", "token": ["k", "=", "match", ".", "end", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "k = match . end ( )"}
{"src": ["find", "the", "first", "subgroup", "of", "the", "matched", "string", "from", "the", "match", "object", ",", "convert", "it", "to", "lowercase", ",", "substitute", "it", "for", "tag", "and", "self.lasttag", "[", "self", ".", "lasttag", "]", "."], "cano_code": "self . lasttag = tag = match . group ( 1 ) . lower ( )", "decano_code": "self . lasttag = tag = match . group ( 1 ) . lower ( )", "token": ["self", ".", "lasttag", "=", "tag", "=", "match", ".", "group", "(", "1", ")", ".", "lower", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "self . lasttag = tag = match . group ( 1 ) . lower ( )"}
{"src": ["as", "long", "k", "is", "smaller", "than", "endpos", ","], "cano_code": "while k < endpos :pass", "decano_code": "while k < endpos :", "token": ["while", "k", "<", "endpos", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "while k < endpos :"}
{"src": ["match", "the", "rawdata", "from", "the", "position", "k", ",", "with", "attrfind", "pattern", ",", "assign", "the", "result", "to", "the", "m", "."], "cano_code": "m = _html_parser . attrfind . match ( rawdata , k )", "decano_code": "m = _html_parser . attrfind . match ( rawdata , k )", "token": ["m", "=", "_html_parser", ".", "attrfind", ".", "match", "(", "rawdata", ",", "k", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "m = _html_parser . attrfind . match ( rawdata , k )"}
{"src": ["if", "m", "is", "not", "False", ",", "None", "is", "considered", "False", ","], "cano_code": "if not m :pass", "decano_code": "if not m :", "token": ["if", "not", "m", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not m :"}
{"src": ["breaks", "from", "the", "smallest", "enclosing", "loop", "."], "cano_code": "break", "decano_code": "break", "token": ["break"], "type": ["NAME"], "raw_code": "break"}
{"src": ["find", "the", "first", ",", "second", "and", "third", "subgroup", "of", "the", "m", "regular", "expression", "match", ",", "assign", "the", "result", "to", "the", "attrname", ",", "rest", "and", "attrvalue", ",", "respectively", "."], "cano_code": "attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )", "decano_code": "attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )", "token": ["attrname", ",", "rest", ",", "attrvalue", "=", "m", ".", "group", "(", "1", ",", "2", ",", "3", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "NUMBER", "OP", "NUMBER", "OP"], "raw_code": "attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )"}
{"src": ["if", "rest", "is", "not", "False", ",", "None", "is", "considered", "False", ","], "cano_code": "if not rest :pass", "decano_code": "if not rest :", "token": ["if", "not", "rest", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not rest :"}
{"src": ["set", "attrvalue", "to", "None", "."], "cano_code": "attrvalue = None", "decano_code": "attrvalue = None", "token": ["attrvalue", "=", "None"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "attrvalue = None"}
{"src": ["otherwise", ",", "if", "first", "and", "the", "last", "character", "of", "attrvalue", "are", "_STR:0_", "''", "'", "character", ","], "cano_code": "if True: pass\nelif ( attrvalue [ : 1 ] == '\\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '\"' == attrvalue [ - 1 : ] ) :pass", "decano_code": "elif ( attrvalue [ : 1 ] == '\\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '\"' == attrvalue [ - 1 : ] ) :", "token": ["elif", "(", "attrvalue", "[", ":", "1", "]", "==", "\" \\' \"", "==", "attrvalue", "[", "-", "1", ":", "]", "or", "attrvalue", "[", ":", "1", "]", "==", "\" \" \"", "==", "attrvalue", "[", "-", "1", ":", "]", ")", ":"], "type": ["KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "STRING", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "KEYWORD", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "STRING", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "OP", "OP"], "raw_code": "elif ( attrvalue [ : 1 ] == '\\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '\"' == attrvalue [ - 1 : ] ) :"}
{"src": ["remove", "first", "and", "last", "character", "from", "the", "attrvalue", ",", "substitute", "it", "for", "attrvalue", "."], "cano_code": "attrvalue = attrvalue [ 1 : - 1 ]", "decano_code": "attrvalue = attrvalue [ 1 : - 1 ]", "token": ["attrvalue", "=", "attrvalue", "[", "1", ":", "-", "1", "]"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP"], "raw_code": "attrvalue = attrvalue [ 1 : - 1 ]"}
{"src": ["if", "attrvalue", "is", "not", "an", "empty", "string", ","], "cano_code": "if attrvalue :pass", "decano_code": "if attrvalue :", "token": ["if", "attrvalue", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if attrvalue :"}
{"src": ["call", "the", "method", "unescape", "with", "attrvalue", "as", "the", "argument", "on", "the", "self", "class", "instance", ",", "substitute", "the", "result", "for", "attrvalue", "."], "cano_code": "attrvalue = self . unescape ( attrvalue )", "decano_code": "attrvalue = self . unescape ( attrvalue )", "token": ["attrvalue", "=", "self", ".", "unescape", "(", "attrvalue", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "attrvalue = self . unescape ( attrvalue )"}
{"src": ["form", "the", "tuple", "from", "the", "attrname", "converted", "to", "lowercase", "and", "attrvalue", ",", "append", "it", "to", "the", "end", "of", "attrs", "."], "cano_code": "attrs . append ( ( attrname . lower ( ) , attrvalue ) )", "decano_code": "attrs . append ( ( attrname . lower ( ) , attrvalue ) )", "token": ["attrs", ".", "append", "(", "(", "attrname", ".", "lower", "(", ")", ",", "attrvalue", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "attrs . append ( ( attrname . lower ( ) , attrvalue ) )"}
{"src": ["find", "the", "ending", "position", "of", "the", "regular", "expression", "match", "of", "the", "object", "match", ",", "substitute", "the", "result", "for", "k", "."], "cano_code": "k = m . end ( )", "decano_code": "k = m . end ( )", "token": ["k", "=", "match", ".", "end", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "k = m . end ( )"}
{"src": ["slice", "the", "rawdata", "string", "from", "the", "k-th", "to", "the", "endpos-th", "index", ",", "remove", "the", "whitespaces", "from", "the", "start", "and", "the", "end", "of", "the", "string", ",", "substitute", "it", "for", "end", "."], "cano_code": "end = rawdata [ k : endpos ] . strip ( )", "decano_code": "end = rawdata [ k : endpos ] . strip ( )", "token": ["end", "=", "rawdata", "[", "k", ":", "endpos", "]", ".", "strip", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "end = rawdata [ k : endpos ] . strip ( )"}
{"src": ["if", "end", "is", "not", "a", "_STR:0_", "or", "_STR:1_", "character", ","], "cano_code": "if end not in ( \">\" , \"/>\" ) :pass", "decano_code": "if end not in ( \">\" , \"/>\" ) :", "token": ["if", "end", "not", "in", "(", "\" > \"", ",", "\" /> \"", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP", "STRING", "OP", "STRING", "OP", "OP"], "raw_code": "if end not in ( \">\" , \"/>\" ) :"}
{"src": ["evaluate", "the", "self.getpos", "[", "self", ".", "getpos", "]", "(", ")", "and", "assign", "the", "result", "to", "the", "lineno", "and", "offset", "respectfully", "."], "cano_code": "lineno , offset = self . getpos ( )", "decano_code": "lineno , offset = self . getpos ( )", "token": ["lineno", ",", "offset", "=", "self", ".", "getpos", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "lineno , offset = self . getpos ( )"}
{"src": ["if", "self.__stattag_text", "[", "self", ".", "__stattag_text", "]", "contains", "newline", "character", ","], "cano_code": "if \"\\n\" in self . __starttag_text :pass", "decano_code": "if \"\\n\" in self . __starttag_text :", "token": ["if", "\" \\n \"", "in", "self", ".", "__starttag_text", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if \"\\n\" in self . __starttag_text :"}
{"src": ["increment", "the", "lineno", "by", "the", "count", "of", "the", "newlines", "in", "self.__starttag_text", "[", "self", ".", "__starttag_text", "]", "."], "cano_code": "lineno = lineno + self . __starttag_text . count ( \"\\n\" )", "decano_code": "lineno = lineno + self . __starttag_text . count ( \"\\n\" )", "token": ["lineno", "=", "lineno", "+", "self", ".", "__starttag_text", ".", "count", "(", "\" \\n \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "lineno = lineno + self . __starttag_text . count ( \"\\n\" )"}
{"src": ["find", "the", "last", "index", "of", "newline", "occurrence", "in", "self.__starttag_text", "[", "self", ".", "__starttag_text", "]", ",", "subtract", "it", "from", "total", "length", "of", "self.__starttag_text", "[", "self", ".", "__starttag_text", "]", ","], "cano_code": "offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( \"\\n\" ) )", "decano_code": "offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( \"\\n\" ) )", "token": ["offset", "=", "(", "len", "(", "self", ".", "__starttag_text", ")", "-", "self", ".", "__starttag_text", ".", "rfind", "(", "\" \\n \"", ")", ")"], "type": ["NAME", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( \"\\n\" ) )"}
{"src": ["substitute", "the", "result", "for", "offset", ".", "if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["increment", "the", "offset", "by", "the", "length", "of", "self.__starttag_text", "[", "self", ".", "__starttag_text", "]", "."], "cano_code": "offset = offset + len ( self . __starttag_text )", "decano_code": "offset = offset + len ( self . __starttag_text )", "token": ["offset", "=", "offset", "+", "len", "(", "self", ".", "__starttag_text", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "offset = offset + len ( self . __starttag_text )"}
{"src": ["slice", "the", "rawdata", "from", "k", "to", "endpos", ",", "then", "take", "the", "first", "20", "elements", "of", "the", "previous", "slice", ","], "cano_code": "self . error ( \"junk characters in start tag: %r\"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )", "decano_code": "self . error ( \"junk characters in start tag: %r\"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )", "token": ["self", ".", "error", "(", "\" junk characters in start tag: %r \"", "%", "(", "rawdata", "[", "k", ":", "endpos", "]", "[", ":", "20", "]", ",", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NUMBER", "OP", "OP", "OP", "OP"], "raw_code": "self . error ( \"junk characters in start tag: %r\"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )"}
{"src": ["with", "it", "replace", "%", "r", "in", "the", "string", "_STR:0_", ",", "call", "the", "method", "self.error", "[", "self", ".", "error", "]", "with", "the", "resulting", "string", "as", "an", "argument", ".", "if", "string", "end", "ends", "with", "string", "_STR:1_", ","], "cano_code": "if end . endswith ( '_STR:1_' ) :pass", "decano_code": "if end . endswith ( '_STR:1_' ) :", "token": ["if", "end", ".", "endswith", "(", "\" _STR:1_ \"", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "if end . endswith ( '/>' ) :"}
{"src": ["call", "the", "method", "self.handle_startendtag", "[", "self", ".", "handle_startendtag", "]", "with", "tag", "and", "attrs", "as", "the", "arguments", "."], "cano_code": "self . handle_startendtag ( tag , attrs )", "decano_code": "self . handle_startendtag ( tag , attrs )", "token": ["self", ".", "handle_startendtag", "(", "tag", ",", "attrs", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "self . handle_startendtag ( tag , attrs )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["call", "the", "method", "self.handle_starttag", "[", "self", ".", "handle_starttag", "]", ",", "with", "tag", "and", "attrs", "as", "the", "arguments", "."], "cano_code": "self . handle_starttag ( tag , attrs )", "decano_code": "self . handle_starttag ( tag , attrs )", "token": ["self", ".", "handle_starttag", "(", "tag", ",", "attrs", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "self . handle_starttag ( tag , attrs )"}
{"src": ["if", "tag", "is", "contained", "in", "self.CDATA_CONTENT_ELEMENTS", "[", "self", ".", "CDATA_CONTENT_ELEMENTS", "]", ","], "cano_code": "if tag in self . CDATA_CONTENT_ELEMENTS :pass", "decano_code": "if tag in self . CDATA_CONTENT_ELEMENTS :", "token": ["if", "tag", "in", "self", ".", "CDATA_CONTENT_ELEMENTS", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if tag in self . CDATA_CONTENT_ELEMENTS :"}
{"src": ["call", "the", "method", "self.set_cdata_mode", "[", "self", ".", "set_cdata_mode", "]", "with", "tag", "as", "the", "argument", "."], "cano_code": "self . set_cdata_mode ( tag )", "decano_code": "self . set_cdata_mode ( tag )", "token": ["self", ".", "set_cdata_mode", "(", "tag", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "self . set_cdata_mode ( tag )"}
{"src": ["return", "endpos", "."], "cano_code": "return endpos", "decano_code": "return endpos", "token": ["return", "endpos"], "type": ["KEYWORD", "NAME"], "raw_code": "return endpos"}
{"src": ["define", "the", "method", "parse_endtag", "with", "self", "class", "instance", "and", "i", "as", "the", "arguments", "."], "cano_code": "def parse_endtag ( self , i ) :pass", "decano_code": "def parse_endtag ( self , i ) :", "token": ["def", "parse_endtag", "(", "self", ",", "i", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def parse_endtag ( self , i ) :"}
{"src": ["substitute", "self.rawdata", "[", "self", ".", "rawdata", "]", "for", "rawdata", "."], "cano_code": "rawdata = self . rawdata", "decano_code": "rawdata = self . rawdata", "token": ["rawdata", "=", "self", ".", "rawdata"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "rawdata = self . rawdata"}
{"src": ["take", "two", "characters", "from", "the", "i-th", "element", "of", "rawdata", ",", "if", "they", "are", "not", "equal", "to", "the", "string", "_STR:0_", ","], "cano_code": "assert rawdata [ i : i + 2 ] == \"</\" , \"unexpected call to parse_endtag\"", "decano_code": "assert rawdata [ i : i + 2 ] == \"</\" , \"unexpected call to parse_endtag\"", "token": ["assert", "rawdata", "[", "i", ":", "i", "+", "2", "]", "==", "\" </ \"", ",", "\" unexpected call to parse_endtag \""], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "STRING", "OP", "STRING"], "raw_code": "assert rawdata [ i : i + 2 ] == \"</\" , \"unexpected call to parse_endtag\""}
{"src": ["throw", "an", "exception", "with", "string", "_STR:0_", "as", "the", "message", ".", "search", "anywhere", "in", "the", "rawdata", "string", "starting", "from", "the", "(", "i+1", ")", "-th", "element", "for", "the", "_html_parser.endendeag", "[", "_html_parser", ".", "endendeag", "]", ",", "replace", "the", "result", "for", "match", "."], "cano_code": "match = _html_parser . endendtag . search ( rawdata , i + 1 )", "decano_code": "match = _html_parser . endendtag . search ( rawdata , i + 1 )", "token": ["match", "=", "_html_parser", ".", "endendtag", ".", "search", "(", "rawdata", ",", "i", "+", "1", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP"], "raw_code": "match = _html_parser . endendtag . search ( rawdata , i + 1 )"}
{"src": ["if", "there", "is", "no", "match", ","], "cano_code": "if not match :pass", "decano_code": "if not match :", "token": ["if", "not", "match", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not match :"}
{"src": ["return", "integer", "-1", "."], "cano_code": "return - 1", "decano_code": "return - 1", "token": ["return", "-", "1"], "type": ["KEYWORD", "OP", "NUMBER"], "raw_code": "return - 1"}
{"src": ["find", "the", "ending", "position", "of", "the", "regular", "expression", "match", "of", "the", "object", "match", ",", "substitute", "the", "result", "for", "j", "."], "cano_code": "j = match . end ( )", "decano_code": "j = match . end ( )", "token": ["j", "=", "match", ".", "end", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "j = match . end ( )"}
{"src": ["match", "the", "rawdata", "from", "the", "position", "i", ",", "with", "_html_parser.endtagfind", "[", "_html_parser", ".", "endtagfind", "]", "pattern", ",", "assign", "the", "result", "to", "the", "match", "."], "cano_code": "match = _html_parser . endtagfind . match ( rawdata , i )", "decano_code": "match = _html_parser . endtagfind . match ( rawdata , i )", "token": ["match", "=", "_html_parser", ".", "endtagfind", ".", "match", "(", "rawdata", ",", "i", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "match = _html_parser . endtagfind . match ( rawdata , i )"}
{"src": ["if", "there", "is", "no", "match", ","], "cano_code": "if not match :pass", "decano_code": "if not match :", "token": ["if", "not", "match", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not match :"}
{"src": ["if", "self.cdata_tag", "[", "self", ".", "cdata_tag", "]", "is", "not", "None", ","], "cano_code": "if self . cdata_tag is not None :pass", "decano_code": "if self . cdata_tag is not None :", "token": ["if", "self", ".", "cdata_tag", "is", "not", "None", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if self . cdata_tag is not None :"}
{"src": ["slice", "the", "rawdata", "to", "obtain", "substring", "from", "i-th", "to", "j-th", "element", ",", "use", "it", "as", "the", "argument", "for", "the", "method", "call", "to", "the", "self.handle_data", "[", "self", ".", "handle_data", "]", "."], "cano_code": "self . handle_data ( rawdata [ i : j ] )", "decano_code": "self . handle_data ( rawdata [ i : j ] )", "token": ["self", ".", "handle_data", "(", "rawdata", "[", "i", ":", "j", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "self . handle_data ( rawdata [ i : j ] )"}
{"src": ["return", "j", "."], "cano_code": "return j", "decano_code": "return j", "token": ["return", "j"], "type": ["KEYWORD", "NAME"], "raw_code": "return j"}
{"src": ["slice", "the", "rawdata", "from", "i-th", "to", "the", "j-th", "element", ",", "replace", "with", "it", "_STR:0_", "in", "the", "string", "_STR:1_", ",", "use", "it", "to", "call", "the", "method", "self.error", "[", "self", ".", "error", "]", "."], "cano_code": "self . error ( '_STR:1_' % ( rawdata [ i : j ] , ) )", "decano_code": "self . error ( '_STR:1_' % ( rawdata [ i : j ] , ) )", "token": ["self", ".", "error", "(", "\" _STR:1_ \"", "%", "(", "rawdata", "[", "i", ":", "j", "]", ",", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "OP"], "raw_code": "self . error ( \"bad end tag: %r\" % ( rawdata [ i : j ] , ) )"}
{"src": ["find", "the", "first", "subgroup", "of", "the", "matched", "string", "from", "the", "match", "object", ",", "strip", "the", "whitespaces", "from", "the", "begging", "and", "end", ",", "replace", "it", "for", "tag", "."], "cano_code": "tag = match . group ( 1 ) . strip ( )", "decano_code": "tag = match . group ( 1 ) . strip ( )", "token": ["tag", "=", "match", ".", "group", "(", "1", ")", ".", "strip", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "tag = match . group ( 1 ) . strip ( )"}
{"src": ["if", "self.cdata_tag", "[", "self", ".", "cdata_tag", "]", "is", "not", "None", ","], "cano_code": "if self . cdata_tag is not None :pass", "decano_code": "if self . cdata_tag is not None :", "token": ["if", "self", ".", "cdata_tag", "is", "not", "None", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if self . cdata_tag is not None :"}
{"src": ["convert", "tag", "to", "lowercase", "if", "it", "is", "not", "equal", "to", "self.cdata_tag", "[", "self", ".", "cdata_tag", "]", ","], "cano_code": "if tag . lower ( ) != self . cdata_tag :pass", "decano_code": "if tag . lower ( ) != self . cdata_tag :", "token": ["if", "tag", ".", "lower", "(", ")", "!=", "self", ".", "cdata_tag", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "if tag . lower ( ) != self . cdata_tag :"}
{"src": ["slice", "the", "rawdata", "to", "obtain", "substring", "from", "i-th", "to", "j-th", "element", ",", "use", "it", "as", "the", "argument", "for", "the", "method", "call", "to", "the", "self.handle_data", "[", "self", ".", "handle_data", "]", "."], "cano_code": "self . handle_data ( rawdata [ i : j ] )", "decano_code": "self . handle_data ( rawdata [ i : j ] )", "token": ["self", ".", "handle_data", "(", "rawdata", "[", "i", ":", "j", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "self . handle_data ( rawdata [ i : j ] )"}
{"src": ["return", "j", "."], "cano_code": "return j", "decano_code": "return j", "token": ["return", "j"], "type": ["KEYWORD", "NAME"], "raw_code": "return j"}
{"src": ["convert", "tag", "to", "lowercase", ",", "use", "it", "as", "the", "argument", "for", "the", "call", "to", "the", "method", "self.handle_endtag", "[", "self", ".", "handle_endtag", "]", "."], "cano_code": "self . handle_endtag ( tag . lower ( ) )", "decano_code": "self . handle_endtag ( tag . lower ( ) )", "token": ["self", ".", "handle_endtag", "(", "tag", ".", "lower", "(", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "self . handle_endtag ( tag . lower ( ) )"}
{"src": ["call", "the", "method", "self.clear_cdata_mode", "[", "self", ".", "clear_cdata_mode", "]", "."], "cano_code": "self . clear_cdata_mode ( )", "decano_code": "self . clear_cdata_mode ( )", "token": ["self", ".", "clear_cdata_mode", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP"], "raw_code": "self . clear_cdata_mode ( )"}
{"src": ["return", "j", "."], "cano_code": "return j", "decano_code": "return j", "token": ["return", "j"], "type": ["KEYWORD", "NAME"], "raw_code": "return j"}
{"src": ["from", "__future__", "import", "unicode_literals", "into", "default", "name", "space", "."], "cano_code": "from __future__ import unicode_literals", "decano_code": "from __future__ import unicode_literals", "token": ["from", "__future__", "import", "unicode_literals"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from __future__ import unicode_literals"}
{"src": ["import", "module", "base64", "."], "cano_code": "import base64", "decano_code": "import base64", "token": ["import", "base64"], "type": ["KEYWORD", "NAME"], "raw_code": "import base64"}
{"src": ["import", "module", "calendar", "."], "cano_code": "import calendar", "decano_code": "import calendar", "token": ["import", "calendar"], "type": ["KEYWORD", "NAME"], "raw_code": "import calendar"}
{"src": ["import", "module", "datetime", "."], "cano_code": "import datetime", "decano_code": "import datetime", "token": ["import", "datetime"], "type": ["KEYWORD", "NAME"], "raw_code": "import datetime"}
{"src": ["import", "module", "re", "."], "cano_code": "import re", "decano_code": "import re", "token": ["import", "re"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "import re"}
{"src": ["import", "module", "sys", "."], "cano_code": "import sys", "decano_code": "import sys", "token": ["import", "sys"], "type": ["KEYWORD", "NAME"], "raw_code": "import sys"}
{"src": ["from", "binascii", "import", "Error", "as", "BinasciiError", "into", "default", "name", "space", "."], "cano_code": "from binascii import Error as BinasciiError", "decano_code": "from binascii import Error as BinasciiError", "token": ["from", "binascii", "import", "Error", "as", "BinasciiError"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from binascii import Error as BinasciiError"}
{"src": ["from", "email.utils", "[", "email", ".", "utils", "]", "import", "formatdate", "into", "default", "name", "space", "."], "cano_code": "from email . utils import formatdate", "decano_code": "from email . utils import formatdate", "token": ["from", "email", ".", "utils", "import", "formatdate"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from email . utils import formatdate"}
{"src": ["from", "django.utils.datastructures", "[", "django", ".", "utils", ".", "datastructures", "]", "import", "MultiValueDict", "into", "default", "name", "space", "."], "cano_code": "from django . utils . datastructures import MultiValueDict", "decano_code": "from django . utils . datastructures import MultiValueDict", "token": ["from", "django", ".", "utils", ".", "datastructures", "import", "MultiValueDict"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . datastructures import MultiValueDict"}
{"src": ["from", "django.utils.encoding", "[", "django", ".", "utils", ".", "encoding", "]", "import", "force_str", "and", "force_text", "into", "default", "name", "space", "."], "cano_code": "from django . utils . encoding import force_str , force_text", "decano_code": "from django . utils . encoding import force_str , force_text", "token": ["from", "django", ".", "utils", ".", "encoding", "import", "force_str", ",", "force_text"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME"], "raw_code": "from django . utils . encoding import force_str , force_text"}
{"src": ["from", "django.utils.functional", "[", "django", ".", "utils", ".", "functional", "]", "import", "allow_lazy", "into", "default", "name", "space", "."], "cano_code": "from django . utils . functional import allow_lazy", "decano_code": "from django . utils . functional import allow_lazy", "token": ["from", "django", ".", "utils", ".", "functional", "import", "allow_lazy"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . functional import allow_lazy"}
{"src": ["from", "django.utils", "[", "django", ".", "utils", "]", "import", "six", "into", "default", "name", "space", "."], "cano_code": "from django . utils import six", "decano_code": "from django . utils import six", "token": ["from", "django", ".", "utils", "import", "six"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils import six"}
{"src": ["from", "django.utils.six.moves.urllib.parse", "[", "django", ".", "utils", ".", "six", ".", "moves", ".", "urllib", ".", "parse", "]", "import", "quote", ",", "quote_plus", ",", "unquote", ",", "unquote_plus", ",", "urlparse", ",", "urlencode", "as", "original_urlencode", "."], "cano_code": "from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )", "decano_code": "from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )", "token": ["from", "django", ".", "utils", ".", "six", ".", "moves", ".", "urllib", ".", "parse", "import", "(", "quote", ",", "quote_plus", ",", "unquote", ",", "unquote_plus", ",", "urlparse", ",", "urlencode", "as", "original_urlencode", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )"}
{"src": ["call", "the", "function", "re.compile", "[", "re", ".", "compile", "]", "with", "an", "argument", "raw", "string", "_STR:0_", ",", "substitute", "the", "result", "for", "ETAG_MATCH", "."], "cano_code": "ETAG_MATCH = re . compile ( r'_STR:0_' )", "decano_code": "ETAG_MATCH = re . compile ( r'_STR:0_' )", "token": ["ETAG_MATCH", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP"], "raw_code": "ETAG_MATCH = re . compile ( r'(?:W/)?\"((?:\\\\.|[^\"])*)\"' )"}
{"src": ["MONTHS", "is", "a", "list", "with", "12", "elements", ":", "strings", "_STR:0_", ",", "_STR:1_", ",", "_STR:2_", ",", "_STR:3_", ",", "_STR:4_", ",", "_STR:5_", ",", "_STR:6_", ",", "_STR:7_", ",", "_STR:8_", ",", "_STR:9_", ",", "_STR:10_", ",", "and", "_STR:11_", "."], "cano_code": "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )", "decano_code": "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )", "token": ["MONTHS", "=", "\" jan feb mar apr may jun jul aug sep oct nov dec \"", ".", "split", "(", ")"], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "OP"], "raw_code": "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )"}
{"src": ["__D", "is", "a", "raw", "string", "_STR:0_", "."], "cano_code": "__D = r'_STR:0_'", "decano_code": "__D = r'_STR:0_'", "token": ["__D", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "__D = r'(?P<day>\\d{2})'"}
{"src": ["__D2", "is", "a", "raw", "string", "_STR:0_", "."], "cano_code": "__D2 = r'_STR:0_'", "decano_code": "__D2 = r'_STR:0_'", "token": ["__D2", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "__D2 = r'(?P<day>[ \\d]\\d)'"}
{"src": ["__M", "is", "a", "raw", "string", "_STR:0_", "."], "cano_code": "__M = r'_STR:0_'", "decano_code": "__M = r'_STR:0_'", "token": ["__M", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "__M = r'(?P<mon>\\w{3})'"}
{"src": ["__Y", "is", "a", "raw", "string", "_STR:0_", "."], "cano_code": "__Y = r'_STR:0_'", "decano_code": "__Y = r'_STR:0_'", "token": ["__Y", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "__Y = r'(?P<year>\\d{4})'"}
{"src": ["__Y2", "is", "a", "raw", "string", "_STR:0_", "."], "cano_code": "__Y2 = r'_STR:0_'", "decano_code": "__Y2 = r'_STR:0_'", "token": ["__Y2", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "__Y2 = r'(?P<year>\\d{2})'"}
{"src": ["__T", "is", "a", "raw", "string", "_STR:0_", "."], "cano_code": "__T = r'_STR:0_'", "decano_code": "__T = r'_STR:0_'", "token": ["__T", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'"}
{"src": ["call", "the", "function", "re.compile", "[", "re", ".", "compile", "]", "with", "an", "argument", "raw", "string", "_STR:0_", "formated", "with", "__D", ",", "__M", ",", "__Y", "and", "__T", ","], "cano_code": "RFC1123_DATE = re . compile ( r'_STR:0_' % ( __D , __M , __Y , __T ) )", "decano_code": "RFC1123_DATE = re . compile ( r'_STR:0_' % ( __D , __M , __Y , __T ) )", "token": ["RFC1123_DATE", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", "%", "(", "__D", ",", "__M", ",", "__Y", ",", "__T", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "RFC1123_DATE = re . compile ( r'^\\w{3}, %s %s %s %s GMT$' % ( __D , __M , __Y , __T ) )"}
{"src": ["substitute", "the", "result", "for", "RFC1123_DATE", ".", "call", "the", "function", "re.compile", "[", "re", ".", "compile", "]", "with", "an", "argument", "raw", "string", "_STR:0_", "formated", "with", "__D", ",", "__M", ",", "__Y2", "and", "__T", ","], "cano_code": "RFC850_DATE = re . compile ( r'_STR:0_' % ( __D , __M , __Y2 , __T ) )", "decano_code": "RFC850_DATE = re . compile ( r'_STR:0_' % ( __D , __M , __Y2 , __T ) )", "token": ["RFC850_DATE", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", "%", "(", "__D", ",", "__M", ",", "__Y2", ",", "__T", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "RFC850_DATE = re . compile ( r'^\\w{6,9}, %s-%s-%s %s GMT$' % ( __D , __M , __Y2 , __T ) )"}
{"src": ["substitute", "the", "result", "for", "RFC850_DATE", ".", "call", "the", "function", "re.compile", "[", "re", ".", "compile", "]", "with", "an", "argument", "raw", "string", "_STR:0_", "formated", "with", "__M", ",", "__D2", ",", "__T", "and", "__Y", ","], "cano_code": "ASCTIME_DATE = re . compile ( r'_STR:0_' % ( __M , __D2 , __T , __Y ) )", "decano_code": "ASCTIME_DATE = re . compile ( r'_STR:0_' % ( __M , __D2 , __T , __Y ) )", "token": ["ASCTIME_DATE", "=", "re", ".", "compile", "(", "\" _STR:0_ \"", "%", "(", "__M", ",", "__D2", ",", "__T", ",", "__Y", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "ASCTIME_DATE = re . compile ( r'^\\w{3} %s %s %s %s$' % ( __M , __D2 , __T , __Y ) )"}
{"src": ["substitute", "the", "result", "for", "ASCTIME_DATE", ".", "define", "the", "function", "urlquote", "with", "2", "arguments", ":", "url", "and", "safe", "set", "to", "_STR:0_", "."], "cano_code": "def urlquote ( url , safe = '_STR:0_' ) :pass", "decano_code": "def urlquote ( url , safe = '_STR:0_' ) :", "token": ["def", "urlquote", "(", "url", ",", "safe", "=", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "def urlquote ( url , safe = '/' ) :"}
{"src": ["call", "the", "function", "quote", "with", "2", "arguments", ":", "result", "of", "the", "function", "force_str", "called", "with", "an", "argument", "url", ","], "cano_code": "return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )", "decano_code": "return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )", "token": ["return", "force_text", "(", "quote", "(", "force_str", "(", "url", ")", ",", "force_str", "(", "safe", ")", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )"}
{"src": ["and", "result", "of", "the", "function", "force_str", "called", "with", "an", "argument", "safe", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "force_text", ",", "return", "the", "result", ".", "call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "urlquote", "and", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "urlquote", "."], "cano_code": "urlquote = allow_lazy ( urlquote , six . text_type )", "decano_code": "urlquote = allow_lazy ( urlquote , six . text_type )", "token": ["urlquote", "=", "allow_lazy", "(", "urlquote", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "urlquote = allow_lazy ( urlquote , six . text_type )"}
{"src": ["define", "the", "function", "urlquote_plus", "with", "2", "arguments", ":", "url", "and", "safe", "set", "to", "an", "empty", "string", "."], "cano_code": "def urlquote_plus ( url , safe = '' ) :pass", "decano_code": "def urlquote_plus ( url , safe = '' ) :", "token": ["def", "urlquote_plus", "(", "url", ",", "safe", "=", "\"  \"", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "def urlquote_plus ( url , safe = '' ) :"}
{"src": ["call", "the", "function", "quote_plus", "with", "2", "arguments", ":", "result", "of", "the", "function", "force_str", "called", "with", "an", "argument", "url", ","], "cano_code": "return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )", "decano_code": "return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )", "token": ["return", "force_text", "(", "quote_plus", "(", "force_str", "(", "url", ")", ",", "force_str", "(", "safe", ")", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )"}
{"src": ["and", "result", "of", "the", "function", "force_str", "called", "with", "an", "argument", "safe", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "force_text", ",", "return", "the", "result", ".", "call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "urlquote_plus", "and", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "urlquote_plus", "."], "cano_code": "urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )", "decano_code": "urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )", "token": ["urlquote_plus", "=", "allow_lazy", "(", "urlquote_plus", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )"}
{"src": ["define", "the", "function", "urlunquote", "with", "an", "argument", "quoted_url", "."], "cano_code": "def urlunquote ( quoted_url ) :pass", "decano_code": "def urlunquote ( quoted_url ) :", "token": ["def", "urlunquote", "(", "quoted_url", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def urlunquote ( quoted_url ) :"}
{"src": ["call", "the", "function", "force_str", "with", "an", "argument", "quoted_url", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "unquote", ","], "cano_code": "return force_text ( unquote ( force_str ( quoted_url ) ) )", "decano_code": "return force_text ( unquote ( force_str ( quoted_url ) ) )", "token": ["return", "force_text", "(", "unquote", "(", "force_str", "(", "quoted_url", ")", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "return force_text ( unquote ( force_str ( quoted_url ) ) )"}
{"src": ["use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "force_text", ",", "return", "the", "result", ".", "call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "urlunquote", "and", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "urlunquote", "."], "cano_code": "urlunquote = allow_lazy ( urlunquote , six . text_type )", "decano_code": "urlunquote = allow_lazy ( urlunquote , six . text_type )", "token": ["urlunquote", "=", "allow_lazy", "(", "urlunquote", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "urlunquote = allow_lazy ( urlunquote , six . text_type )"}
{"src": ["define", "the", "function", "urlunquote", "with", "an", "argument", "quoted_url", "."], "cano_code": "def urlunquote_plus ( quoted_url ) :pass", "decano_code": "def urlunquote_plus ( quoted_url ) :", "token": ["def", "urlunquote", "(", "quoted_url", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def urlunquote_plus ( quoted_url ) :"}
{"src": ["call", "the", "function", "force_str", "with", "an", "argument", "quoted_url", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "unquote_plus", ","], "cano_code": "return force_text ( unquote_plus ( force_str ( quoted_url ) ) )", "decano_code": "return force_text ( unquote_plus ( force_str ( quoted_url ) ) )", "token": ["return", "force_text", "(", "unquote_plus", "(", "force_str", "(", "quoted_url", ")", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "return force_text ( unquote_plus ( force_str ( quoted_url ) ) )"}
{"src": ["use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "force_text", ",", "return", "the", "result", ".", "call", "the", "function", "allow_lazy", "with", "2", "arguments", ":", "urlunquote_plus", "and", "six.text_type", "[", "six", ".", "text_type", "]", ",", "substitute", "the", "result", "for", "urlunquote_plus", "."], "cano_code": "urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )", "decano_code": "urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )", "token": ["urlunquote_plus", "=", "allow_lazy", "(", "urlunquote_plus", ",", "six", ".", "text_type", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )"}
{"src": ["define", "the", "function", "urlencode", "with", "2", "arguments", "query", "and", "doseq", "set", "to", "integer", "0", "."], "cano_code": "def urlencode ( query , doseq = 0 ) :pass", "decano_code": "def urlencode ( query , doseq = 0 ) :", "token": ["def", "urlencode", "(", "query", ",", "doseq", "=", "0", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP"], "raw_code": "def urlencode ( query , doseq = 0 ) :"}
{"src": ["if", "query", "is", "an", "instance", "of", "MultiValueDict", "class", ","], "cano_code": "if isinstance ( query , MultiValueDict ) :pass", "decano_code": "if isinstance ( query , MultiValueDict ) :", "token": ["if", "isinstance", "(", "query", ",", "MultiValueDict", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if isinstance ( query , MultiValueDict ) :"}
{"src": ["call", "the", "method", "query.lists", "[", "query", ".", "lists", "]", ",", "substitute", "the", "result", "for", "query", "."], "cano_code": "query = query . lists ( )", "decano_code": "query = query . lists ( )", "token": ["query", "=", "query", ".", "lists", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "query = query . lists ( )"}
{"src": ["otherwise", "if", "query", "has", "an", "attribute", "_STR:0_", ","], "cano_code": "if True: pass\nelif hasattr ( query , '_STR:0_' ) :pass", "decano_code": "elif hasattr ( query , '_STR:0_' ) :", "token": ["elif", "hasattr", "(", "query", ",", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "elif hasattr ( query , 'items' ) :"}
{"src": ["call", "the", "method", "query.items", "[", "query", ".", "items", "]", ",", "substitute", "the", "result", "for", "query", "."], "cano_code": "query = query . items ( )", "decano_code": "query = query . items ( )", "token": ["query", "=", "query", ".", "items", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "query = query . items ( )"}
{"src": ["call", "the", "function", "original_urlencode", "with", "2", "arguments", ":", "list", "with", "2", "elements", ":", "result", "of", "the", "function", "force_str", "with", "an", "argument", "k", ","], "cano_code": "return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )", "decano_code": "return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )", "token": ["return", "original_urlencode", "(", "[", "(", "force_str", "(", "k", ")", ",", "[", "force_str", "(", "i", ")", "for", "i", "in", "v", "]", "if", "isinstance", "(", "v", ",", "(", "list", ",", "tuple", ")", ")", "else", "force_str", "(", "v", ")", ")", "for", "k", ",", "v", "in", "query", "]", ",", "doseq", ")"], "type": ["KEYWORD", "NAME", "OP", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "OP", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )"}
{"src": ["and", "list", "with", "results", "of", "the", "function", "force_str", "with", "an", "argument", "i", ",", "for", "every", "i", "in", "v", ",", "only", "if", "v", "is", "a", "list", "or", "a", "tuple", ",", "otherwise", "second", "element", "is", "result", "of", "the", "function", "force_str", "with", "an", "argument", "v", ",", "for", "every", "k", "and", "v", "in", "query", ",", "and", "doseq", ",", "return", "the", "result", ".", "define", "the", "function", "cookie_date", "with", "an", "argument", "epoch_seconds", "set", "to", "None", "."], "cano_code": "def cookie_date ( epoch_seconds = None ) :pass", "decano_code": "def cookie_date ( epoch_seconds = None ) :", "token": ["def", "cookie_date", "(", "epoch_seconds", "=", "None", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def cookie_date ( epoch_seconds = None ) :"}
{"src": ["call", "the", "function", "formatdate", "with", "an", "argument", "epoch_seconds", ",", "substitute", "the", "result", "for", "rfcdate", "."], "cano_code": "rfcdate = formatdate ( epoch_seconds )", "decano_code": "rfcdate = formatdate ( epoch_seconds )", "token": ["rfcdate", "=", "formatdate", "(", "epoch_seconds", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "rfcdate = formatdate ( epoch_seconds )"}
{"src": ["return", "a", "string", "_STR:0_", ",", "formated", "with", ":", "first", "7", "elements", "of", "rfcdate", ",", "elements", "of", "rfcdate", "from", "8-th", "to", "the", "11-th", "index", ","], "cano_code": "return '_STR:0_' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )", "decano_code": "return '_STR:0_' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )", "token": ["return", "\" _STR:0_ \"", "%", "(", "rfcdate", "[", ":", "7", "]", ",", "rfcdate", "[", "8", ":", "11", "]", ",", "rfcdate", "[", "12", ":", "25", "]", ")"], "type": ["KEYWORD", "STRING", "OP", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP"], "raw_code": "return '%s-%s-%s GMT' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )"}
{"src": ["and", "elements", "of", "rfcdate", "from", "12-th", "to", "the", "25-th", "index", ".", "define", "the", "function", "http_date", "with", "an", "argument", "epoch_seconds", "set", "to", "None", "."], "cano_code": "def http_date ( epoch_seconds = None ) :pass", "decano_code": "def http_date ( epoch_seconds = None ) :", "token": ["def", "http_date", "(", "epoch_seconds", "=", "None", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def http_date ( epoch_seconds = None ) :"}
{"src": ["call", "the", "function", "formatdate", "with", "2", "arguments", ":", "epoch_seconds", "and", "usegmt", "set", "to", "boolean", "True", ",", "return", "the", "result", "."], "cano_code": "return formatdate ( epoch_seconds , usegmt = True )", "decano_code": "return formatdate ( epoch_seconds , usegmt = True )", "token": ["return", "formatdate", "(", "epoch_seconds", ",", "usegmt", "=", "True", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP"], "raw_code": "return formatdate ( epoch_seconds , usegmt = True )"}
{"src": ["define", "the", "function", "parse_http_date", "with", "an", "argument", "date", "."], "cano_code": "def parse_http_date ( date ) :pass", "decano_code": "def parse_http_date ( date ) :", "token": ["def", "parse_http_date", "(", "date", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def parse_http_date ( date ) :"}
{"src": ["for", "every", "regex", "in", "tuple", "with", "3", "elements", ":", "RFC1123_DATE", ",", "RFC850_DATE", "and", "ASCTIME_DATE", ","], "cano_code": "for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :pass", "decano_code": "for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :", "token": ["for", "regex", "in", "RFC1123_DATE", ",", "RFC850_DATE", ",", "ASCTIME_DATE", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :"}
{"src": ["call", "the", "method", "regex.match", "[", "regex", ".", "match", "]", "with", "an", "argument", "date", ",", "substitute", "the", "result", "for", "m", "."], "cano_code": "m = regex . match ( date )", "decano_code": "m = regex . match ( date )", "token": ["m", "=", "regex", ".", "match", "(", "date", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "m = regex . match ( date )"}
{"src": ["if", "m", "is", "not", "None", ","], "cano_code": "if m is not None :pass", "decano_code": "if m is not None :", "token": ["if", "m", "is", "not", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if m is not None :"}
{"src": ["break", "from", "the", "loop", "execution", "."], "cano_code": "break", "decano_code": "break", "token": ["break"], "type": ["NAME"], "raw_code": "break"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["raise", "an", "ValueError", "exception", "with", "an", "argument", "string", "_STR:0_", "formated", "with", "date", "."], "cano_code": "raise ValueError ( '_STR:0_' % date )", "decano_code": "raise ValueError ( '_STR:0_' % date )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", "%", "date", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "raise ValueError ( \"%r is not in a valid HTTP date format\" % date )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "method", "m.group", "[", "m", ".", "group", "]", "with", "an", "argument", "string", "_STR:0_", ",", "convert", "the", "result", "into", "a", "string", ",", "substitute", "it", "for", "year", "."], "cano_code": "year = int ( m . group ( '_STR:0_' ) )", "decano_code": "year = int ( m . group ( '_STR:0_' ) )", "token": ["year", "=", "int", "(", "m", ".", "group", "(", "\" _STR:0_ \"", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "year = int ( m . group ( 'year' ) )"}
{"src": ["if", "year", "is", "lesser", "than", "integer", "100", ","], "cano_code": "if year < 100 :pass", "decano_code": "if year < 100 :", "token": ["if", "year", "<", "100", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if year < 100 :"}
{"src": ["if", "year", "is", "lesser", "than", "integer", "70", ","], "cano_code": "if year < 70 :pass", "decano_code": "if year < 70 :", "token": ["if", "year", "<", "70", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if year < 70 :"}
{"src": ["increment", "year", "by", "integer", "2000", "."], "cano_code": "year += 2000", "decano_code": "year += 2000", "token": ["year", "+=", "2000"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "year += 2000"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["increment", "year", "by", "integer", "1900", "."], "cano_code": "year += 1900", "decano_code": "year += 1900", "token": ["year", "+=", "1900"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "year += 1900"}
{"src": ["call", "the", "method", "m.group", "[", "m", ".", "group", "]", "with", "an", "argument", "string", "_STR:0_", ",", "convert", "the", "result", "to", "lowercase", ",", "use", "it", "as", "an", "argument", "for", "the", "call", "to", "the", ","], "cano_code": "month = MONTHS . index ( m . group ( '_STR:0_' ) . lower ( ) ) + 1", "decano_code": "month = MONTHS . index ( m . group ( '_STR:0_' ) . lower ( ) ) + 1", "token": ["month", "=", "MONTHS", ".", "index", "(", "m", ".", "group", "(", "\" _STR:0_ \"", ")", ".", "lower", "(", ")", ")", "+", "1"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "OP", "OP", "OP", "NUMBER"], "raw_code": "month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1"}
{"src": ["method", "MONTHS.index", "[", "MONTHS", ".", "index", "]", ",", "increment", "the", "result", "by", "integer", "1", ",", "substitute", "it", "for", "month", ".", "call", "the", "method", "m.group", "[", "m", ".", "group", "]", "with", "an", "argument", "string", "_STR:0_", ",", "convert", "the", "result", "into", "a", "string", ",", "substitute", "it", "for", "day", "."], "cano_code": "day = int ( m . group ( 'day' ) )", "decano_code": "day = int ( m . group ( 'day' ) )", "token": ["day", "=", "int", "(", "m", ".", "group", "(", "\" day \"", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "day = int ( m . group ( 'day' ) )"}
{"src": ["call", "the", "method", "m.group", "[", "m", ".", "group", "]", "with", "an", "argument", "string", "_STR:0_", ",", "convert", "the", "result", "into", "a", "string", ",", "substitute", "it", "for", "hour", "."], "cano_code": "hour = int ( m . group ( '_STR:0_' ) )", "decano_code": "hour = int ( m . group ( '_STR:0_' ) )", "token": ["hour", "=", "int", "(", "m", ".", "group", "(", "\" _STR:0_ \"", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "hour = int ( m . group ( 'hour' ) )"}
{"src": ["call", "the", "method", "m.group", "[", "m", ".", "group", "]", "with", "an", "argument", "string", "_STR:0_", ",", "convert", "the", "result", "into", "a", "string", ",", "substitute", "it", "for", "min", "."], "cano_code": "min = int ( m . group ( '_STR:0_' ) )", "decano_code": "min = int ( m . group ( '_STR:0_' ) )", "token": ["min", "=", "int", "(", "m", ".", "group", "(", "\" _STR:0_ \"", ")", ")"], "type": ["KEYWORD", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "min = int ( m . group ( 'min' ) )"}
{"src": ["call", "the", "method", "m.group", "[", "m", ".", "group", "]", "with", "an", "argument", "string", "_STR:0_", ",", "convert", "the", "result", "into", "a", "string", ",", "substitute", "it", "for", "sec", "."], "cano_code": "sec = int ( m . group ( '_STR:0_' ) )", "decano_code": "sec = int ( m . group ( '_STR:0_' ) )", "token": ["sec", "=", "int", "(", "m", ".", "group", "(", "\" _STR:0_ \"", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "sec = int ( m . group ( 'sec' ) )"}
{"src": ["call", "the", "method", "MONTHS.index", "[", "MONTHS", ".", "index", "]", "with", "6", "arguments", ":", "year", ",", "month", ",", "day", ",", "hour", ",", "min", "and", "sec", ",", "substitute", "the", "result", "for", "result", "."], "cano_code": "result = datetime . datetime ( year , month , day , hour , min , sec )", "decano_code": "result = datetime . datetime ( year , month , day , hour , min , sec )", "token": ["result", "=", "datetime", ".", "datetime", "(", "year", ",", "month", ",", "day", ",", "hour", ",", "min", ",", "sec", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "result = datetime . datetime ( year , month , day , hour , min , sec )"}
{"src": ["call", "the", "method", "result.utctimetuple", "[", "result", ".", "utctimetuple", "]", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "method", "calendar.timegm", "[", "calendar", ".", "timegm", "]", ",", "return", "the", "result", "."], "cano_code": "return calendar . timegm ( result . utctimetuple ( ) )", "decano_code": "return calendar . timegm ( result . utctimetuple ( ) )", "token": ["return", "calendar", ".", "timegm", "(", "result", ".", "utctimetuple", "(", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "return calendar . timegm ( result . utctimetuple ( ) )"}
{"src": ["if", "Exception", "exception", "is", "caught", "."], "cano_code": "try: pass\nexcept Exception :pass", "decano_code": "except Exception :", "token": ["except", "Exception", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except Exception :"}
{"src": ["call", "the", "function", "six.reraise", "[", "six", ".", "reraise", "]", "with", "3", "arguments", ":", "ValueError", ",", "instance", "of", "a", "class", "ValueError", ",", "created", "with", "an", "argument", "string", ","], "cano_code": "six . reraise ( ValueError , ValueError ( \"%r is not a valid date\" % date ) , sys . exc_info ( ) [ 2 ] )", "decano_code": "six . reraise ( ValueError , ValueError ( \"%r is not a valid date\" % date ) , sys . exc_info ( ) [ 2 ] )", "token": ["six", ".", "reraise", "(", "ValueError", ",", "ValueError", "(", "\" %r is not a valid date \"", "%", "date", ")", ",", "sys", ".", "exc_info", "(", ")", "[", "2", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "six . reraise ( ValueError , ValueError ( \"%r is not a valid date\" % date ) , sys . exc_info ( ) [ 2 ] )"}
{"src": ["_STR:0_", "formated", "with", "date", "and", "third", "element", "of", "the", "result", "of", "the", "function", "sys.exc_info", "[", "sys", ".", "exc_info", "]", ".", "define", "the", "function", "parse_http_date_safe", "an", "argument", "date", "."], "cano_code": "def parse_http_date_safe ( date ) :pass", "decano_code": "def parse_http_date_safe ( date ) :", "token": ["def", "parse_http_date_safe", "(", "date", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def parse_http_date_safe ( date ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "function", "parse_http_date", "with", "an", "argument", "date", ",", "return", "the", "result", "."], "cano_code": "return parse_http_date ( date )", "decano_code": "return parse_http_date ( date )", "token": ["return", "parse_http_date", "(", "date", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "return parse_http_date ( date )"}
{"src": ["if", "Exception", "exception", "is", "caught", "."], "cano_code": "try: pass\nexcept Exception :pass", "decano_code": "except Exception :", "token": ["except", "Exception", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except Exception :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["define", "the", "functionbase36_to_int", "with", "an", "argument", "s", "."], "cano_code": "def base36_to_int ( s ) :pass", "decano_code": "def base36_to_int ( s ) :", "token": ["def", "base36_to_int", "(", "s", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def base36_to_int ( s ) :"}
{"src": ["if", "length", "of", "s", "is", "greater", "than", "integer", "13", ","], "cano_code": "if len ( s ) > 13 :pass", "decano_code": "if len ( s ) > 13 :", "token": ["if", "len", "(", "s", ")", ">", "13", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "OP"], "raw_code": "if len ( s ) > 13 :"}
{"src": ["raise", "an", "ValueError", "exception", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise ValueError ( '_STR:0_' )", "decano_code": "raise ValueError ( '_STR:0_' )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise ValueError ( \"Base36 input too large\" )"}
{"src": ["convert", "s", "to", "integer", "of", "base", "36", ",", "substitute", "it", "for", "value", "."], "cano_code": "value = int ( s , 36 )", "decano_code": "value = int ( s , 36 )", "token": ["value", "=", "int", "(", "s", ",", "36", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP"], "raw_code": "value = int ( s , 36 )"}
{"src": ["if", "six.PY2", "[", "six", ".", "PY2", "]", "is", "true", "and", "value", "is", "greater", "than", "sys.maxint", "[", "sys", ".", "maxint", "]", ","], "cano_code": "if six . PY2 and value > sys . maxint :pass", "decano_code": "if six . PY2 and value > sys . maxint :", "token": ["if", "six", ".", "PY2", "and", "value", ">", "sys", ".", "maxint", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "if six . PY2 and value > sys . maxint :"}
{"src": ["raise", "an", "ValueError", "exception", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise ValueError ( '_STR:0_' )", "decano_code": "raise ValueError ( '_STR:0_' )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise ValueError ( \"Base36 input too large\" )"}
{"src": ["return", "value", "."], "cano_code": "return value", "decano_code": "return value", "token": ["return", "value"], "type": ["KEYWORD", "NAME"], "raw_code": "return value"}
{"src": ["define", "the", "function", "int_to_base36", "with", "an", "argument", "i", "."], "cano_code": "def int_to_base36 ( i ) :pass", "decano_code": "def int_to_base36 ( i ) :", "token": ["def", "int_to_base36", "(", "i", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def int_to_base36 ( i ) :"}
{"src": ["digits", "is", "a", "string", "_STR:0_", "."], "cano_code": "digits = '_STR:0_'", "decano_code": "digits = '_STR:0_'", "token": ["digits", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "digits = \"0123456789abcdefghijklmnopqrstuvwxyz\""}
{"src": ["factor", "is", "integer", "0", "."], "cano_code": "factor = 0", "decano_code": "factor = 0", "token": ["factor", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "factor = 0"}
{"src": ["if", "i", "is", "smaller", "than", "integer", "0", ","], "cano_code": "if i < 0 :pass", "decano_code": "if i < 0 :", "token": ["if", "i", "<", "0", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if i < 0 :"}
{"src": ["raise", "an", "ValueError", "exception", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise ValueError ( '_STR:0_' )", "decano_code": "raise ValueError ( '_STR:0_' )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise ValueError ( \"Negative base36 conversion input.\" )"}
{"src": ["if", "six.PY2", "[", "six", ".", "PY2", "]", "is", "true", ","], "cano_code": "if six . PY2 :pass", "decano_code": "if six . PY2 :", "token": ["if", "six", ".", "PY2", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if six . PY2 :"}
{"src": ["if", "i", "is", "not", "an", "instance", "of", "six.integer_types", "[", "six", ".", "integer_types", "]", "class", ","], "cano_code": "if not isinstance ( i , six . integer_types ) :pass", "decano_code": "if not isinstance ( i , six . integer_types ) :", "token": ["if", "not", "isinstance", "(", "i", ",", "six", ".", "integer_types", ")", ":"], "type": ["KEYWORD", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if not isinstance ( i , six . integer_types ) :"}
{"src": ["raise", "an", "TypeError", "exception", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise TypeError ( '_STR:0_' )", "decano_code": "raise TypeError ( '_STR:0_' )", "token": ["raise", "TypeError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise TypeError ( \"Non-integer base36 conversion input.\" )"}
{"src": ["if", "i", "is", "greater", "than", "sys.maxint", "[", "sys", ".", "maxint", "]", ","], "cano_code": "if i > sys . maxint :pass", "decano_code": "if i > sys . maxint :", "token": ["if", "i", ">", "sys", ".", "maxint", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "if i > sys . maxint :"}
{"src": ["raise", "an", "ValueError", "exception", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise ValueError ( '_STR:0_' )", "decano_code": "raise ValueError ( '_STR:0_' )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise ValueError ( \"Base36 conversion input too large.\" )"}
{"src": ["endless", "loop", ","], "cano_code": "while True :pass", "decano_code": "while True :", "token": ["while", "True", ":"], "type": ["KEYWORD", "KEYWORD", "OP"], "raw_code": "while True :"}
{"src": ["increment", "factor", "by", "one", "."], "cano_code": "factor += 1", "decano_code": "factor += 1", "token": ["factor", "+=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "factor += 1"}
{"src": ["bring", "integer", "36", "to", "the", "power", "of", "factor", ",", "if", "i", "is", "smaller", "than", "the", "result", ","], "cano_code": "if i < 36 ** factor :pass", "decano_code": "if i < 36 ** factor :", "token": ["if", "i", "<", "36", "**", "factor", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP", "NAME", "OP"], "raw_code": "if i < 36 ** factor :"}
{"src": ["decrement", "factor", "by", "one", "."], "cano_code": "factor -= 1", "decano_code": "factor -= 1", "token": ["factor", "-=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "factor -= 1"}
{"src": ["break", "from", "the", "loop", "execution", "."], "cano_code": "break", "decano_code": "break", "token": ["break"], "type": ["NAME"], "raw_code": "break"}
{"src": ["base36", "is", "an", "empty", "list", "."], "cano_code": "base36 = [ ]", "decano_code": "base36 = [ ]", "token": ["base36", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "base36 = [ ]"}
{"src": ["while", "factor", "is", "greater", "or", "equal", "to", "integer", "0", ","], "cano_code": "while factor >= 0 :pass", "decano_code": "while factor >= 0 :", "token": ["while", "factor", ">=", "0", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "while factor >= 0 :"}
{"src": ["bring", "integer", "36", "to", "the", "power", "of", "factor", ",", "substitute", "the", "result", "for", "j", "."], "cano_code": "j = 36 ** factor", "decano_code": "j = 36 ** factor", "token": ["j", "=", "36", "**", "factor"], "type": ["NAME", "OP", "NUMBER", "OP", "NAME"], "raw_code": "j = 36 ** factor"}
{"src": ["floor", "the", "division", "of", "i", "by", "j", ",", "use", "it", "an", "an", "index", "to", "get", "the", "element", "of", "the", "digits", "list", ",", "append", "the", "result", "for", "base36", "."], "cano_code": "base36 . append ( digits [ i // j ] )", "decano_code": "base36 . append ( digits [ i // j ] )", "token": ["base36", ".", "append", "(", "digits", "[", "i", "//", "j", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "base36 . append ( digits [ i // j ] )"}
{"src": ["i", "is", "the", "reminder", "of", "the", "division", "of", "i", "by", "j", "."], "cano_code": "i = i % j", "decano_code": "i = i % j", "token": ["i", "=", "i", "%", "j"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "i = i % j"}
{"src": ["decrement", "factor", "by", "one", "."], "cano_code": "factor -= 1", "decano_code": "factor -= 1", "token": ["factor", "-=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "factor -= 1"}
{"src": ["join", "elements", "of", "base36", "into", "a", "string", ",", "return", "it", "."], "cano_code": "return '' . join ( base36 )", "decano_code": "return '' . join ( base36 )", "token": ["return", "\"  \"", ".", "join", "(", "base36", ")"], "type": ["KEYWORD", "STRING", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return '' . join ( base36 )"}
{"src": ["define", "the", "function", "urlsafe_base64_encode", "with", "an", "argument", "s", "."], "cano_code": "def urlsafe_base64_encode ( s ) :pass", "decano_code": "def urlsafe_base64_encode ( s ) :", "token": ["def", "urlsafe_base64_encode", "(", "s", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def urlsafe_base64_encode ( s ) :"}
{"src": ["call", "the", "method", "base64.urlsafe_b64encode", "[", "base64", ".", "urlsafe_b64encode", "]", "with", "an", "argument", "s", ",", "strip", "the", "result", "of", "the", "bytes", "string", "_STR:0_", "from", "the", "right", ",", "return", "it", "."], "cano_code": "return base64 . urlsafe_b64encode ( s ) . rstrip ( b'_STR:0_' )", "decano_code": "return base64 . urlsafe_b64encode ( s ) . rstrip ( b'_STR:0_' )", "token": ["return", "base64", ".", "urlsafe_b64encode", "(", "s", ")", ".", "rstrip", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "return base64 . urlsafe_b64encode ( s ) . rstrip ( b'\\n=' )"}
{"src": ["define", "the", "function", "urlsafe_base64_decode", "with", "an", "argument", "s", "."], "cano_code": "def urlsafe_base64_decode ( s ) :pass", "decano_code": "def urlsafe_base64_decode ( s ) :", "token": ["def", "urlsafe_base64_decode", "(", "s", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def urlsafe_base64_decode ( s ) :"}
{"src": ["call", "the", "method", "s.encode", "[", "s", ".", "encode", "]", "with", "an", "argument", "string", "_STR:0_", ",", "substitute", "the", "result", "for", "s", "."], "cano_code": "s = s . encode ( '_STR:0_' )", "decano_code": "s = s . encode ( '_STR:0_' )", "token": ["s", "=", "s", ".", "encode", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "s = s . encode ( 'utf-8' )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["left", "justify", "string", "s", "in", "a", "field", "of", "width", "equal", "to", "the", "sum", "of", "length", "of", "s", "and", "reminder", "of", "the", "division", "of", "length", "of", "s", "by", "integer", "4", ","], "cano_code": "return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )", "decano_code": "return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )", "token": ["return", "base64", ".", "urlsafe_b64decode", "(", "s", ".", "ljust", "(", "len", "(", "s", ")", "+", "len", "(", "s", ")", "%", "4", ",", "\" = \"", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "STRING", "OP", "OP"], "raw_code": "return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )"}
{"src": ["pad", "the", "rest", "of", "the", "field", "with", "bytes", "string", "_STR:0_", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "method", "base64.urlsafe_b64decode", "[", "base64", ".", "urlsafe_b64decode", "]", ",", "return", "the", "result", ".", "if", "LookupError", "or", "BinasciiError", ",", "renamed", "to", "e", ",", "exceptions", "are", "caught", "."], "cano_code": "try: pass\nexcept ( LookupError , BinasciiError ) as e :pass", "decano_code": "except ( LookupError , BinasciiError ) as e :", "token": ["except", "(", "LookupError", ",", "BinasciiError", ")", "as", "e", ":"], "type": ["KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "NAME", "OP"], "raw_code": "except ( LookupError , BinasciiError ) as e :"}
{"src": ["raise", "an", "ValueError", "exception", "with", "an", "argument", "e", "."], "cano_code": "raise ValueError ( e )", "decano_code": "raise ValueError ( e )", "token": ["raise", "ValueError", "(", "e", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "raise ValueError ( e )"}
{"src": ["define", "the", "function", "parse_etags", "with", "an", "argument", "etag_str", "."], "cano_code": "def parse_etags ( etag_str ) :pass", "decano_code": "def parse_etags ( etag_str ) :", "token": ["def", "parse_etags", "(", "etag_str", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def parse_etags ( etag_str ) :"}
{"src": ["call", "the", "method", "ETAG_MATCH.findall", "[", "ETAG_MATCH", ".", "findall", "]", "with", "an", "argument", "etag_str", ",", "substitute", "the", "result", "for", "etags", "."], "cano_code": "etags = ETAG_MATCH . findall ( etag_str )", "decano_code": "etags = ETAG_MATCH . findall ( etag_str )", "token": ["etags", "=", "ETAG_MATCH", ".", "findall", "(", "etag_str", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "etags = ETAG_MATCH . findall ( etag_str )"}
{"src": ["if", "etags", "is", "false", ","], "cano_code": "if not etags :pass", "decano_code": "if not etags :", "token": ["if", "not", "etags", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not etags :"}
{"src": ["return", "a", "list", "with", "an", "element", "etag_str", "."], "cano_code": "return [ etag_str ]", "decano_code": "return [ etag_str ]", "token": ["return", "[", "etag_str", "]"], "type": ["KEYWORD", "OP", "NAME", "OP"], "raw_code": "return [ etag_str ]"}
{"src": ["for", "every", "e", "in", "etags", "call", "the", "method", "e.encode", "[", "e", ".", "encode", "]", "with", "an", "argument", "string", "_STR:0_", ",", "call", "the", "method", "decode", "on", "the", "result", "with", "an", "argument", ","], "cano_code": "etags = [ e . encode ( '_STR:0_' ) . decode ( 'unicode_escape' ) for e in etags ]", "decano_code": "etags = [ e . encode ( '_STR:0_' ) . decode ( 'unicode_escape' ) for e in etags ]", "token": ["etags", "=", "[", "e", ".", "encode", "(", "\" _STR:0_ \"", ")", ".", "decode", "(", "\" unicode_escape \"", ")", "for", "e", "in", "etags", "]"], "type": ["NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "etags = [ e . encode ( 'ascii' ) . decode ( 'unicode_escape' ) for e in etags ]"}
{"src": ["string", "_STR:0_", ",", "substitute", "the", "list", "of", "results", "for", "etags", ".", "return", "etags", "."], "cano_code": "return etags", "decano_code": "return etags", "token": ["return", "etags"], "type": ["KEYWORD", "NAME"], "raw_code": "return etags"}
{"src": ["define", "the", "function", "quote_etag", "with", "an", "argument", "etag", "."], "cano_code": "def quote_etag ( etag ) :pass", "decano_code": "def quote_etag ( etag ) :", "token": ["def", "quote_etag", "(", "etag", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def quote_etag ( etag ) :"}
{"src": ["return", "a", "string", "_STR:0_", "formated", "with", "etag", ",", "in", "which", "every", "occurrence", "of", "_STR:1_\\\\\\\\_STR:2_", "''", "'", ","], "cano_code": "return '_STR:0_' % etag . replace ( '\\\\' , '\\\\\\\\' ) . replace ( '\"' , '\\\\\"' )", "decano_code": "return '_STR:0_' % etag . replace ( '\\\\' , '\\\\\\\\' ) . replace ( '\"' , '\\\\\"' )", "token": ["return", "\" _STR:0_ \"", "%", "etag", ".", "replace", "(", "\" \\\\ \"", ",", "\" \\\\\\\\ \"", ")", ".", "replace", "(", "\" \" \"", ",", "\" \\\\\" \"", ")"], "type": ["KEYWORD", "STRING", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP"], "raw_code": "return '\"%s\"' % etag . replace ( '\\\\' , '\\\\\\\\' ) . replace ( '\"' , '\\\\\"' )"}
{"src": ["is", "replaced", "with", "_STR:0_", ".", "define", "the", "function", "same_origin", "with", "2", "arguments", "url1", "and", "url2", "."], "cano_code": "def same_origin ( url1 , url2 ) :pass", "decano_code": "def same_origin ( url1 , url2 ) :", "token": ["def", "same_origin", "(", "url1", ",", "url2", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def same_origin ( url1 , url2 ) :"}
{"src": ["substitute", "result", "of", "the", "function", "urlparse", "with", "an", "argument", "ur1", "for", "p1", "and", "result", "of", "the", "function", "urlparse", "with", "an", "argument", "ur2", "for", "p2", "."], "cano_code": "p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )", "decano_code": "p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )", "token": ["p1", ",", "p2", "=", "urlparse", "(", "url1", ")", ",", "urlparse", "(", "url2", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["if", "p2.scheme", "[", "p2", ".", "scheme", "]", ",", "p2.hostname", "[", "p2", ".", "hostname", "]", "and", "p2.port", "[", "p2", ".", "port", "]", "equals", "p1.scheme", "[", "p1", ".", "scheme", "]", ",", "p1.hostname", "[", "p1", ".", "hostname", "]", "and", "p1.port", "[", "p1", ".", "port", "]", ",", "respectively", ",", "return", "boolean", "True", ",", "otherwise", "return", "boolean", "False", "."], "cano_code": "return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )", "decano_code": "return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )", "token": ["return", "(", "p1", ".", "scheme", ",", "p1", ".", "hostname", ",", "p1", ".", "port", ")", "==", "(", "p2", ".", "scheme", ",", "p2", ".", "hostname", ",", "p2", ".", "port", ")"], "type": ["KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )"}
{"src": ["if", "ValueError", "exception", "is", "caught", "."], "cano_code": "try: pass\nexcept ValueError :pass", "decano_code": "except ValueError :", "token": ["except", "ValueError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ValueError :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["define", "the", "function", "is_safe_url", "with", "2", "arguments", "url", "and", "host", "set", "to", "None", "."], "cano_code": "def is_safe_url ( url , host = None ) :pass", "decano_code": "def is_safe_url ( url , host = None ) :", "token": ["def", "is_safe_url", "(", "url", ",", "host", "=", "None", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def is_safe_url ( url , host = None ) :"}
{"src": ["if", "url", "is", "false", ","], "cano_code": "if not url :pass", "decano_code": "if not url :", "token": ["if", "not", "url", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not url :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["replace", "every", "occurrence", "of", "_STR:0_/", "'", "."], "cano_code": "url = url . replace ( '\\\\' , '/' )", "decano_code": "url = url . replace ( '\\\\' , '/' )", "token": ["url", "=", "url", ".", "replace", "(", "\" \\\\ \"", ",", "\" / \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP"], "raw_code": "url = url . replace ( '\\\\' , '/' )"}
{"src": ["if", "url", "starts", "with", "_STR:0_", ","], "cano_code": "if url . startswith ( '_STR:0_' ) :pass", "decano_code": "if url . startswith ( '_STR:0_' ) :", "token": ["if", "url", ".", "startswith", "(", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "if url . startswith ( '///' ) :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["call", "the", "function", "urlparse", "with", "an", "argument", "url", ",", "substitute", "the", "result", "for", "url_info", "."], "cano_code": "url_info = urlparse ( url )", "decano_code": "url_info = urlparse ( url )", "token": ["url_info", "=", "urlparse", "(", "url", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "url_info = urlparse ( url )"}
{"src": ["if", "url_info.netloc", "[", "url_info", ".", "netloc", "]", "is", "false", "and", "url_info.scheme", "[", "url_info", ".", "scheme", "]", "is", "true", ","], "cano_code": "if not url_info . netloc and url_info . scheme :pass", "decano_code": "if not url_info . netloc and url_info . scheme :", "token": ["if", "not", "url_info", ".", "netloc", "and", "url_info", ".", "scheme", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if not url_info . netloc and url_info . scheme :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "url_info.netloc", "[", "url_info", ".", "netloc", "]", "is", "false", "or", "url_info.netloc", "[", "url_info", ".", "netloc", "]", "equals", "host", ",", "and", "if", "url_info.scheme", "[", "url_info", ".", "scheme", "]", "is", "false", "or", "url_info.scheme", "[", "url_info", ".", "scheme", "]", "equals", ","], "cano_code": "return ( ( not url_info . netloc or url_info . netloc == host ) and  ( not url_info . scheme or url_info . scheme in [ 'http' , 'https' ] ) )", "decano_code": "return ( ( not url_info . netloc or url_info . netloc == host ) and  ( not url_info . scheme or url_info . scheme in [ 'http' , 'https' ] ) )", "token": ["return", "(", "(", "not", "url_info", ".", "netloc", "or", "url_info", ".", "netloc", "==", "host", ")", "and", "(", "not", "url_info", ".", "scheme", "or", "url_info", ".", "scheme", "in", "[", "\" http \"", ",", "\" https \"", "]", ")", ")"], "type": ["KEYWORD", "OP", "OP", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "OP", "STRING", "OP", "STRING", "OP", "OP", "OP"], "raw_code": "return ( ( not url_info . netloc or url_info . netloc == host ) and  ( not url_info . scheme or url_info . scheme in [ 'http' , 'https' ] ) )"}
{"src": ["import", "module", "warnings", "."], "cano_code": "import warnings", "decano_code": "import warnings", "token": ["import", "warnings"], "type": ["KEYWORD", "NAME"], "raw_code": "import warnings"}
{"src": ["import", "module", "sys", "."], "cano_code": "import sys", "decano_code": "import sys", "token": ["import", "sys"], "type": ["KEYWORD", "NAME"], "raw_code": "import sys"}
{"src": ["from", "django.utils", "[", "django", ".", "utils", "]", "import", "six", "into", "default", "name", "space", "."], "cano_code": "from django . utils import six", "decano_code": "from django . utils import six", "token": ["from", "django", ".", "utils", "import", "six"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils import six"}
{"src": ["from", "django.utils.deprecation", "[", "django", ".", "utils", ".", "deprecation", "]", "import", "RemovedInDjango19Warning", "into", "default", "name", "space", "."], "cano_code": "from django . utils . deprecation import RemovedInDjango19Warning", "decano_code": "from django . utils . deprecation import RemovedInDjango19Warning", "token": ["from", "django", ".", "utils", ".", "deprecation", "import", "RemovedInDjango19Warning"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . deprecation import RemovedInDjango19Warning"}
{"src": ["call", "the", "function", "warnings.warn", "[", "warnings", ".", "warn", "]", "with", "3", "arguments", ":", "string", "_STR:0_", ","], "cano_code": "warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning , stacklevel = 2 )", "decano_code": "warnings . warn ( '_STR:0_' ,  RemovedInDjango19Warning , stacklevel = 2 )", "token": ["warnings", ".", "warn", "(", "\" _STR:0_ \"", ",", "RemovedInDjango19Warning", ",", "stacklevel", "=", "2", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP"], "raw_code": "warnings . warn ( \"django.utils.importlib will be removed in Django 1.9.\" ,  RemovedInDjango19Warning , stacklevel = 2 )"}
{"src": ["RemovedInDjango19Warning", "and", "stacklevel", "set", "to", "integer", "2.", "define", "the", "function", "_resolve_name", "with", "3", "arguments", ":", "name", ",", "package", "and", "level", "."], "cano_code": "def _resolve_name ( name , package , level ) :pass", "decano_code": "def _resolve_name ( name , package , level ) :", "token": ["def", "_resolve_name", "(", "name", ",", "package", ",", "level", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def _resolve_name ( name , package , level ) :"}
{"src": ["if", "package", "doesnt", "have", "an", "_STR:0_", "attribute", ","], "cano_code": "if not hasattr ( package , '_STR:0_' ) :pass", "decano_code": "if not hasattr ( package , '_STR:0_' ) :", "token": ["if", "not", "hasattr", "(", "package", ",", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "if not hasattr ( package , 'rindex' ) :"}
{"src": ["raise", "an", "ValueError", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise ValueError ( '_STR:0_' )", "decano_code": "raise ValueError ( '_STR:0_' )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise ValueError ( \"'package' not set to a string\" )"}
{"src": ["substitute", "length", "of", "package", "for", "dot", "."], "cano_code": "dot = len ( package )", "decano_code": "dot = len ( package )", "token": ["dot", "=", "len", "(", "package", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "dot = len ( package )"}
{"src": ["for", "every", "x", "is", "the", "range", "of", "integers", "from", "level", "to", "the", "integer", "2", ",", "in", "the", "reversed", "order", ","], "cano_code": "for x in range ( level , 1 , - 1 ) :pass", "decano_code": "for x in range ( level , 1 , - 1 ) :", "token": ["for", "x", "in", "range", "(", "level", ",", "1", ",", "-", "1", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "for x in range ( level , 1 , - 1 ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "method", "package.rindex", "[", "package", ".", "rindex", "]", "with", "3", "arguments", ":", "string", "_STR:0_", ",", "integer", "0", "and", "dot", ",", "substitute", "the", "result", "for", "dot", "."], "cano_code": "dot = package . rindex ( '_STR:0_' , 0 , dot )", "decano_code": "dot = package . rindex ( '_STR:0_' , 0 , dot )", "token": ["dot", "=", "package", ".", "rindex", "(", "\" _STR:0_ \"", ",", "0", ",", "dot", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NUMBER", "OP", "NAME", "OP"], "raw_code": "dot = package . rindex ( '.' , 0 , dot )"}
{"src": ["if", "ValueError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ValueError :pass", "decano_code": "except ValueError :", "token": ["except", "ValueError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ValueError :"}
{"src": ["raise", "an", "ValueError", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise ValueError ( '_STR:0_' )", "decano_code": "raise ValueError ( '_STR:0_' )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise ValueError ( \"attempted relative import beyond top-level package\" )"}
{"src": ["return", "a", "string", "_STR:0_", "formated", "with", "first", "dot", "package", "elements", "and", "name", "."], "cano_code": "return '_STR:0_' % ( package [ : dot ] , name )", "decano_code": "return '_STR:0_' % ( package [ : dot ] , name )", "token": ["return", "\" _STR:0_ \"", "%", "(", "package", "[", ":", "dot", "]", ",", "name", ")"], "type": ["KEYWORD", "STRING", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "return \"%s.%s\" % ( package [ : dot ] , name )"}
{"src": ["if", "six.PY3", "[", "six", ".", "PY3", "]", "is", "true", ","], "cano_code": "if six . PY3 :pass", "decano_code": "if six . PY3 :", "token": ["if", "six", ".", "PY3", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if six . PY3 :"}
{"src": ["from", "importlib", "import", "import_module", "."], "cano_code": "from importlib import import_module", "decano_code": "from importlib import import_module", "token": ["from", "importlib", "import", "import_module"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from importlib import import_module"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["define", "the", "function", "import_module", "with", "3", "arguments", ":", "name", "and", "package", "set", "to", "None", "."], "cano_code": "def import_module ( name , package = None ) :pass", "decano_code": "def import_module ( name , package = None ) :", "token": ["def", "import_module", "(", "name", ",", "package", "=", "None", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def import_module ( name , package = None ) :"}
{"src": ["if", "name", "starts", "with", "an", "string", "_STR:0_", ","], "cano_code": "if name . startswith ( '_STR:0_' ) :pass", "decano_code": "if name . startswith ( '_STR:0_' ) :", "token": ["if", "name", ".", "startswith", "(", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "if name . startswith ( '.' ) :"}
{"src": ["if", "package", "is", "false", ","], "cano_code": "if not package :pass", "decano_code": "if not package :", "token": ["if", "not", "package", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not package :"}
{"src": ["raise", "an", "TypeError", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise TypeError ( '_STR:0_' )", "decano_code": "raise TypeError ( '_STR:0_' )", "token": ["raise", "TypeError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise TypeError ( \"relative imports require the 'package' argument\" )"}
{"src": ["level", "is", "an", "integer", "0", "."], "cano_code": "level = 0", "decano_code": "level = 0", "token": ["level", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "level = 0"}
{"src": ["for", "every", "character", "in", "name", ","], "cano_code": "for character in name :pass", "decano_code": "for character in name :", "token": ["for", "character", "in", "name", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for character in name :"}
{"src": ["if", "character", "is", "not", "equal", "to", "a", "string", "_STR:0_", ","], "cano_code": "if character != '_STR:0_' :pass", "decano_code": "if character != '_STR:0_' :", "token": ["if", "character", "!=", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if character != '.' :"}
{"src": ["break", "from", "the", "loop", "execution", "."], "cano_code": "break", "decano_code": "break", "token": ["break"], "type": ["NAME"], "raw_code": "break"}
{"src": ["increment", "level", "by", "one", "."], "cano_code": "level += 1", "decano_code": "level += 1", "token": ["level", "+=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "level += 1"}
{"src": ["call", "the", "function", "_resolve_name", "with", "3", "arguments", ":", "name", "list", "elements", "from", "the", "level", "index", "to", "the", "end", ",", "package", "and", "level", ","], "cano_code": "name = _resolve_name ( name [ level : ] , package , level )", "decano_code": "name = _resolve_name ( name [ level : ] , package , level )", "token": ["name", "=", "_resolve_name", "(", "name", "[", "level", ":", "]", ",", "package", ",", "level", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "name = _resolve_name ( name [ level : ] , package , level )"}
{"src": ["substitute", "the", "result", "for", "name", ".", "call", "the", "function", "__import__", "with", "an", "argument", "name", "."], "cano_code": "__import__ ( name )", "decano_code": "__import__ ( name )", "token": ["__import__", "(", "name", ")"], "type": ["KEYWORD", "OP", "NAME", "OP"], "raw_code": "__import__ ( name )"}
{"src": ["return", "sys.modules", "[", "sys", ".", "modules", "]", "dictionary", "value", "under", "the", "name", "key", "."], "cano_code": "return sys . modules [ name ]", "decano_code": "return sys . modules [ name ]", "token": ["return", "sys", ".", "modules", "[", "name", "]"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return sys . modules [ name ]"}
{"src": ["from", "django.core.exceptions", "[", "django", ".", "core", ".", "exceptions", "]", "import", "ValidationError", "into", "default", "name", "space", "."], "cano_code": "from django . core . exceptions import ValidationError", "decano_code": "from django . core . exceptions import ValidationError", "token": ["from", "django", ".", "core", ".", "exceptions", "import", "ValidationError"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . core . exceptions import ValidationError"}
{"src": ["from", "django.utils.translation", "[", "django", ".", "utils", ".", "translation", "]", "import", "ugettext_lazy", "as", "_", "into", "default", "name", "space", "."], "cano_code": "from django . utils . translation import ugettext_lazy as _", "decano_code": "from django . utils . translation import ugettext_lazy as _", "token": ["from", "django", ".", "utils", ".", "translation", "import", "ugettext_lazy", "as", "_"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . translation import ugettext_lazy as _"}
{"src": ["from", "django.utils.six.moves", "[", "django", ".", "utils", ".", "six", ".", "moves", "]", "import", "xrange", "into", "default", "name", "space", "."], "cano_code": "from django . utils . six . moves import xrange", "decano_code": "from django . utils . six . moves import xrange", "token": ["from", "django", ".", "utils", ".", "six", ".", "moves", "import", "xrange"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "KEYWORD"], "raw_code": "from django . utils . six . moves import xrange"}
{"src": ["define", "the", "function", "clean_ipv6_address", "with", "3", "arguments", ":", "ip_str", ",", "unpack_ipv4", "set", "to", "boolean", "False", "and", "error_message", ","], "cano_code": "def clean_ipv6_address ( ip_str , unpack_ipv4 = False ,  error_message = _ ( \"This is not a valid IPv6 address.\" ) ) :pass", "decano_code": "def clean_ipv6_address ( ip_str , unpack_ipv4 = False ,  error_message = _ ( \"This is not a valid IPv6 address.\" ) ) :", "token": ["def", "clean_ipv6_address", "(", "ip_str", ",", "unpack_ipv4", "=", "False", ",", "error_message", "=", "_", "(", "\" This is not a valid IPv6 address. \"", ")", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "OP"], "raw_code": "def clean_ipv6_address ( ip_str , unpack_ipv4 = False ,  error_message = _ ( \"This is not a valid IPv6 address.\" ) ) :"}
{"src": ["best_doublecolon_start", "is", "an", "integer", "-1", "."], "cano_code": "best_doublecolon_start = - 1", "decano_code": "best_doublecolon_start = - 1", "token": ["best_doublecolon_start", "=", "-", "1"], "type": ["NAME", "OP", "OP", "NUMBER"], "raw_code": "best_doublecolon_start = - 1"}
{"src": ["best_doublecolon_len", "is", "an", "integer", "0", "."], "cano_code": "best_doublecolon_len = 0", "decano_code": "best_doublecolon_len = 0", "token": ["best_doublecolon_len", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "best_doublecolon_len = 0"}
{"src": ["doublecolon_start", "is", "an", "integer", "-1", "."], "cano_code": "doublecolon_start = - 1", "decano_code": "doublecolon_start = - 1", "token": ["doublecolon_start", "=", "-", "1"], "type": ["NAME", "OP", "OP", "NUMBER"], "raw_code": "doublecolon_start = - 1"}
{"src": ["doublecolon_len", "is", "an", "integer", "0", "."], "cano_code": "doublecolon_len = 0", "decano_code": "doublecolon_len = 0", "token": ["doublecolon_len", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "doublecolon_len = 0"}
{"src": ["call", "he", "function", "is_valid_ipv6_address", "with", "an", "argument", "ip_str", ",", "if", "it", "evaluates", "to", "false", ","], "cano_code": "if not is_valid_ipv6_address ( ip_str ) :pass", "decano_code": "if not is_valid_ipv6_address ( ip_str ) :", "token": ["if", "not", "is_valid_ipv6_address", "(", "ip_str", ")", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if not is_valid_ipv6_address ( ip_str ) :"}
{"src": ["raise", "an", "ValidationError", "exception", "with", "2", "arguments", ":", "error_message", "and", "code", "as", "a", "string", "_STR:0_", "."], "cano_code": "raise ValidationError ( error_message , code = '_STR:0_' )", "decano_code": "raise ValidationError ( error_message , code = '_STR:0_' )", "token": ["raise", "ValidationError", "(", "error_message", ",", "code", "=", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "raise ValidationError ( error_message , code = 'invalid' )"}
{"src": ["call", "the", "function", "_explode_shorthand_ip_string", "with", "an", "argument", "ip_str", ",", "substitute", "the", "result", "for", "ip_str", "."], "cano_code": "ip_str = _explode_shorthand_ip_string ( ip_str )", "decano_code": "ip_str = _explode_shorthand_ip_string ( ip_str )", "token": ["ip_str", "=", "_explode_shorthand_ip_string", "(", "ip_str", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "ip_str = _explode_shorthand_ip_string ( ip_str )"}
{"src": ["call", "the", "function", "_explode_shorthand_ip_string", "with", "an", "argument", "ip_str", ",", "substitute", "the", "result", "for", "ip_str", "."], "cano_code": "ip_str = _sanitize_ipv4_mapping ( ip_str )", "decano_code": "ip_str = _sanitize_ipv4_mapping ( ip_str )", "token": ["ip_str", "=", "_explode_shorthand_ip_string", "(", "ip_str", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "ip_str = _sanitize_ipv4_mapping ( ip_str )"}
{"src": ["if", "unpack_ipv4", "is", "true", ","], "cano_code": "if unpack_ipv4 :pass", "decano_code": "if unpack_ipv4 :", "token": ["if", "unpack_ipv4", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if unpack_ipv4 :"}
{"src": ["call", "the", "function", "_unpack_ipv4", "with", "an", "argument", "ip_str", ",", "substitute", "the", "result", "for", "ipv4_unpacked", "."], "cano_code": "ipv4_unpacked = _unpack_ipv4 ( ip_str )", "decano_code": "ipv4_unpacked = _unpack_ipv4 ( ip_str )", "token": ["ipv4_unpacked", "=", "_unpack_ipv4", "(", "ip_str", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "ipv4_unpacked = _unpack_ipv4 ( ip_str )"}
{"src": ["if", "ipv4_unpacked", "is", "true", ","], "cano_code": "if ipv4_unpacked :pass", "decano_code": "if ipv4_unpacked :", "token": ["if", "ipv4_unpacked", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if ipv4_unpacked :"}
{"src": ["return", "ipv4_unpacked", "."], "cano_code": "return ipv4_unpacked", "decano_code": "return ipv4_unpacked", "token": ["return", "ipv4_unpacked"], "type": ["KEYWORD", "NAME"], "raw_code": "return ipv4_unpacked"}
{"src": ["split", "ip_str", "by", "_STR:0_", ",", "substitute", "the", "result", "for", "hextets", "."], "cano_code": "hextets = ip_str . split ( \":\" )", "decano_code": "hextets = ip_str . split ( \":\" )", "token": ["hextets", "=", "ip_str", ".", "split", "(", "\" : \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "hextets = ip_str . split ( \":\" )"}
{"src": ["for", "every", "index", "in", "range", "of", "integers", "from", "0", "to", "length", "of", "hextets", ",", "not", "included", ","], "cano_code": "for index in range ( len ( hextets ) ) :pass", "decano_code": "for index in range ( len ( hextets ) ) :", "token": ["for", "index", "in", "range", "(", "len", "(", "hextets", ")", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "for index in range ( len ( hextets ) ) :"}
{"src": ["get", "the", "value", "under", "the", "index", "key", "of", "the", "hextets", "dictionary", ",", "remove", "the", "leading", "_STR:0_", "characters", ","], "cano_code": "hextets [ index ] = hextets [ index ] . lstrip ( '_STR:0_' )", "decano_code": "hextets [ index ] = hextets [ index ] . lstrip ( '_STR:0_' )", "token": ["hextets", "[", "index", "]", "=", "hextets", "[", "index", "]", ".", "lstrip", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "hextets [ index ] = hextets [ index ] . lstrip ( '0' )"}
{"src": ["substitute", "the", "result", "for", "value", "under", "the", "index", "key", "of", "the", "hextets", "dictionary", ".", "get", "the", "value", "under", "the", "index", "key", "of", "the", "hextets", "dictionary", ",", "if", "it", "is", "false", ","], "cano_code": "if not hextets [ index ] :pass", "decano_code": "if not hextets [ index ] :", "token": ["if", "not", "hextets", "[", "index", "]", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if not hextets [ index ] :"}
{"src": ["value", "under", "the", "index", "key", "of", "the", "hextets", "dictionary", "is", "a", "string", "_STR:0_", "."], "cano_code": "hextets [ index ] = '_STR:0_'", "decano_code": "hextets [ index ] = '_STR:0_'", "token": ["hextets", "[", "index", "]", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "NAME", "OP", "OP", "STRING"], "raw_code": "hextets [ index ] = '0'"}
{"src": ["if", "value", "under", "the", "index", "key", "of", "the", "hextets", "dictionary", "equals", "to", "string", "_STR:0_", ","], "cano_code": "if hextets [ index ] == '_STR:0_' :pass", "decano_code": "if hextets [ index ] == '_STR:0_' :", "token": ["if", "hextets", "[", "index", "]", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "STRING", "OP"], "raw_code": "if hextets [ index ] == '0' :"}
{"src": ["increment", "doublecolon_len", "by", "integer", "1", ","], "cano_code": "doublecolon_len += 1", "decano_code": "doublecolon_len += 1", "token": ["doublecolon_len", "+=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "doublecolon_len += 1"}
{"src": ["if", "doublecolon_start", "equals", "integer", "-1", ","], "cano_code": "if doublecolon_start == - 1 :pass", "decano_code": "if doublecolon_start == - 1 :", "token": ["if", "doublecolon_start", "==", "-", "1", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "NUMBER", "OP"], "raw_code": "if doublecolon_start == - 1 :"}
{"src": ["substitute", "index", "for", "doublecolon_start", "."], "cano_code": "doublecolon_start = index", "decano_code": "doublecolon_start = index", "token": ["doublecolon_start", "=", "index"], "type": ["NAME", "OP", "NAME"], "raw_code": "doublecolon_start = index"}
{"src": ["if", "doublecolon_len", "is", "greater", "than", "best_doublecolon_len", ","], "cano_code": "if doublecolon_len > best_doublecolon_len :pass", "decano_code": "if doublecolon_len > best_doublecolon_len :", "token": ["if", "doublecolon_len", ">", "best_doublecolon_len", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if doublecolon_len > best_doublecolon_len :"}
{"src": ["substitute", "doublecolon_len", "for", "best_doublecolon_len", "."], "cano_code": "best_doublecolon_len = doublecolon_len", "decano_code": "best_doublecolon_len = doublecolon_len", "token": ["best_doublecolon_len", "=", "doublecolon_len"], "type": ["NAME", "OP", "NAME"], "raw_code": "best_doublecolon_len = doublecolon_len"}
{"src": ["substitute", "doublecolon_start", "for", "best_doublecolon_start", "."], "cano_code": "best_doublecolon_start = doublecolon_start", "decano_code": "best_doublecolon_start = doublecolon_start", "token": ["best_doublecolon_start", "=", "doublecolon_start"], "type": ["NAME", "OP", "NAME"], "raw_code": "best_doublecolon_start = doublecolon_start"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["doublecolon_len", "is", "integer", "0", "."], "cano_code": "doublecolon_len = 0", "decano_code": "doublecolon_len = 0", "token": ["doublecolon_len", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "doublecolon_len = 0"}
{"src": ["doublecolon_start", "is", "integer", "-1", "."], "cano_code": "doublecolon_start = - 1", "decano_code": "doublecolon_start = - 1", "token": ["doublecolon_start", "=", "-", "1"], "type": ["NAME", "OP", "OP", "NUMBER"], "raw_code": "doublecolon_start = - 1"}
{"src": ["if", "best_doublecolon_len", "is", "greater", "than", "integer", "1", ","], "cano_code": "if best_doublecolon_len > 1 :pass", "decano_code": "if best_doublecolon_len > 1 :", "token": ["if", "best_doublecolon_len", ">", "1", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if best_doublecolon_len > 1 :"}
{"src": ["sum", "best_doublecolon_start", "and", "best_doublecolon_len", ",", "substitute", "the", "result", "for", "best_doublecolon_end", ","], "cano_code": "best_doublecolon_end = ( best_doublecolon_start +  best_doublecolon_len )", "decano_code": "best_doublecolon_end = ( best_doublecolon_start +  best_doublecolon_len )", "token": ["best_doublecolon_end", "=", "(", "best_doublecolon_start", "+", "best_doublecolon_len", ")"], "type": ["NAME", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "best_doublecolon_end = ( best_doublecolon_start +  best_doublecolon_len )"}
{"src": ["if", "best_doublecolon_end", "equals", "length", "of", "hextets", ","], "cano_code": "if best_doublecolon_end == len ( hextets ) :pass", "decano_code": "if best_doublecolon_end == len ( hextets ) :", "token": ["if", "best_doublecolon_end", "==", "len", "(", "hextets", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP"], "raw_code": "if best_doublecolon_end == len ( hextets ) :"}
{"src": ["append", "an", "empty", "string", "to", "list", "hextets", "."], "cano_code": "hextets += [ '' ]", "decano_code": "hextets += [ '' ]", "token": ["hextets", "+=", "[", "\"  \"", "]"], "type": ["NAME", "OP", "OP", "STRING", "OP"], "raw_code": "hextets += [ '' ]"}
{"src": ["replace", "hextets", "list", "from", "the", "best_doublecolon_start", "index", "to", "best_doublecolon_end", "index", "with", "an", "empty", "string", "."], "cano_code": "hextets [ best_doublecolon_start : best_doublecolon_end ] = [ '' ]", "decano_code": "hextets [ best_doublecolon_start : best_doublecolon_end ] = [ '' ]", "token": ["hextets", "[", "best_doublecolon_start", ":", "best_doublecolon_end", "]", "=", "[", "\"  \"", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "STRING", "OP"], "raw_code": "hextets [ best_doublecolon_start : best_doublecolon_end ] = [ '' ]"}
{"src": ["if", "best_doublecolon_start", "equals", "integer", "0", ","], "cano_code": "if best_doublecolon_start == 0 :pass", "decano_code": "if best_doublecolon_start == 0 :", "token": ["if", "best_doublecolon_start", "==", "0", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if best_doublecolon_start == 0 :"}
{"src": ["prepend", "an", "empty", "string", "to", "hextets", "list", "."], "cano_code": "hextets = [ '' ] + hextets", "decano_code": "hextets = [ '' ] + hextets", "token": ["hextets", "=", "[", "\"  \"", "]", "+", "hextets"], "type": ["NAME", "OP", "OP", "STRING", "OP", "OP", "NAME"], "raw_code": "hextets = [ '' ] + hextets"}
{"src": ["join", "elements", "of", "hextets", "into", "a", "string", ",", "separated", "with", "_STR:0_", ",", "substitute", "it", "for", "result", "."], "cano_code": "result = \":\" . join ( hextets )", "decano_code": "result = \":\" . join ( hextets )", "token": ["result", "=", "\" : \"", ".", "join", "(", "hextets", ")"], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "result = \":\" . join ( hextets )"}
{"src": ["convert", "result", "to", "lowercase", "and", "return", "it", "."], "cano_code": "return result . lower ( )", "decano_code": "return result . lower ( )", "token": ["return", "result", ".", "lower", "(", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "return result . lower ( )"}
{"src": ["define", "the", "function", "_sanitize_ipv4_mapping", "with", "an", "argument", "ip_str", "."], "cano_code": "def _sanitize_ipv4_mapping ( ip_str ) :pass", "decano_code": "def _sanitize_ipv4_mapping ( ip_str ) :", "token": ["def", "_sanitize_ipv4_mapping", "(", "ip_str", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def _sanitize_ipv4_mapping ( ip_str ) :"}
{"src": ["convert", "ip_str", "to", "lowercase", ",", "if", "it", "doesnt", "start", "with", "a", "string", "_STR:0_", ","], "cano_code": "if not ip_str . lower ( ) . startswith ( '_STR:0_' ) :pass", "decano_code": "if not ip_str . lower ( ) . startswith ( '_STR:0_' ) :", "token": ["if", "not", "ip_str", ".", "lower", "(", ")", ".", "startswith", "(", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :"}
{"src": ["return", "ip_str", "."], "cano_code": "return ip_str", "decano_code": "return ip_str", "token": ["return", "ip_str"], "type": ["KEYWORD", "NAME"], "raw_code": "return ip_str"}
{"src": ["split", "ip_str", "into", "parts", "by", "_STR:0_", ",", "substitute", "the", "result", "for", "hextets", "."], "cano_code": "hextets = ip_str . split ( '_STR:0_' )", "decano_code": "hextets = ip_str . split ( '_STR:0_' )", "token": ["hextets", "=", "ip_str", ".", "split", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "hextets = ip_str . split ( ':' )"}
{"src": ["if", "_STR:0_", "is", "contained", "in", "last", "elements", "of", "hextets", ","], "cano_code": "if '_STR:0_' in hextets [ - 1 ] :pass", "decano_code": "if '_STR:0_' in hextets [ - 1 ] :", "token": ["if", "\" _STR:0_ \"", "in", "hextets", "[", "-", "1", "]", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "NAME", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "if '.' in hextets [ - 1 ] :"}
{"src": ["return", "ip_str", "."], "cano_code": "return ip_str", "decano_code": "return ip_str", "token": ["return", "ip_str"], "type": ["KEYWORD", "NAME"], "raw_code": "return ip_str"}
{"src": ["ipv4_address", "is", "a", "string", "_STR:0_", "formated", "with", "first", "2", "elements", "of", "seventh", "element", "of", "hextets", "converted", "into", "hexadecimal", "number", ","], "cano_code": "ipv4_address = '_STR:0_' % (  int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) ,  int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) ,  )", "decano_code": "ipv4_address = '_STR:0_' % (  int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) ,  int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) ,  )", "token": ["ipv4_address", "=", "'_STR:0_'", "%", "(", "int", "(", "hextets", "[", "6", "]", "[", "0", ":", "2", "]", ",", "16", ")", ",", "int", "(", "hextets", "[", "6", "]", "[", "2", ":", "4", "]", ",", "16", ")", ",", "int", "(", "hextets", "[", "7", "]", "[", "0", ":", "2", "]", ",", "16", ")", ",", "int", "(", "hextets", "[", "7", "]", "[", "2", ":", "4", "]", ",", "16", ")", ",", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "OP", "OP"], "raw_code": "ipv4_address = \"%d.%d.%d.%d\" % (  int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) ,  int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) ,  )"}
{"src": ["second", "2", "elements", "of", "seventh", "element", "of", "hextets", "converted", "into", "hexadecimal", "number", ",", "first", "2", "elements", "of", "eight", "element", "of", "hextets", "converted", "into", "hexadecimal", "number", ",", "second", "2", "elements", "of", "eight", "element", "of", "hextets", "converted", "into", "hexadecimal", "number", ".", "join", "first", "5", "elements", "of", "hextets", "into", "a", "string", ",", "separated", "by", "_STR:0_", ",", "substitute", "the", "result", "for", "result", "."], "cano_code": "result = '_STR:0_' . join ( hextets [ 0 : 6 ] )", "decano_code": "result = '_STR:0_' . join ( hextets [ 0 : 6 ] )", "token": ["result", "=", "\" _STR:0_ \"", ".", "join", "(", "hextets", "[", "0", ":", "6", "]", ")"], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP"], "raw_code": "result = ':' . join ( hextets [ 0 : 6 ] )"}
{"src": ["append", "_STR:0_", "and", "ipv4_address", "to", "result", "."], "cano_code": "result += '_STR:0_' + ipv4_address", "decano_code": "result += '_STR:0_' + ipv4_address", "token": ["result", "+=", "\" _STR:0_ \"", "+", "ipv4_address"], "type": ["NAME", "OP", "STRING", "OP", "NAME"], "raw_code": "result += ':' + ipv4_address"}
{"src": ["return", "result", "."], "cano_code": "return result", "decano_code": "return result", "token": ["return", "result"], "type": ["KEYWORD", "NAME"], "raw_code": "return result"}
{"src": ["define", "the", "function", "_unpack_ipv4", "with", "an", "argument", "ip_str", "."], "cano_code": "def _unpack_ipv4 ( ip_str ) :pass", "decano_code": "def _unpack_ipv4 ( ip_str ) :", "token": ["def", "_unpack_ipv4", "(", "ip_str", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def _unpack_ipv4 ( ip_str ) :"}
{"src": ["convert", "ip_str", "to", "lowercase", ",", "if", "it", "doesnt", "start", "with", "a", "string", "_STR:0_", ","], "cano_code": "if not ip_str . lower ( ) . startswith ( '_STR:0_' ) :pass", "decano_code": "if not ip_str . lower ( ) . startswith ( '_STR:0_' ) :", "token": ["if", "not", "ip_str", ".", "lower", "(", ")", ".", "startswith", "(", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :"}
{"src": ["return", "None", "."], "cano_code": "return None", "decano_code": "return None", "token": ["return", "None"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return None"}
{"src": ["split", "ip_str", "into", "2", "parts", "from", "right", ",", "return", "second", "element", "of", "the", "result", "."], "cano_code": "return ip_str . rsplit ( ':' , 1 ) [ 1 ]", "decano_code": "return ip_str . rsplit ( ':' , 1 ) [ 1 ]", "token": ["return", "ip_str", ".", "rsplit", "(", "\" : \"", ",", "1", ")", "[", "1", "]"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP"], "raw_code": "return ip_str . rsplit ( ':' , 1 ) [ 1 ]"}
{"src": ["define", "the", "function", "is_valid_ipv6_address", "with", "an", "argument", "ip_str", "."], "cano_code": "def is_valid_ipv6_address ( ip_str ) :pass", "decano_code": "def is_valid_ipv6_address ( ip_str ) :", "token": ["def", "is_valid_ipv6_address", "(", "ip_str", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def is_valid_ipv6_address ( ip_str ) :"}
{"src": ["from", "django.core.validators", "[", "django", ".", "core", ".", "validators", "]", "import", "validate_ipv4_address", "."], "cano_code": "from django . core . validators import validate_ipv4_address", "decano_code": "from django . core . validators import validate_ipv4_address", "token": ["from", "django", ".", "core", ".", "validators", "import", "validate_ipv4_address"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . core . validators import validate_ipv4_address"}
{"src": ["if", "_STR:0_", "is", "not", "contained", "in", "ip_str", "."], "cano_code": "if '_STR:0_' not in ip_str :pass", "decano_code": "if '_STR:0_' not in ip_str :", "token": ["if", "\" _STR:0_ \"", "not", "in", "ip_str", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if ':' not in ip_str :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "count", "of", "occurrence", "of", "_STR:0_", "in", "ip_str", "is", "greater", "than", "integer", "1", ","], "cano_code": "if ip_str . count ( '_STR:0_' ) > 1 :pass", "decano_code": "if ip_str . count ( '_STR:0_' ) > 1 :", "token": ["if", "ip_str", ".", "count", "(", "\" _STR:0_ \"", ")", ">", "1", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NUMBER", "OP"], "raw_code": "if ip_str . count ( '::' ) > 1 :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "string", "_STR:0_", "is", "contained", "in", "ip_str", ","], "cano_code": "if '_STR:0_' in ip_str :pass", "decano_code": "if '_STR:0_' in ip_str :", "token": ["if", "\" _STR:0_ \"", "in", "ip_str", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "NAME", "OP"], "raw_code": "if ':::' in ip_str :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "ip_str", "starts", "with", "_STR:0_", ":", ":_STR:1_", ":", ",", "but", "it", "doesnt", "ends", "with", "_STR:2_", ","], "cano_code": "if ( ( ip_str . startswith ( ':' ) and not ip_str . startswith ( '_STR:2_' ) ) or  ( ip_str . endswith ( ':' ) and not ip_str . endswith ( '_STR:2_' ) ) ) :pass", "decano_code": "if ( ( ip_str . startswith ( ':' ) and not ip_str . startswith ( '_STR:2_' ) ) or  ( ip_str . endswith ( ':' ) and not ip_str . endswith ( '_STR:2_' ) ) ) :", "token": ["if", "(", "(", "ip_str", ".", "startswith", "(", "\" : \"", ")", "and", "not", "ip_str", ".", "startswith", "(", "\" _STR:2_ \"", ")", ")", "or", "(", "ip_str", ".", "endswith", "(", "\" : \"", ")", "and", "not", "ip_str", ".", "endswith", "(", "\" _STR:2_ \"", ")", ")", ")", ":"], "type": ["KEYWORD", "OP", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "OP", "OP"], "raw_code": "if ( ( ip_str . startswith ( ':' ) and not ip_str . startswith ( '::' ) ) or  ( ip_str . endswith ( ':' ) and not ip_str . endswith ( '::' ) ) ) :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "count", "of", "occurrence", "of", "_STR:0_", "in", "ip_str", "is", "greater", "than", "integer", "7", ","], "cano_code": "if ip_str . count ( '_STR:0_' ) > 7 :pass", "decano_code": "if ip_str . count ( '_STR:0_' ) > 7 :", "token": ["if", "ip_str", ".", "count", "(", "\" _STR:0_ \"", ")", ">", "7", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NUMBER", "OP"], "raw_code": "if ip_str . count ( ':' ) > 7 :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "_STR:0_", "is", "not", "contained", "in", "ip_str", "and", "number", "of", "occurrences", "of", "_STR:1_", "in", "ip_str", "is", "not", "equal", "to", "integer", "7", ","], "cano_code": "if '_STR:0_' not in ip_str and ip_str . count ( '_STR:1_' ) != 7 :pass", "decano_code": "if '_STR:0_' not in ip_str and ip_str . count ( '_STR:1_' ) != 7 :", "token": ["if", "\" _STR:0_ \"", "not", "in", "ip_str", "and", "ip_str", ".", "count", "(", "\" _STR:1_ \"", ")", "!=", "7", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NUMBER", "OP"], "raw_code": "if '::' not in ip_str and ip_str . count ( ':' ) != 7 :"}
{"src": ["if", "count", "of", "occurrence", "of", "_STR:0_", "in", "ip_str", "is", "not", "equal", "to", "integer", "3", ","], "cano_code": "if ip_str . count ( '_STR:0_' ) != 3 :pass", "decano_code": "if ip_str . count ( '_STR:0_' ) != 3 :", "token": ["if", "ip_str", ".", "count", "(", "\" _STR:0_ \"", ")", "!=", "3", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NUMBER", "OP"], "raw_code": "if ip_str . count ( '.' ) != 3 :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["call", "the", "function", "_explode_shorthand_ip_string", "with", "an", "argument", "ip_str", ",", "substitute", "the", "result", "for", "ip_str", "."], "cano_code": "ip_str = _explode_shorthand_ip_string ( ip_str )", "decano_code": "ip_str = _explode_shorthand_ip_string ( ip_str )", "token": ["ip_str", "=", "_explode_shorthand_ip_string", "(", "ip_str", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "ip_str = _explode_shorthand_ip_string ( ip_str )"}
{"src": ["split", "ip_str", "into", "parts", "by", "_STR:0_", ",", "for", "every", "hextet", "in", "the", "result", ","], "cano_code": "for hextet in ip_str . split ( '_STR:0_' ) :pass", "decano_code": "for hextet in ip_str . split ( '_STR:0_' ) :", "token": ["for", "hextet", "in", "ip_str", ".", "split", "(", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "for hextet in ip_str . split ( ':' ) :"}
{"src": ["if", "count", "of", "occurrence", "of", "_STR:0_", "in", "ip_str", "is", "equal", "to", "integer", "3", ","], "cano_code": "if hextet . count ( '_STR:0_' ) == 3 :pass", "decano_code": "if hextet . count ( '_STR:0_' ) == 3 :", "token": ["if", "hextet", ".", "count", "(", "\" _STR:0_ \"", ")", "==", "3", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NUMBER", "OP"], "raw_code": "if hextet . count ( '.' ) == 3 :"}
{"src": ["split", "ip_str", "by", "_STR:0_", ",", "if", "last", "element", "of", "the", "result", "is", "not", "equal", "to", "hextet", "."], "cano_code": "if not ip_str . split ( '_STR:0_' ) [ - 1 ] == hextet :pass", "decano_code": "if not ip_str . split ( '_STR:0_' ) [ - 1 ] == hextet :", "token": ["if", "not", "ip_str", ".", "split", "(", "\" _STR:0_ \"", ")", "[", "-", "1", "]", "==", "hextet", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "OP", "NUMBER", "OP", "OP", "NAME", "OP"], "raw_code": "if not ip_str . split ( ':' ) [ - 1 ] == hextet :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "function", "validate_ipv4_address", "with", "an", "argument", "hextet", "."], "cano_code": "validate_ipv4_address ( hextet )", "decano_code": "validate_ipv4_address ( hextet )", "token": ["validate_ipv4_address", "(", "hextet", ")"], "type": ["NAME", "OP", "NAME", "OP"], "raw_code": "validate_ipv4_address ( hextet )"}
{"src": ["if", "ValidationError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ValidationError :pass", "decano_code": "except ValidationError :", "token": ["except", "ValidationError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ValidationError :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["if", "hextet", "converted", "to", "hexadecimal", "number", "is", "smaller", "than", "hexadecimal", "0", ",", "or", "hextet", "converted", "to", "hexadecimal", "number", "is", "smaller", "than", "hexadecimal", "FFFF", ","], "cano_code": "if int ( hextet , 16 ) < 0x0 or int ( hextet , 16 ) > 0xFFFF :pass", "decano_code": "if int ( hextet , 16 ) < 0x0 or int ( hextet , 16 ) > 0xFFFF :", "token": ["if", "int", "(", "hextet", ",", "16", ")", "<", "0x0", "or", "int", "(", "hextet", ",", "16", ")", ">", "0xFFFF", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP"], "raw_code": "if int ( hextet , 16 ) < 0x0 or int ( hextet , 16 ) > 0xFFFF :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "ValueError", "exception", "is", "caught", "."], "cano_code": "try: pass\nexcept ValueError :pass", "decano_code": "except ValueError :", "token": ["except", "ValueError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ValueError :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["define", "the", "function", "_explode_shorthand_ip_string", "with", "an", "argument", "ip_str", "."], "cano_code": "def _explode_shorthand_ip_string ( ip_str ) :pass", "decano_code": "def _explode_shorthand_ip_string ( ip_str ) :", "token": ["def", "_explode_shorthand_ip_string", "(", "ip_str", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def _explode_shorthand_ip_string ( ip_str ) :"}
{"src": ["call", "the", "function", "_is_shorthand_ip", "with", "an", "argument", "ip_str", ",", "if", "it", "evaluates", "to", "false", ","], "cano_code": "if not _is_shorthand_ip ( ip_str ) :pass", "decano_code": "if not _is_shorthand_ip ( ip_str ) :", "token": ["if", "not", "_is_shorthand_ip", "(", "ip_str", ")", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if not _is_shorthand_ip ( ip_str ) :"}
{"src": ["return", "ip_str", "."], "cano_code": "return ip_str", "decano_code": "return ip_str", "token": ["return", "ip_str"], "type": ["KEYWORD", "NAME"], "raw_code": "return ip_str"}
{"src": ["new_ip", "is", "an", "empty", "list", ","], "cano_code": "new_ip = [ ]", "decano_code": "new_ip = [ ]", "token": ["new_ip", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "new_ip = [ ]"}
{"src": ["split", "ip_str", "by", "_STR:0_", ",", "substitute", "it", "for", "hextet", "."], "cano_code": "hextet = ip_str . split ( '_STR:0_' )", "decano_code": "hextet = ip_str . split ( '_STR:0_' )", "token": ["hextet", "=", "ip_str", ".", "split", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "hextet = ip_str . split ( '::' )"}
{"src": ["split", "ip_str", "into", "parts", "by", "_STR:0_", ",", "if", "_STR:1_", "is", "contained", "in", "the", "last", "element", "of", "the", "result", ","], "cano_code": "if '_STR:1_' in ip_str . split ( '_STR:0_' ) [ - 1 ] :pass", "decano_code": "if '_STR:1_' in ip_str . split ( '_STR:0_' ) [ - 1 ] :", "token": ["if", "\" _STR:1_ \"", "in", "ip_str", ".", "split", "(", "\" _STR:0_ \"", ")", "[", "-", "1", "]", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "if '.' in ip_str . split ( ':' ) [ - 1 ] :"}
{"src": ["fill_to", "is", "an", "integer", "7", "."], "cano_code": "fill_to = 7", "decano_code": "fill_to = 7", "token": ["fill_to", "=", "7"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "fill_to = 7"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["fill_to", "is", "an", "integer", "8", "."], "cano_code": "fill_to = 8", "decano_code": "fill_to = 8", "token": ["fill_to", "=", "8"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "fill_to = 8"}
{"src": ["if", "length", "of", "hextet", "is", "greater", "than", "integer", "1", ","], "cano_code": "if len ( hextet ) > 1 :pass", "decano_code": "if len ( hextet ) > 1 :", "token": ["if", "len", "(", "hextet", ")", ">", "1", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "OP"], "raw_code": "if len ( hextet ) > 1 :"}
{"src": ["split", "first", "and", "second", "element", "of", "hextet", "into", "parts", "by", "_STR:0_", ",", "sum", "their", "lengths", ",", "substitute", "the", "result", "for", "sep", "."], "cano_code": "sep = len ( hextet [ 0 ] . split ( '_STR:0_' ) ) + len ( hextet [ 1 ] . split ( '_STR:0_' ) )", "decano_code": "sep = len ( hextet [ 0 ] . split ( '_STR:0_' ) ) + len ( hextet [ 1 ] . split ( '_STR:0_' ) )", "token": ["sep", "=", "len", "(", "hextet", "[", "0", "]", ".", "split", "(", "\" _STR:0_ \"", ")", ")", "+", "len", "(", "hextet", "[", "1", "]", ".", "split", "(", "\" _STR:0_ \"", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "STRING", "OP", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "sep = len ( hextet [ 0 ] . split ( ':' ) ) + len ( hextet [ 1 ] . split ( ':' ) )"}
{"src": ["split", "first", "element", "of", "hextet", "into", "parts", "by", "_STR:0_", ",", "append", "them", "to", "new_ip", "."], "cano_code": "new_ip = hextet [ 0 ] . split ( '_STR:0_' )", "decano_code": "new_ip = hextet [ 0 ] . split ( '_STR:0_' )", "token": ["new_ip", "=", "hextet", "[", "0", "]", ".", "split", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "new_ip = hextet [ 0 ] . split ( ':' )"}
{"src": ["for", "every", "__", "in", "range", "of", "integers", "from", "0", "up", "to", "sep", "subtracted", "from", "fill_to", ","], "cano_code": "for __ in xrange ( fill_to - sep ) :pass", "decano_code": "for __ in xrange ( fill_to - sep ) :", "token": ["for", "__", "in", "xrange", "(", "fill_to", "-", "sep", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "for __ in xrange ( fill_to - sep ) :"}
{"src": ["append", "string", "_STR:0_", "to", "new_ip", "."], "cano_code": "new_ip . append ( '_STR:0_' )", "decano_code": "new_ip . append ( '_STR:0_' )", "token": ["new_ip", ".", "append", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "new_ip . append ( '0000' )"}
{"src": ["split", "second", "element", "of", "hextet", "into", "parts", "by", "_STR:0_", ",", "append", "them", "to", "new_ip", "."], "cano_code": "new_ip += hextet [ 1 ] . split ( '_STR:0_' )", "decano_code": "new_ip += hextet [ 1 ] . split ( '_STR:0_' )", "token": ["new_ip", "+=", "hextet", "[", "1", "]", ".", "split", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "new_ip += hextet [ 1 ] . split ( ':' )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["split", "ip_str", "into", "parts", "by", "_STR:0_", ",", "substitute", "the", "result", "for", "new_ip", "."], "cano_code": "new_ip = ip_str . split ( '_STR:0_' )", "decano_code": "new_ip = ip_str . split ( '_STR:0_' )", "token": ["new_ip", "=", "ip_str", ".", "split", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "new_ip = ip_str . split ( ':' )"}
{"src": ["ret_ip", "is", "an", "empty", "list", "."], "cano_code": "ret_ip = [ ]", "decano_code": "ret_ip = [ ]", "token": ["ret_ip", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "ret_ip = [ ]"}
{"src": ["for", "every", "hextet", "in", "new_ip", ","], "cano_code": "for hextet in new_ip :pass", "decano_code": "for hextet in new_ip :", "token": ["for", "hextet", "in", "new_ip", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for hextet in new_ip :"}
{"src": ["subtract", "length", "of", "hextet", "from", "4", ",", "create", "a", "string", "with", "previous", "result", "number", "of", "character", "_STR:0_", ",", "append", "hextet", "to", "it", ","], "cano_code": "ret_ip . append ( ( '_STR:0_' * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )", "decano_code": "ret_ip . append ( ( '_STR:0_' * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )", "token": ["ret_ip", ".", "append", "(", "(", "\" _STR:0_ \"", "*", "(", "4", "-", "len", "(", "hextet", ")", ")", "+", "hextet", ")", ".", "lower", "(", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "STRING", "OP", "OP", "NUMBER", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "ret_ip . append ( ( '0' * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )"}
{"src": ["convert", "the", "result", "into", "a", "lowercase", ",", "append", "it", "to", "ret_ip", ".", "join", "elements", "of", "ret_ip", "into", "a", "string", "separated", "with", "_STR:0_", ",", "return", "it", "."], "cano_code": "return '_STR:0_' . join ( ret_ip )", "decano_code": "return '_STR:0_' . join ( ret_ip )", "token": ["return", "\" _STR:0_ \"", ".", "join", "(", "ret_ip", ")"], "type": ["KEYWORD", "STRING", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return ':' . join ( ret_ip )"}
{"src": ["define", "the", "function", "_is_shorthand_ip", "with", "an", "argument", "ip_str", "."], "cano_code": "def _is_shorthand_ip ( ip_str ) :pass", "decano_code": "def _is_shorthand_ip ( ip_str ) :", "token": ["def", "_is_shorthand_ip", "(", "ip_str", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def _is_shorthand_ip ( ip_str ) :"}
{"src": ["if", "count", "of", "occurrence", "of", "_STR:0_", "in", "ip_str", "equals", "integer", "1", ","], "cano_code": "if ip_str . count ( '_STR:0_' ) == 1 :pass", "decano_code": "if ip_str . count ( '_STR:0_' ) == 1 :", "token": ["if", "ip_str", ".", "count", "(", "\" _STR:0_ \"", ")", "==", "1", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NUMBER", "OP"], "raw_code": "if ip_str . count ( '::' ) == 1 :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["split", "ip_str", "into", "parts", "by", "_STR:0_", ",", "for", "every", "x", "in", "the", "result", ",", "calculate", "length", "of", "x", ",", "if", "any", "is", "smaller", "than", "integer", "4", ","], "cano_code": "if any ( len ( x ) < 4 for x in ip_str . split ( '_STR:0_' ) ) :pass", "decano_code": "if any ( len ( x ) < 4 for x in ip_str . split ( '_STR:0_' ) ) :", "token": ["if", "any", "(", "len", "(", "x", ")", "<", "4", "for", "x", "in", "ip_str", ".", "split", "(", "\" _STR:0_ \"", ")", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "OP"], "raw_code": "if any ( len ( x ) < 4 for x in ip_str . split ( ':' ) ) :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["define", "the", "function", "is_iterable", "with", "an", "argument", "x", "."], "cano_code": "def is_iterable ( x ) :pass", "decano_code": "def is_iterable ( x ) :", "token": ["def", "is_iterable", "(", "x", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def is_iterable ( x ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["create", "an", "iterator", "out", "of", "x", "."], "cano_code": "iter ( x )", "decano_code": "iter ( x )", "token": ["iter", "(", "x", ")"], "type": ["KEYWORD", "OP", "NAME", "OP"], "raw_code": "iter ( x )"}
{"src": ["if", "TypeError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept TypeError :pass", "decano_code": "except TypeError :", "token": ["except", "TypeError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except TypeError :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["import", "module", "re", "."], "cano_code": "import re", "decano_code": "import re", "token": ["import", "re"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "import re"}
{"src": ["derive", "the", "class", "Tok", "from", "the", "object", "base", "class", "."], "cano_code": "class Tok ( object ) :pass", "decano_code": "class Tok ( object ) :", "token": ["class", "Tok", "(", "object", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "class Tok ( object ) :"}
{"src": ["num", "is", "an", "integer", "0", "."], "cano_code": "num = 0", "decano_code": "num = 0", "token": ["num", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "num = 0"}
{"src": ["define", "the", "method", "__init__", "with", "4", "arguments", ":", "self", ",", "name", ",", "regex", "and", "next", "set", "to", "None", "."], "cano_code": "def __init__ ( self , name , regex , next = None ) :pass", "decano_code": "def __init__ ( self , name , regex , next = None ) :", "token": ["def", "__init__", "(", "self", ",", "name", ",", "regex", ",", "next", "=", "None", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def __init__ ( self , name , regex , next = None ) :"}
{"src": ["substitute", "Tok.num", "[", "Tok", ".", "num", "]", "for", "self.id", "[", "self", ".", "id", "]", "."], "cano_code": "self . id = Tok . num", "decano_code": "self . id = Tok . num", "token": ["self", ".", "id", "=", "Tok", ".", "num"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME"], "raw_code": "self . id = Tok . num"}
{"src": ["increment", "Tok.num", "[", "Tok", ".", "num", "]", "with", "an", "integer", "1", "."], "cano_code": "Tok . num += 1", "decano_code": "Tok . num += 1", "token": ["Tok", ".", "num", "+=", "1"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER"], "raw_code": "Tok . num += 1"}
{"src": ["substitute", "name", "for", "self.name", "[", "self", ".", "name", "]", "."], "cano_code": "self . name = name", "decano_code": "self . name = name", "token": ["self", ".", "name", "=", "name"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . name = name"}
{"src": ["substitute", "regex", "for", "self.regex", "[", "self", ".", "regex", "]", "."], "cano_code": "self . regex = regex", "decano_code": "self . regex = regex", "token": ["self", ".", "regex", "=", "regex"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . regex = regex"}
{"src": ["substitute", "next", "for", "self.next", "[", "self", ".", "next", "]", "."], "cano_code": "self . next = next", "decano_code": "self . next = next", "token": ["self", ".", "next", "=", "next"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD"], "raw_code": "self . next = next"}
{"src": ["define", "the", "function", "literals", "with", "3", "arguments", ":", "choices", ",", "prefix", "set", "to", "an", "empty", "string", "and", "suffix", "set", "to", "an", "empty", "string", "."], "cano_code": "def literals ( choices , prefix = \"\" , suffix = \"\" ) :pass", "decano_code": "def literals ( choices , prefix = \"\" , suffix = \"\" ) :", "token": ["def", "literals", "(", "choices", ",", "prefix", "=", "\"  \"", ",", "suffix", "=", "\"  \"", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "def literals ( choices , prefix = \"\" , suffix = \"\" ) :"}
{"src": ["for", "every", "c", "in", "choices", "split", "into", "words", ",", "concatenate", "prefix", ",", "result", "of", "the", "function", "re.escape", "[", "re", ".", "escape", "]", "with", "an", "argument", "c", "and", "suffix", ","], "cano_code": "return \"|\" . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )", "decano_code": "return \"|\" . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )", "token": ["return", "\" | \"", ".", "join", "(", "prefix", "+", "re", ".", "escape", "(", "c", ")", "+", "suffix", "for", "c", "in", "choices", ".", "split", "(", ")", ")"], "type": ["KEYWORD", "STRING", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "return \"|\" . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )"}
{"src": ["and", "join", "the", "results", "into", "a", "string", ",", "separated", "with", "_STR:0_", "character", ",", "return", "the", "result", ".", "derive", "the", "class", "Lexer", "from", "the", "object", "base", "class", "."], "cano_code": "class Lexer ( object ) :pass", "decano_code": "class Lexer ( object ) :", "token": ["class", "Lexer", "(", "object", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "class Lexer ( object ) :"}
{"src": ["define", "the", "method", "__init__", "with", "3", "arguments", "self", ",", "states", "and", "first", "."], "cano_code": "def __init__ ( self , states , first ) :pass", "decano_code": "def __init__ ( self , states , first ) :", "token": ["def", "__init__", "(", "self", ",", "states", ",", "first", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def __init__ ( self , states , first ) :"}
{"src": ["self.regexes", "[", "self", ".", "regexes", "]", "is", "an", "empty", "dictionary", "."], "cano_code": "self . regexes = { }", "decano_code": "self . regexes = { }", "token": ["self", ".", "regexes", "=", "{", "}"], "type": ["NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "self . regexes = { }"}
{"src": ["self.tokens", "[", "self", ".", "tokens", "]", "is", "an", "empty", "dictionary", "."], "cano_code": "self . toks = { }", "decano_code": "self . toks = { }", "token": ["self", ".", "toks", "=", "{", "}"], "type": ["NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "self . toks = { }"}
{"src": ["call", "the", "method", "states.items", "[", "states", ".", "items", "]", ",", "for", "every", "state", "and", "rules", "in", "the", "result", ","], "cano_code": "for state , rules in states . items ( ) :pass", "decano_code": "for state , rules in states . items ( ) :", "token": ["for", "state", ",", "rules", "in", "states", ".", "items", "(", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "for state , rules in states . items ( ) :"}
{"src": ["parts", "is", "an", "empty", "list", "."], "cano_code": "parts = [ ]", "decano_code": "parts = [ ]", "token": ["parts", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "parts = [ ]"}
{"src": ["for", "every", "tok", "in", "rules", ","], "cano_code": "for tok in rules :pass", "decano_code": "for tok in rules :", "token": ["for", "tok", "in", "rules", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for tok in rules :"}
{"src": ["groupid", "is", "a", "string", "_STR:0_", "formated", "with", "tok.id", "[", "tok", ".", "id", "]", "."], "cano_code": "groupid = '_STR:0_' % tok . id", "decano_code": "groupid = '_STR:0_' % tok . id", "token": ["groupid", "=", "\" _STR:0_ \"", "%", "tok", ".", "id"], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "KEYWORD"], "raw_code": "groupid = \"t%d\" % tok . id"}
{"src": ["substitute", "tok", "for", "value", "under", "the", "groupid", "key", "of", "the", "self.toks", "[", "self", ".", "toks", "]", "dictionary", "."], "cano_code": "self . toks [ groupid ] = tok", "decano_code": "self . toks [ groupid ] = tok", "token": ["self", ".", "toks", "[", "groupid", "]", "=", "tok"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "self . toks [ groupid ] = tok"}
{"src": ["format", "a", "string", "_STR:0_", "with", "groupid", "and", "tok.regex", "[", "tok", ".", "regex", "]", ",", "append", "it", "to", "the", "parts", "."], "cano_code": "parts . append ( '_STR:0_' % ( groupid , tok . regex ) )", "decano_code": "parts . append ( '_STR:0_' % ( groupid , tok . regex ) )", "token": ["parts", ".", "append", "(", "\" _STR:0_ \"", "%", "(", "groupid", ",", "tok", ".", "regex", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "parts . append ( \"(?P<%s>%s)\" % ( groupid , tok . regex ) )"}
{"src": ["call", "the", "function", "re.compile", "[", "re", ".", "compile", "]", "with", "2", "arguments", ":", "elements", "of", "parts", "joined", "into", "a", "string", ",", "separated", "with", "_STR:0_", ","], "cano_code": "self . regexes [ state ] = re . compile ( \"|\" . join ( parts ) , re . MULTILINE | re . VERBOSE )", "decano_code": "self . regexes [ state ] = re . compile ( \"|\" . join ( parts ) , re . MULTILINE | re . VERBOSE )", "token": ["self", ".", "regexes", "[", "state", "]", "=", "re", ".", "compile", "(", "\" | \"", ".", "join", "(", "parts", ")", ",", "re", ".", "MULTILINE", "|", "re", ".", "VERBOSE", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "self . regexes [ state ] = re . compile ( \"|\" . join ( parts ) , re . MULTILINE | re . VERBOSE )"}
{"src": ["and", "result", "of", "bitwise", "OR", "performed", "on", "2", "operands", ":", "re.MULTILINE", "[", "re", ".", "MULTILINE", "]", "and", "re.VERBOSE", "[", "re", ".", "VERBOSE", "]", ",", "substitute", "the", "result", "for", "value", "under", "the", "state", "key", "of", "the", "self.regexes", "[", "self", ".", "regexes", "]", "dictionary", ".", "substitute", "first", "for", "self.state", "[", "self", ".", "state", "]", "."], "cano_code": "self . state = first", "decano_code": "self . state = first", "token": ["self", ".", "state", "=", "first"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . state = first"}
{"src": ["define", "the", "method", "lex", "with", "2", "arguments", "self", "and", "text", "."], "cano_code": "def lex ( self , text ) :pass", "decano_code": "def lex ( self , text ) :", "token": ["def", "lex", "(", "self", ",", "text", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def lex ( self , text ) :"}
{"src": ["substitute", "length", "of", "text", "for", "end", "."], "cano_code": "end = len ( text )", "decano_code": "end = len ( text )", "token": ["end", "=", "len", "(", "text", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "end = len ( text )"}
{"src": ["substitute", "self.state", "[", "self", ".", "state", "]", "for", "state", "."], "cano_code": "state = self . state", "decano_code": "state = self . state", "token": ["state", "=", "self", ".", "state"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "state = self . state"}
{"src": ["substitute", "self.regexes", "[", "self", ".", "regexes", "]", "for", "regexes", "."], "cano_code": "regexes = self . regexes", "decano_code": "regexes = self . regexes", "token": ["regexes", "=", "self", ".", "regexes"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "regexes = self . regexes"}
{"src": ["substitute", "self.toks", "[", "self", ".", "toks", "]", "for", "toks", "."], "cano_code": "toks = self . toks", "decano_code": "toks = self . toks", "token": ["toks", "=", "self", ".", "toks"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "toks = self . toks"}
{"src": ["start", "is", "an", "integer", "0", "."], "cano_code": "start = 0", "decano_code": "start = 0", "token": ["start", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "start = 0"}
{"src": ["while", "start", "is", "lesser", "than", "end", "."], "cano_code": "while start < end :pass", "decano_code": "while start < end :", "token": ["while", "start", "<", "end", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "while start < end :"}
{"src": ["get", "the", "value", "under", "the", "state", "key", "of", "the", "regexes", "dictionary", ",", "call", "the", "method", "finditer", "on", "the", "result", "with", "2", "arguments", ":", "text", "and", "start", ","], "cano_code": "for match in regexes [ state ] . finditer ( text , start ) :pass", "decano_code": "for match in regexes [ state ] . finditer ( text , start ) :", "token": ["for", "match", "in", "regexes", "[", "state", "]", ".", "finditer", "(", "text", ",", "start", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "for match in regexes [ state ] . finditer ( text , start ) :"}
{"src": ["for", "every", "match", "in", "the", "result", ",", "substitute", "match.lastgroup", "[", "match", ".", "lastgroup", "]", "for", "name", "."], "cano_code": "name = match . lastgroup", "decano_code": "name = match . lastgroup", "token": ["name", "=", "match", ".", "lastgroup"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "name = match . lastgroup"}
{"src": ["substitute", "value", "under", "the", "name", "key", "of", "the", "toks", "dictionary", "for", "tok", "."], "cano_code": "tok = toks [ name ]", "decano_code": "tok = toks [ name ]", "token": ["tok", "=", "toks", "[", "name", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "tok = toks [ name ]"}
{"src": ["call", "the", "method", "match.group", "[", "match", ".", "group", "]", "with", "an", "arugument", "name", ",", "substitute", "the", "result", "for", "toktext", "."], "cano_code": "toktext = match . group ( name )", "decano_code": "toktext = match . group ( name )", "token": ["toktext", "=", "match", ".", "group", "(", "name", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "toktext = match . group ( name )"}
{"src": ["increment", "start", "by", "length", "of", "toktext", "."], "cano_code": "start += len ( toktext )", "decano_code": "start += len ( toktext )", "token": ["start", "+=", "len", "(", "toktext", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "start += len ( toktext )"}
{"src": ["yield", "a", "tuple", "with", "2", "elements", ":", "tok.name", "[", "tok", ".", "name", "]", "and", "toktext", "."], "cano_code": "yield ( tok . name , toktext )", "decano_code": "yield ( tok . name , toktext )", "token": ["yield", "(", "tok", ".", "name", ",", "toktext", ")"], "type": ["KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "yield ( tok . name , toktext )"}
{"src": ["if", "tok.next", "[", "tok", ".", "next", "]", "is", "true", ","], "cano_code": "if tok . next :pass", "decano_code": "if tok . next :", "token": ["if", "tok", ".", "next", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP"], "raw_code": "if tok . next :"}
{"src": ["substitute", "tok.next", "[", "tok", ".", "next", "]", "for", "state", "."], "cano_code": "state = tok . next", "decano_code": "state = tok . next", "token": ["state", "=", "tok", ".", "next"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD"], "raw_code": "state = tok . next"}
{"src": ["break", "from", "the", "loop", "execution", "."], "cano_code": "break", "decano_code": "break", "token": ["break"], "type": ["NAME"], "raw_code": "break"}
{"src": ["substitute", "state", "for", "self.state", "[", "self", ".", "state", "]", "."], "cano_code": "self . state = state", "decano_code": "self . state = state", "token": ["self", ".", "state", "=", "state"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . state = state"}
{"src": ["derive", "the", "class", "JsLexer", "from", "the", "Lexer", "base", "class", "."], "cano_code": "class JsLexer ( Lexer ) :pass", "decano_code": "class JsLexer ( Lexer ) :", "token": ["class", "JsLexer", "(", "Lexer", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "class JsLexer ( Lexer ) :"}
{"src": ["both_before", "is", "a", "list", "containing", "14", "elements", ",", "all", "of", "them", "are", "instances", "of", "Tok", "class", ",", "created", "with", "2", "arguments", ",", "a", "string", "and", "a", "raw", "string", "."], "cano_code": "both_before = [  Tok ( \"comment\" , r\"/\\*(.|\\n)*?\\*/\" ) ,  Tok ( \"linecomment\" , r\"//.*?$\" ) ,  Tok ( \"ws\" , r\"\\s+\" ) ,  Tok ( \"keyword\" , literals ( \"\"\"                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            \"\"\" , suffix = r\"\\b\" ) , next = 'reg' ) ,  Tok ( \"reserved\" , literals ( \"null true false\" , suffix = r\"\\b\" ) , next = 'div' ) ,  Tok ( \"id\" , r\"\"\"                   ([a-zA-Z_$   ]|\\\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*  # rest chars                   \"\"\" , next = 'div' ) ,  Tok ( \"hnum\" , r\"0[xX][0-9a-fA-F]+\" , next = 'div' ) ,  Tok ( \"onum\" , r\"0[0-7]+\" ) ,  Tok ( \"dnum\" , r\"\"\"                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \\.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \\.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     \"\"\" , next = 'div' ) ,  Tok ( \"punct\" , literals ( \"\"\"                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          \"\"\" ) , next = \"reg\" ) ,  Tok ( \"punct\" , literals ( \"++ -- ) ]\" ) , next = 'div' ) ,  Tok ( \"punct\" , literals ( \"{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =\" ) , next = 'reg' ) ,  Tok ( \"string\" , r'\"([^\"\\\\]|(\\\\(.|\\n)))*?\"' , next = 'div' ) ,  Tok ( \"string\" , r\"'([^'\\\\]|(\\\\(.|\\n)))*?'\" , next = 'div' ) ,  ]", "decano_code": "both_before = [  Tok ( \"comment\" , r\"/\\*(.|\\n)*?\\*/\" ) ,  Tok ( \"linecomment\" , r\"//.*?$\" ) ,  Tok ( \"ws\" , r\"\\s+\" ) ,  Tok ( \"keyword\" , literals ( \"\"\"                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            \"\"\" , suffix = r\"\\b\" ) , next = 'reg' ) ,  Tok ( \"reserved\" , literals ( \"null true false\" , suffix = r\"\\b\" ) , next = 'div' ) ,  Tok ( \"id\" , r\"\"\"                   ([a-zA-Z_$   ]|\\\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*  # rest chars                   \"\"\" , next = 'div' ) ,  Tok ( \"hnum\" , r\"0[xX][0-9a-fA-F]+\" , next = 'div' ) ,  Tok ( \"onum\" , r\"0[0-7]+\" ) ,  Tok ( \"dnum\" , r\"\"\"                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \\.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \\.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     \"\"\" , next = 'div' ) ,  Tok ( \"punct\" , literals ( \"\"\"                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          \"\"\" ) , next = \"reg\" ) ,  Tok ( \"punct\" , literals ( \"++ -- ) ]\" ) , next = 'div' ) ,  Tok ( \"punct\" , literals ( \"{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =\" ) , next = 'reg' ) ,  Tok ( \"string\" , r'\"([^\"\\\\]|(\\\\(.|\\n)))*?\"' , next = 'div' ) ,  Tok ( \"string\" , r\"'([^'\\\\]|(\\\\(.|\\n)))*?'\" , next = 'div' ) ,  ]", "token": ["both_before", "=", "[", "Tok", "(", "\"comment\"", ",", "r\"/\\*(.|\\n)*?\\*/\"", ")", ",", "Tok", "(", "\"linecomment\"", ",", "r\"//.*?$\"", ")", ",", "Tok", "(", "\"ws\"", ",", "r\"\\s+\"", ")", ",", "Tok", "(", "\"keyword\"", ",", "literals", "(", "\"\"\"                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            \"\"\"", ",", "suffix", "=", "r\"\\b\"", ")", ",", "next", "=", "'reg'", ")", ",", "Tok", "(", "\"reserved\"", ",", "literals", "(", "\"null true false\"", ",", "suffix", "=", "r\"\\b\"", ")", ",", "next", "=", "'div'", ")", ",", "Tok", "(", "\"id\"", ",", "r\"\"\"                   ([a-zA-Z_$   ]|\\\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*  # rest chars                   \"\"\"", ",", "next", "=", "'div'", ")", ",", "Tok", "(", "\"hnum\"", ",", "r\"0[xX][0-9a-fA-F]+\"", ",", "next", "=", "'div'", ")", ",", "Tok", "(", "\"onum\"", ",", "r\"0[0-7]+\"", ")", ",", "Tok", "(", "\"dnum\"", ",", "r\"\"\"                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \\.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \\.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     \"\"\"", ",", "next", "=", "'div'", ")", ",", "Tok", "(", "\"punct\"", ",", "literals", "(", "\"\"\"                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          \"\"\"", ")", ",", "next", "=", "\"reg\"", ")", ",", "Tok", "(", "\"punct\"", ",", "literals", "(", "\"++ -- ) ]\"", ")", ",", "next", "=", "'div'", ")", ",", "Tok", "(", "\"punct\"", ",", "literals", "(", "\"{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =\"", ")", ",", "next", "=", "'reg'", ")", ",", "Tok", "(", "\"string\"", ",", "r'\"([^\"\\\\]|(\\\\(.|\\n)))*?\"'", ",", "next", "=", "'div'", ")", ",", "Tok", "(", "\"string\"", ",", "r\"'([^'\\\\]|(\\\\(.|\\n)))*?'\"", ",", "next", "=", "'div'", ")", ",", "]"], "type": ["NAME", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "OP"], "raw_code": "both_before = [  Tok ( \"comment\" , r\"/\\*(.|\\n)*?\\*/\" ) ,  Tok ( \"linecomment\" , r\"//.*?$\" ) ,  Tok ( \"ws\" , r\"\\s+\" ) ,  Tok ( \"keyword\" , literals ( \"\"\"                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            \"\"\" , suffix = r\"\\b\" ) , next = 'reg' ) ,  Tok ( \"reserved\" , literals ( \"null true false\" , suffix = r\"\\b\" ) , next = 'div' ) ,  Tok ( \"id\" , r\"\"\"                   ([a-zA-Z_$   ]|\\\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\\\u[0-9a-fA-F]{4})*  # rest chars                   \"\"\" , next = 'div' ) ,  Tok ( \"hnum\" , r\"0[xX][0-9a-fA-F]+\" , next = 'div' ) ,  Tok ( \"onum\" , r\"0[0-7]+\" ) ,  Tok ( \"dnum\" , r\"\"\"                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \\.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \\.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     \"\"\" , next = 'div' ) ,  Tok ( \"punct\" , literals ( \"\"\"                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          \"\"\" ) , next = \"reg\" ) ,  Tok ( \"punct\" , literals ( \"++ -- ) ]\" ) , next = 'div' ) ,  Tok ( \"punct\" , literals ( \"{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =\" ) , next = 'reg' ) ,  Tok ( \"string\" , r'\"([^\"\\\\]|(\\\\(.|\\n)))*?\"' , next = 'div' ) ,  Tok ( \"string\" , r\"'([^'\\\\]|(\\\\(.|\\n)))*?'\" , next = 'div' ) ,  ]"}
{"src": ["both_after", "is", "an", "list", "with", "an", "element", "instance", "of", "Tok", "class", ",", "created", "with", "2", "arguments", ":", "string", "_STR:0_", "and", "raw", "string", "_STR:1_", "."], "cano_code": "both_after = [  Tok ( \"other\" , r\".\" ) ,  ]", "decano_code": "both_after = [  Tok ( \"other\" , r\".\" ) ,  ]", "token": ["both_after", "=", "[", "Tok", "(", "\" other \"", ",", "\" . \"", ")", ",", "]"], "type": ["NAME", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "OP", "OP"], "raw_code": "both_after = [  Tok ( \"other\" , r\".\" ) ,  ]"}
{"src": ["states", "is", "a", "dictionary", "with", "2", "arguments", ":", "appended", "list", "with", "an", "element", "instance", "of", "a", "class", "Tok", ",", "created", "with", "3", "arguments", ":", "_STR:0_", ","], "cano_code": "states = {   'div' : both_before + [  Tok ( '_STR:0_' , literals ( \"/= /\" ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( \"regex\" ,  r\"\"\"                     /                       # opening slash                     # First character is..                     (   [^*\\\\/[]            # anything but * \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )                     # Following characters are same, except for excluding a star                     (   [^\\\\/[]             # anything but \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 \"\"\" , next = 'div' ) ,  ] + both_after ,  }", "decano_code": "states = {   'div' : both_before + [  Tok ( '_STR:0_' , literals ( \"/= /\" ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( \"regex\" ,  r\"\"\"                     /                       # opening slash                     # First character is..                     (   [^*\\\\/[]            # anything but * \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )                     # Following characters are same, except for excluding a star                     (   [^\\\\/[]             # anything but \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 \"\"\" , next = 'div' ) ,  ] + both_after ,  }", "token": ["states", "=", "{", "'div'", ":", "both_before", "+", "[", "Tok", "(", "'_STR:0_'", ",", "literals", "(", "\"/= /\"", ")", ",", "next", "=", "'reg'", ")", ",", "]", "+", "both_after", ",", "'reg'", ":", "both_before", "+", "[", "Tok", "(", "\"regex\"", ",", "r\"\"\"                     /                       # opening slash                     # First character is..                     (   [^*\\\\/[]            # anything but * \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )                     # Following characters are same, except for excluding a star                     (   [^\\\\/[]             # anything but \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 \"\"\"", ",", "next", "=", "'div'", ")", ",", "]", "+", "both_after", ",", "}"], "type": ["NAME", "OP", "OP", "STRING", "OP", "NAME", "OP", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "OP", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "OP", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "states = {   'div' : both_before + [  Tok ( \"punct\" , literals ( \"/= /\" ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( \"regex\" ,  r\"\"\"                     /                       # opening slash                     # First character is..                     (   [^*\\\\/[]            # anything but * \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )                     # Following characters are same, except for excluding a star                     (   [^\\\\/[]             # anything but \\ / or [                     |   \\\\.                 # or an escape sequence                     |   \\[                  # or a class, which has                             (   [^\\]\\\\]     #   anything but \\ or ]                             |   \\\\.         #   or an escape sequence                             )*              #   many times                         \\]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 \"\"\" , next = 'div' ) ,  ] + both_after ,  }"}
{"src": ["result", "of", "the", "function", "literals", "called", "with", "an", "argument", "string", "_STR:0_", "and", "next", "as", "a", "string", "_STR:1_", ",", "to", "the", "both_before", ",", "appended", "both_after", "to", "the", "previous", "result", ",", "for", "_STR:2_", "and", "appended", "list", "with", "an", "element", "instance", "of", "a", "class", "Tok", ",", "created", "with", "3", "arguments", ":", "string", "_STR:3_", ",", "raw", "string", "_STR:4_", ",", "and", "next", "as", "a", "string", "_STR:2_", ",", "to", "the", "both_before", ",", "appended", "both_after", "to", "the", "previous", "result", "for", "_STR:2_", ".", "define", "the", "method", "__init__", "with", "an", "argument", "self", "."], "cano_code": "def __init__ ( self ) :pass", "decano_code": "def __init__ ( self ) :", "token": ["def", "__init__", "(", "self", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def __init__ ( self ) :"}
{"src": ["call", "the", "method", "__init__", "with", "2", "arguments", ":", "self.states", "[", "self", ".", "states", "]", "and", "string", "_STR:0_", "from", "the", "base", "class", "of", "the", "class", "JsLexer", "."], "cano_code": "super ( JsLexer , self ) . __init__ ( self . states , '_STR:0_' )", "decano_code": "super ( JsLexer , self ) . __init__ ( self . states , '_STR:0_' )", "token": ["super", "(", "JsLexer", ",", "self", ")", ".", "__init__", "(", "self", ".", "states", ",", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "super ( JsLexer , self ) . __init__ ( self . states , 'reg' )"}
{"src": ["define", "the", "function", "prepare_js_for_gettext", "with", "an", "argument", "js", "."], "cano_code": "def prepare_js_for_gettext ( js ) :pass", "decano_code": "def prepare_js_for_gettext ( js ) :", "token": ["def", "prepare_js_for_gettext", "(", "js", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def prepare_js_for_gettext ( js ) :"}
{"src": ["define", "the", "function", "escape_quotes", "with", "an", "argument", "m", "."], "cano_code": "def escape_quotes ( m ) :pass", "decano_code": "def escape_quotes ( m ) :", "token": ["def", "escape_quotes", "(", "m", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def escape_quotes ( m ) :"}
{"src": ["call", "the", "method", "m.group", "[", "m", ".", "group", "]", "with", "an", "argument", "integer", "0", ",", "substitute", "the", "result", "for", "s", "."], "cano_code": "s = m . group ( 0 )", "decano_code": "s = m . group ( 0 )", "token": ["s", "=", "m", ".", "group", "(", "0", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP"], "raw_code": "s = m . group ( 0 )"}
{"src": ["if", "s", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if s == '_STR:0_' :pass", "decano_code": "if s == '_STR:0_' :", "token": ["if", "s", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if s == '\"' :"}
{"src": ["return", "an", "raw", "string", "_STR:0_", "."], "cano_code": "return r'_STR:0_'", "decano_code": "return r'_STR:0_'", "token": ["return", "\" _STR:0_ \""], "type": ["KEYWORD", "STRING"], "raw_code": "return r'\\\"'"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["return", "s", "."], "cano_code": "return s", "decano_code": "return s", "token": ["return", "s"], "type": ["KEYWORD", "NAME"], "raw_code": "return s"}
{"src": ["lexer", "is", "an", "instance", "of", "JsLexer", "class", "."], "cano_code": "lexer = JsLexer ( )", "decano_code": "lexer = JsLexer ( )", "token": ["lexer", "=", "JsLexer", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP"], "raw_code": "lexer = JsLexer ( )"}
{"src": ["c", "is", "an", "empty", "list", "."], "cano_code": "c = [ ]", "decano_code": "c = [ ]", "token": ["c", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "c = [ ]"}
{"src": ["call", "the", "method", "lexer.lex", "[", "lexer", ".", "lex", "]", "with", "an", "arguments", "js", ",", "for", "every", "name", "and", "tok", "in", "the", "result", ","], "cano_code": "for name , tok in lexer . lex ( js ) :pass", "decano_code": "for name , tok in lexer . lex ( js ) :", "token": ["for", "name", ",", "tok", "in", "lexer", ".", "lex", "(", "js", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "for name , tok in lexer . lex ( js ) :"}
{"src": ["if", "name", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if name == '_STR:0_' :pass", "decano_code": "if name == '_STR:0_' :", "token": ["if", "name", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if name == 'regex' :"}
{"src": ["tok", "is", "a", "string", "_STR:0_", ","], "cano_code": "tok = '_STR:0_'", "decano_code": "tok = '_STR:0_'", "token": ["tok", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "tok = '\"REGEX\"'"}
{"src": ["otherwise", "if", "name", "starts", "with", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif name == '_STR:0_' :pass", "decano_code": "elif name == '_STR:0_' :", "token": ["elif", "name", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif name == 'string' :"}
{"src": ["if", "tok", "starts", "with", "_STR:0_", ","], "cano_code": "if tok . startswith ( '_STR:0_' ) :pass", "decano_code": "if tok . startswith ( '_STR:0_' ) :", "token": ["if", "tok", ".", "startswith", "(", "\" _STR:0_ \"", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "if tok . startswith ( \"'\" ) :"}
{"src": ["call", "the", "function", "re.sub", "[", "re", ".", "sub", "]", "with", "3", "arguments", ":", "raw", "string", "_STR:0_", ",", "escape_quotes", "and", "tok", "without", "the", "first", "and", "last", "element", ","], "cano_code": "guts = re . sub ( r'_STR:0_' , escape_quotes , tok [ 1 : - 1 ] )", "decano_code": "guts = re . sub ( r'_STR:0_' , escape_quotes , tok [ 1 : - 1 ] )", "token": ["guts", "=", "re", ".", "sub", "(", "\" _STR:0_ \"", ",", "escape_quotes", ",", "tok", "[", "1", ":", "-", "1", "]", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "guts = re . sub ( r\"\\\\.|.\" , escape_quotes , tok [ 1 : - 1 ] )"}
{"src": ["substitute", "the", "result", "for", "guts", ".", "concatenate", "string", "_STR:0_", ",", "guts", "and", "string", "_STR:0_", ",", "substitute", "the", "result", "for", "tok", "."], "cano_code": "tok = '_STR:0_' + guts + '_STR:0_'", "decano_code": "tok = '_STR:0_' + guts + '_STR:0_'", "token": ["tok", "=", "\" _STR:0_ \"", "+", "guts", "+", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "STRING"], "raw_code": "tok = '\"' + guts + '\"'"}
{"src": ["otherwise", "if", "name", "equals", "a", "string", "_STR:0_", "."], "cano_code": "if True: pass\nelif name == '_STR:0_' :pass", "decano_code": "elif name == '_STR:0_' :", "token": ["elif", "name", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif name == 'id' :"}
{"src": ["replace", "every", "occurrence", "of", "_STR:0_U", "'", ",", "substitute", "the", "result", "for", "tok", "."], "cano_code": "tok = tok . replace ( \"\\\\\" , \"U\" )", "decano_code": "tok = tok . replace ( \"\\\\\" , \"U\" )", "token": ["tok", "=", "tok", ".", "replace", "(", "\" \\\\ \"", ",", "\" U \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP"], "raw_code": "tok = tok . replace ( \"\\\\\" , \"U\" )"}
{"src": ["append", "tok", "to", "c", "."], "cano_code": "c . append ( tok )", "decano_code": "c . append ( tok )", "token": ["c", ".", "append", "(", "tok", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "c . append ( tok )"}
{"src": ["join", "elements", "of", "c", "into", "a", "string", ",", "return", "it", "."], "cano_code": "return '' . join ( c )", "decano_code": "return '' . join ( c )", "token": ["return", "\"  \"", ".", "join", "(", "c", ")"], "type": ["KEYWORD", "STRING", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return '' . join ( c )"}
{"src": ["import", "module", "logging", "."], "cano_code": "import logging", "decano_code": "import logging", "token": ["import", "logging"], "type": ["KEYWORD", "NAME"], "raw_code": "import logging"}
{"src": ["import", "module", "sys", "."], "cano_code": "import sys", "decano_code": "import sys", "token": ["import", "sys"], "type": ["KEYWORD", "NAME"], "raw_code": "import sys"}
{"src": ["import", "module", "warnings", "."], "cano_code": "import warnings", "decano_code": "import warnings", "token": ["import", "warnings"], "type": ["KEYWORD", "NAME"], "raw_code": "import warnings"}
{"src": ["from", "django.conf", "[", "django", ".", "conf", "]", "import", "settings", "into", "default", "name", "space", "."], "cano_code": "from django . conf import settings", "decano_code": "from django . conf import settings", "token": ["from", "django", ".", "conf", "import", "settings"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . conf import settings"}
{"src": ["from", "django.core", "[", "django", ".", "core", "]", "import", "mail", "into", "default", "name", "space", "."], "cano_code": "from django . core import mail", "decano_code": "from django . core import mail", "token": ["from", "django", ".", "core", "import", "mail"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . core import mail"}
{"src": ["from", "django.core.mail", "[", "django", ".", "core", ".", "mail", "]", "import", "get_connection", "into", "default", "name", "space", "."], "cano_code": "from django . core . mail import get_connection", "decano_code": "from django . core . mail import get_connection", "token": ["from", "django", ".", "core", ".", "mail", "import", "get_connection"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . core . mail import get_connection"}
{"src": ["from", "django.utils.deprecation", "[", "django", ".", "utils", ".", "deprecation", "]", "import", "RemovedInNextVersionWarning", "into", "default", "name", "space", "."], "cano_code": "from django . utils . deprecation import RemovedInNextVersionWarning", "decano_code": "from django . utils . deprecation import RemovedInNextVersionWarning", "token": ["from", "django", ".", "utils", ".", "deprecation", "import", "RemovedInNextVersionWarning"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . deprecation import RemovedInNextVersionWarning"}
{"src": ["from", "django.utils.module_loading", "[", "django", ".", "utils", ".", "module_loading", "]", "import", "import_string", "into", "default", "name", "space", "."], "cano_code": "from django . utils . module_loading import import_string", "decano_code": "from django . utils . module_loading import import_string", "token": ["from", "django", ".", "utils", ".", "module_loading", "import", "import_string"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . module_loading import import_string"}
{"src": ["from", "django.views.debug", "[", "django", ".", "views", ".", "debug", "]", "import", "ExceptionReporter", "and", "get_exception_reporter_filter", "into", "default", "name", "space", "."], "cano_code": "from django . views . debug import ExceptionReporter , get_exception_reporter_filter", "decano_code": "from django . views . debug import ExceptionReporter , get_exception_reporter_filter", "token": ["from", "django", ".", "views", ".", "debug", "import", "ExceptionReporter", ",", "get_exception_reporter_filter"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME"], "raw_code": "from django . views . debug import ExceptionReporter , get_exception_reporter_filter"}
{"src": ["from", "logging", "import", "NullHandler", "."], "cano_code": "from logging import NullHandler", "decano_code": "from logging import NullHandler", "token": ["from", "logging", "import", "NullHandler"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from logging import NullHandler"}
{"src": ["from", "logging.config", "[", "logging", ".", "config", "]", "import", "dictConfig", "."], "cano_code": "from logging . config import dictConfig", "decano_code": "from logging . config import dictConfig", "token": ["from", "logging", ".", "config", "import", "dictConfig"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from logging . config import dictConfig"}
{"src": ["substitute", "logging.getLogger", "[", "logging", ".", "getLogger", "]", "for", "getLogger", "."], "cano_code": "getLogger = logging . getLogger", "decano_code": "getLogger = logging . getLogger", "token": ["getLogger", "=", "logging", ".", "getLogger"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "getLogger = logging . getLogger"}
{"src": ["DEFAULT_LOGGING", "is", "a", "dictionary", "with", "5", "initial", "entries", ":", "1", "for", "_STR:0_", ",", "False", "for", "_STR:1_", ","], "cano_code": "DEFAULT_LOGGING = {  '_STR:0_' : 1 ,  '_STR:1_' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }", "decano_code": "DEFAULT_LOGGING = {  '_STR:0_' : 1 ,  '_STR:1_' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }", "token": ["DEFAULT_LOGGING", "=", "{", "'_STR:0_'", ":", "1", ",", "'_STR:1_'", ":", "False", ",", "'filters'", ":", "{", "'require_debug_false'", ":", "{", "'()'", ":", "'django.utils.log.RequireDebugFalse'", ",", "}", ",", "'require_debug_true'", ":", "{", "'()'", ":", "'django.utils.log.RequireDebugTrue'", ",", "}", ",", "}", ",", "'handlers'", ":", "{", "'console'", ":", "{", "'level'", ":", "'INFO'", ",", "'filters'", ":", "[", "'require_debug_true'", "]", ",", "'class'", ":", "'logging.StreamHandler'", ",", "}", ",", "'null'", ":", "{", "'class'", ":", "'logging.NullHandler'", ",", "}", ",", "'mail_admins'", ":", "{", "'level'", ":", "'ERROR'", ",", "'filters'", ":", "[", "'require_debug_false'", "]", ",", "'class'", ":", "'django.utils.log.AdminEmailHandler'", "}", "}", ",", "'loggers'", ":", "{", "'django'", ":", "{", "'handlers'", ":", "[", "'console'", "]", ",", "}", ",", "'django.request'", ":", "{", "'handlers'", ":", "[", "'mail_admins'", "]", ",", "'level'", ":", "'ERROR'", ",", "'propagate'", ":", "False", ",", "}", ",", "'django.security'", ":", "{", "'handlers'", ":", "[", "'mail_admins'", "]", ",", "'level'", ":", "'ERROR'", ",", "'propagate'", ":", "False", ",", "}", ",", "'py.warnings'", ":", "{", "'handlers'", ":", "[", "'console'", "]", ",", "}", ",", "}", "}"], "type": ["NAME", "OP", "OP", "STRING", "OP", "NUMBER", "OP", "STRING", "OP", "NAME", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "OP", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "NAME", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "NAME", "OP", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "STRING", "OP", "OP", "OP", "OP", "OP", "OP"], "raw_code": "DEFAULT_LOGGING = {  'version' : 1 ,  'disable_existing_loggers' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }"}
{"src": ["and", "3", "additional", "pairs", "of", "dictionaries", "for", "string", ".", "define", "the", "function", "configure_logging", "with", "2", "arguments", ":", "logging_config", "and", "logging_settings", "."], "cano_code": "def configure_logging ( logging_config , logging_settings ) :pass", "decano_code": "def configure_logging ( logging_config , logging_settings ) :", "token": ["def", "configure_logging", "(", "logging_config", ",", "logging_settings", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def configure_logging ( logging_config , logging_settings ) :"}
{"src": ["if", "sys.warnoptions", "[", "sys", ".", "warnoptions", "]", "is", "false", ","], "cano_code": "if not sys . warnoptions :pass", "decano_code": "if not sys . warnoptions :", "token": ["if", "not", "sys", ".", "warnoptions", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if not sys . warnoptions :"}
{"src": ["call", "the", "method", "logging.captureWarnings", "[", "logging", ".", "captureWarnings", "]", "with", "an", "argument", "boolean", "True", "."], "cano_code": "logging . captureWarnings ( True )", "decano_code": "logging . captureWarnings ( True )", "token": ["logging", ".", "captureWarnings", "(", "True", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP"], "raw_code": "logging . captureWarnings ( True )"}
{"src": ["call", "the", "function", "warnings.simplefilter", "[", "warnings", ".", "simplefilter", "]", "with", "2", "arguments", ":", "string", "_STR:0_", "and", "RemovedInNextVersionWarning", "."], "cano_code": "warnings . simplefilter ( '_STR:0_' , RemovedInNextVersionWarning )", "decano_code": "warnings . simplefilter ( '_STR:0_' , RemovedInNextVersionWarning )", "token": ["warnings", ".", "simplefilter", "(", "\" _STR:0_ \"", ",", "RemovedInNextVersionWarning", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "warnings . simplefilter ( \"default\" , RemovedInNextVersionWarning )"}
{"src": ["if", "logging_config", "is", "true", ","], "cano_code": "if logging_config :pass", "decano_code": "if logging_config :", "token": ["if", "logging_config", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if logging_config :"}
{"src": ["call", "the", "function", "import_string", "with", "an", "argument", "logging_config", ",", "substitute", "the", "result", "for", "logging_config_func", "."], "cano_code": "logging_config_func = import_string ( logging_config )", "decano_code": "logging_config_func = import_string ( logging_config )", "token": ["logging_config_func", "=", "import_string", "(", "logging_config", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "logging_config_func = import_string ( logging_config )"}
{"src": ["call", "the", "function", "logging_config_func", "with", "an", "argument", "DEFAULT_LOGGING", "."], "cano_code": "logging_config_func ( DEFAULT_LOGGING )", "decano_code": "logging_config_func ( DEFAULT_LOGGING )", "token": ["logging_config_func", "(", "DEFAULT_LOGGING", ")"], "type": ["NAME", "OP", "NAME", "OP"], "raw_code": "logging_config_func ( DEFAULT_LOGGING )"}
{"src": ["if", "logging_settings", "is", "true", ","], "cano_code": "if logging_settings :pass", "decano_code": "if logging_settings :", "token": ["if", "logging_settings", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if logging_settings :"}
{"src": ["call", "the", "function", "logging_config_func", "with", "an", "argument", "logging_settings", "."], "cano_code": "logging_config_func ( logging_settings )", "decano_code": "logging_config_func ( logging_settings )", "token": ["logging_config_func", "(", "logging_settings", ")"], "type": ["NAME", "OP", "NAME", "OP"], "raw_code": "logging_config_func ( logging_settings )"}
{"src": ["derive", "the", "class", "AdminEmailHandler", "from", "logging.Handler", "[", "logging", ".", "Handler", "]", "base", "class", "."], "cano_code": "class AdminEmailHandler ( logging . Handler ) :pass", "decano_code": "class AdminEmailHandler ( logging . Handler ) :", "token": ["class", "AdminEmailHandler", "(", "logging", ".", "Handler", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "class AdminEmailHandler ( logging . Handler ) :"}
{"src": ["define", "the", "method", "__init__", "with", "3", "arguments", ":", "self", ",", "include_html", "set", "to", "boolean", "False", "and", "email_backend", "set", "to", "None", "."], "cano_code": "def __init__ ( self , include_html = False , email_backend = None ) :pass", "decano_code": "def __init__ ( self , include_html = False , email_backend = None ) :", "token": ["def", "__init__", "(", "self", ",", "include_html", "=", "False", ",", "email_backend", "=", "None", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def __init__ ( self , include_html = False , email_backend = None ) :"}
{"src": ["call", "the", "method", "logging.Handler.__init__", "[", "logging", ".", "Handler", ".", "__init__", "]", "with", "an", "argument", "self", "."], "cano_code": "logging . Handler . __init__ ( self )", "decano_code": "logging . Handler . __init__ ( self )", "token": ["logging", ".", "Handler", ".", "__init__", "(", "self", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "logging . Handler . __init__ ( self )"}
{"src": ["substitute", "include_html", "for", "self.include_html", "[", "self", ".", "include_html", "]", "."], "cano_code": "self . include_html = include_html", "decano_code": "self . include_html = include_html", "token": ["self", ".", "include_html", "=", "include_html"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . include_html = include_html"}
{"src": ["substitute", "email_backend", "for", "self.email_backend", "[", "self", ".", "email_backend", "]", "."], "cano_code": "self . email_backend = email_backend", "decano_code": "self . email_backend = email_backend", "token": ["self", ".", "email_backend", "=", "email_backend"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . email_backend = email_backend"}
{"src": ["define", "the", "method", "emit", "with", "2", "arguments", ":", "self", "and", "record", "."], "cano_code": "def emit ( self , record ) :pass", "decano_code": "def emit ( self , record ) :", "token": ["def", "emit", "(", "self", ",", "record", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def emit ( self , record ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["substitute", "record.request", "[", "record", ".", "request", "]", "for", "request", "."], "cano_code": "request = record . request", "decano_code": "request = record . request", "token": ["request", "=", "record", ".", "request"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "request = record . request"}
{"src": ["subject", "is", "an", "string", "_STR:0_", ",", "formated", "with", "record.levelname", "[", "record", ".", "levelname", "]", ",", "string", "_STR:1_", "if", "value", "under", "the", "_STR:2_", "key", ","], "cano_code": "subject = '_STR:0_' % (  record . levelname ,  ( '_STR:1_' if request . META . get ( '_STR:2_' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )", "decano_code": "subject = '_STR:0_' % (  record . levelname ,  ( '_STR:1_' if request . META . get ( '_STR:2_' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )", "token": ["subject", "=", "\" _STR:0_ \"", "%", "(", "record", ".", "levelname", ",", "(", "\" _STR:1_ \"", "if", "request", ".", "META", ".", "get", "(", "\" _STR:2_ \"", ")", "in", "settings", ".", "INTERNAL_IPS", "else", "\" EXTERNAL \"", ")", ",", "record", ".", "getMessage", "(", ")", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "STRING", "KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )"}
{"src": ["of", "the", "request.META", "[", "request", ".", "META", "]", "dictionary", "is", "contained", "in", "settings.INTERNAL_IPS", "[", "settings", ".", "INTERNAL_IPS", "]", ",", "otherwise", "use", "string", "_STR:0_", ",", "and", "result", "of", "the", "method", "record.getMessage", "[", "record", ".", "getMessage", "]", ".", "call", "the", "function", "get_exception_reporter_filter", "with", "an", "argument", "request", ",", "substitute", "the", "result", "for", "filter", "."], "cano_code": "filter = get_exception_reporter_filter ( request )", "decano_code": "filter = get_exception_reporter_filter ( request )", "token": ["filter", "=", "get_exception_reporter_filter", "(", "request", ")"], "type": ["KEYWORD", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "filter = get_exception_reporter_filter ( request )"}
{"src": ["call", "the", "method", "filter.get_request_repr", "[", "filter", ".", "get_request_repr", "]", "with", "an", "argument", "request", ",", "format", "string", "_STR:0_", "with", "the", "result", ",", "substitute", "the", "result", "for", "request_repr", "."], "cano_code": "request_repr = '_STR:0_' . format ( filter . get_request_repr ( request ) )", "decano_code": "request_repr = '_STR:0_' . format ( filter . get_request_repr ( request ) )", "token": ["request_repr", "=", "\" _STR:0_ \"", ".", "format", "(", "filter", ".", "get_request_repr", "(", "request", ")", ")"], "type": ["NAME", "OP", "STRING", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "request_repr = '\\n{0}' . format ( filter . get_request_repr ( request ) )"}
{"src": ["if", "Exception", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept Exception :pass", "decano_code": "except Exception :", "token": ["except", "Exception", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except Exception :"}
{"src": ["subject", "is", "an", "string", "_STR:0_", "formated", "with", "record.levelname", "[", "record", ".", "levelname", "]", "and", "result", "of", "the", "method", "record.getMessage", "[", "record", ".", "getMessage", "]", ",", "respectively", "."], "cano_code": "subject = '_STR:0_' % (  record . levelname ,  record . getMessage ( )  )", "decano_code": "subject = '_STR:0_' % (  record . levelname ,  record . getMessage ( )  )", "token": ["subject", "=", "\" _STR:0_ \"", "%", "(", "record", ".", "levelname", ",", "record", ".", "getMessage", "(", ")", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )"}
{"src": ["request", "is", "None", "."], "cano_code": "request = None", "decano_code": "request = None", "token": ["request", "=", "None"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "request = None"}
{"src": ["request_repr", "is", "a", "string", "_STR:0_", "."], "cano_code": "request_repr = '_STR:0_'", "decano_code": "request_repr = '_STR:0_'", "token": ["request_repr", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "request_repr = \"unavailable\""}
{"src": ["call", "the", "function", "self.format_subject", "[", "self", ".", "format_subject", "]", "with", "an", "argument", "subject", ",", "substitute", "the", "result", "for", "subject", "."], "cano_code": "subject = self . format_subject ( subject )", "decano_code": "subject = self . format_subject ( subject )", "token": ["subject", "=", "self", ".", "format_subject", "(", "subject", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "subject = self . format_subject ( subject )"}
{"src": ["if", "record.exc_info", "[", "record", ".", "exc_info", "]", "is", "true", ","], "cano_code": "if record . exc_info :pass", "decano_code": "if record . exc_info :", "token": ["if", "record", ".", "exc_info", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if record . exc_info :"}
{"src": ["substitute", "record.exc_info", "[", "record", ".", "exc_info", "]", "for", "exc_info", "."], "cano_code": "exc_info = record . exc_info", "decano_code": "exc_info = record . exc_info", "token": ["exc_info", "=", "record", ".", "exc_info"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "exc_info = record . exc_info"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["exc_info", "is", "an", "tuple", "with", "3", "elements", ":", "None", ",", "result", "of", "method", "record.getMessage", "[", "record", ".", "getMessage", "]", "and", "None", "."], "cano_code": "exc_info = ( None , record . getMessage ( ) , None )", "decano_code": "exc_info = ( None , record . getMessage ( ) , None )", "token": ["exc_info", "=", "(", "None", ",", "record", ".", "getMessage", "(", ")", ",", "None", ")"], "type": ["NAME", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "KEYWORD", "OP"], "raw_code": "exc_info = ( None , record . getMessage ( ) , None )"}
{"src": ["message", "is", "an", "string", "_STR:0_", "formated", "with", "the", "result", "of", "the", "metod", "self.format", "[", "self", ".", "format", "]", "with", "an", "argument", "record", ","], "cano_code": "message = '_STR:0_' % ( self . format ( record ) , request_repr )", "decano_code": "message = '_STR:0_' % ( self . format ( record ) , request_repr )", "token": ["message", "=", "\" _STR:0_ \"", "%", "(", "self", ".", "format", "(", "record", ")", ",", "request_repr", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "message = \"%s\\n\\nRequest repr(): %s\" % ( self . format ( record ) , request_repr )"}
{"src": ["and", "request_repr", ",", "respectively", ".", "reporter", "is", "an", "instance", "of", "ExceptionReporter", "class", ",", "created", "with", "3", "arguments", ":", "request", ",", "is_email", "as", "boolean", "True", ","], "cano_code": "reporter = ExceptionReporter ( request , is_email = True , * exc_info )", "decano_code": "reporter = ExceptionReporter ( request , is_email = True , * exc_info )", "token": ["reporter", "=", "ExceptionReporter", "(", "request", ",", "is_email", "=", "True", ",", "*", "exc_info", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "OP", "NAME", "OP"], "raw_code": "reporter = ExceptionReporter ( request , is_email = True , * exc_info )"}
{"src": ["unpacked", "list", "exc_info", ".", "if", "self.include_html", "[", "self", ".", "include_html", "]", "is", "true", ",", "call", "the", "method", "reporter.get_traceback_html", "[", "reporter", ".", "get_traceback_html", "]", "and", "substitute", "the", "result", "for", "html_message", ","], "cano_code": "html_message = reporter . get_traceback_html ( ) if self . include_html else None", "decano_code": "html_message = reporter . get_traceback_html ( ) if self . include_html else None", "token": ["html_message", "=", "reporter", ".", "get_traceback_html", "(", ")", "if", "self", ".", "include_html", "else", "None"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "KEYWORD"], "raw_code": "html_message = reporter . get_traceback_html ( ) if self . include_html else None"}
{"src": ["otherwise", "html_message", "is", "None", ".", "call", "the", "method", "mail.mail_admins", "[", "mail", ".", "mail_admins", "]", "with", "5", "arguments", ":", "subject", ",", "message", ",", "fail_silently", "as", "boolean", "True", ",", "tml_message", "as", "html_message", ","], "cano_code": "mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )", "decano_code": "mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )", "token": ["mail", ".", "mail_admins", "(", "subject", ",", "message", ",", "fail_silently", "=", "True", ",", "html_message", "=", "html_message", ",", "connection", "=", "self", ".", "connection", "(", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )"}
{"src": ["and", "connection", "as", "the", "result", "of", "the", "method", "self.connection", "[", "self", ".", "connection", "]", ".", "define", "the", "connection", "with", "an", "argument", "self", "."], "cano_code": "def connection ( self ) :pass", "decano_code": "def connection ( self ) :", "token": ["def", "connection", "(", "self", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def connection ( self ) :"}
{"src": ["call", "the", "function", "get_connection", "with", "2", "arguments", ":", "backend", "set", "to", "self.email_backend", "[", "self", ".", "email_backend", "]", "and", "fail_silently", "set", "to", "boolean", "True", "."], "cano_code": "return get_connection ( backend = self . email_backend , fail_silently = True )", "decano_code": "return get_connection ( backend = self . email_backend , fail_silently = True )", "token": ["return", "get_connection", "(", "backend", "=", "self", ".", "email_backend", ",", "fail_silently", "=", "True", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP"], "raw_code": "return get_connection ( backend = self . email_backend , fail_silently = True )"}
{"src": ["define", "the", "method", "format_subject", "with", "2", "arguments", ":", "self", "and", "subject", "."], "cano_code": "def format_subject ( self , subject ) :pass", "decano_code": "def format_subject ( self , subject ) :", "token": ["def", "format_subject", "(", "self", ",", "subject", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def format_subject ( self , subject ) :"}
{"src": ["replace", "every", "occurrence", "of", "_STR:0_", "in", "subject", "with", "_STR:1_", "and", "replace", "every", "occurrence", "of", "_STR:2_", "in", "subject", "with", "_STR:3_", ","], "cano_code": "formatted_subject = subject . replace ( '_STR:0_' , '_STR:1_' ) . replace ( '_STR:2_' , '_STR:3_' )", "decano_code": "formatted_subject = subject . replace ( '_STR:0_' , '_STR:1_' ) . replace ( '_STR:2_' , '_STR:3_' )", "token": ["formatted_subject", "=", "subject", ".", "replace", "(", "\" _STR:0_ \"", ",", "\" _STR:1_ \"", ")", ".", "replace", "(", "\" _STR:2_ \"", ",", "\" _STR:3_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP", "OP", "NAME", "OP", "STRING", "OP", "STRING", "OP"], "raw_code": "formatted_subject = subject . replace ( '\\n' , '\\\\n' ) . replace ( '\\r' , '\\\\r' )"}
{"src": ["substitute", "the", "result", "for", "formatted_subject", ".", "return", "first", "989", "elements", "of", "formatted_subject", "."], "cano_code": "return formatted_subject [ : 989 ]", "decano_code": "return formatted_subject [ : 989 ]", "token": ["return", "formatted_subject", "[", ":", "989", "]"], "type": ["KEYWORD", "NAME", "OP", "OP", "NUMBER", "OP"], "raw_code": "return formatted_subject [ : 989 ]"}
{"src": ["derive", "the", "class", "CallbackFilter", "from", "logging.Filter", "[", "logging", ".", "Filter", "]", "base", "class", "."], "cano_code": "class CallbackFilter ( logging . Filter ) :pass", "decano_code": "class CallbackFilter ( logging . Filter ) :", "token": ["class", "CallbackFilter", "(", "logging", ".", "Filter", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "class CallbackFilter ( logging . Filter ) :"}
{"src": ["define", "the", "method", "__init__", "with", "2", "arguments", ":", "self", "and", "callback", "."], "cano_code": "def __init__ ( self , callback ) :pass", "decano_code": "def __init__ ( self , callback ) :", "token": ["def", "__init__", "(", "self", ",", "callback", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def __init__ ( self , callback ) :"}
{"src": ["substitute", "callback", "for", "self.callback", "[", "self", ".", "callback", "]", "."], "cano_code": "self . callback = callback", "decano_code": "self . callback = callback", "token": ["self", ".", "callback", "=", "callback"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "self . callback = callback"}
{"src": ["define", "the", "method", "filter", "with", "2", "arguments", ":", "self", "and", "record", "."], "cano_code": "def filter ( self , record ) :pass", "decano_code": "def filter ( self , record ) :", "token": ["def", "filter", "(", "self", ",", "record", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def filter ( self , record ) :"}
{"src": ["call", "the", "method", "self.callback", "[", "self", ".", "callback", "]", "with", "an", "argument", "record", ",", "if", "the", "result", "evaluates", "to", "true", ","], "cano_code": "if self . callback ( record ) :pass", "decano_code": "if self . callback ( record ) :", "token": ["if", "self", ".", "callback", "(", "record", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if self . callback ( record ) :"}
{"src": ["return", "integer", "1", "."], "cano_code": "return 1", "decano_code": "return 1", "token": ["return", "1"], "type": ["KEYWORD", "NUMBER"], "raw_code": "return 1"}
{"src": ["return", "integer", "0", "."], "cano_code": "return 0", "decano_code": "return 0", "token": ["return", "0"], "type": ["KEYWORD", "NUMBER"], "raw_code": "return 0"}
{"src": ["derive", "the", "class", "RequireDebugFalse", "from", "logging.Filter", "[", "logging", ".", "Filter", "]", "base", "class", "."], "cano_code": "class RequireDebugFalse ( logging . Filter ) :pass", "decano_code": "class RequireDebugFalse ( logging . Filter ) :", "token": ["class", "RequireDebugFalse", "(", "logging", ".", "Filter", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "class RequireDebugFalse ( logging . Filter ) :"}
{"src": ["define", "the", "method", "filter", "with", "2", "arguments", ":", "self", "and", "record", "."], "cano_code": "def filter ( self , record ) :pass", "decano_code": "def filter ( self , record ) :", "token": ["def", "filter", "(", "self", ",", "record", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def filter ( self , record ) :"}
{"src": ["if", "settings.DEBUG", "[", "settings", ".", "DEBUG", "]", "is", "true", ",", "return", "boolean", "False", ",", "otherwise", "return", "boolean", "True", "."], "cano_code": "return not settings . DEBUG", "decano_code": "return not settings . DEBUG", "token": ["return", "not", "settings", ".", "DEBUG"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP", "NAME"], "raw_code": "return not settings . DEBUG"}
{"src": ["derive", "the", "class", "RequireDebugTrue", "from", "logging.Filter", "[", "logging", ".", "Filter", "]", "base", "class", "."], "cano_code": "class RequireDebugTrue ( logging . Filter ) :pass", "decano_code": "class RequireDebugTrue ( logging . Filter ) :", "token": ["class", "RequireDebugTrue", "(", "logging", ".", "Filter", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "class RequireDebugTrue ( logging . Filter ) :"}
{"src": ["define", "the", "method", "filter", "with", "2", "arguments", ":", "self", "and", "record", "."], "cano_code": "def filter ( self , record ) :pass", "decano_code": "def filter ( self , record ) :", "token": ["def", "filter", "(", "self", ",", "record", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def filter ( self , record ) :"}
{"src": ["return", "settings.DEBUG", "[", "settings", ".", "DEBUG", "]", "."], "cano_code": "return settings . DEBUG", "decano_code": "return settings . DEBUG", "token": ["return", "settings", ".", "DEBUG"], "type": ["KEYWORD", "NAME", "OP", "NAME"], "raw_code": "return settings . DEBUG"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["from", "functools", "import", "lru_cache", "."], "cano_code": "from functools import lru_cache", "decano_code": "from functools import lru_cache", "token": ["from", "functools", "import", "lru_cache"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from functools import lru_cache"}
{"src": ["if", "ImportError", "exception", "is", "caught", "."], "cano_code": "try: pass\nexcept ImportError :pass", "decano_code": "except ImportError :", "token": ["except", "ImportError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ImportError :"}
{"src": ["from", "collections", "import", "namedtuple", "."], "cano_code": "from collections import namedtuple", "decano_code": "from collections import namedtuple", "token": ["from", "collections", "import", "namedtuple"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from collections import namedtuple"}
{"src": ["from", "functools", "import", "update_wrapper", "."], "cano_code": "from functools import update_wrapper", "decano_code": "from functools import update_wrapper", "token": ["from", "functools", "import", "update_wrapper"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from functools import update_wrapper"}
{"src": ["from", "threading", "import", "RLock", "."], "cano_code": "from threading import RLock", "decano_code": "from threading import RLock", "token": ["from", "threading", "import", "RLock"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from threading import RLock"}
{"src": ["_CacheInfo", "is", "an", "instance", "of", "namedtuple", "class", "created", "with", "2", "arguments", ":", "string", "_STR:0_", "and", "a", "list", "with", "4", "elements", ":", "string", "_STR:1_", ","], "cano_code": "_CacheInfo = namedtuple ( '_STR:0_' , [ \"hits\" , \"misses\" , \"maxsize\" , \"currsize\" ] )", "decano_code": "_CacheInfo = namedtuple ( '_STR:0_' , [ \"hits\" , \"misses\" , \"maxsize\" , \"currsize\" ] )", "token": ["_CacheInfo", "=", "namedtuple", "(", "\" _STR:0_ \"", ",", "[", "\" hits \"", ",", "\" misses \"", ",", "\" maxsize \"", ",", "\" currsize \"", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "OP"], "raw_code": "_CacheInfo = namedtuple ( \"CacheInfo\" , [ \"hits\" , \"misses\" , \"maxsize\" , \"currsize\" ] )"}
{"src": ["_STR:0_", ",", "_STR:1_", "and", "_STR:2_", ".", "derive", "class", "_HashedSeq", "from", "list", "base", "class", "."], "cano_code": "class _HashedSeq ( list ) :pass", "decano_code": "class _HashedSeq ( list ) :", "token": ["class", "_HashedSeq", "(", "list", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "class _HashedSeq ( list ) :"}
{"src": ["__slots__", "is", "a", "string", "_STR:0_", "."], "cano_code": "__slots__ = '_STR:0_'", "decano_code": "__slots__ = '_STR:0_'", "token": ["__slots__", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "__slots__ = 'hashvalue'"}
{"src": ["define", "the", "method", "__init__", "with", "3", "arguments", ":", "self", ",", "tup", "and", "hash", "set", "to", "hash", "."], "cano_code": "def __init__ ( self , tup , hash = hash ) :pass", "decano_code": "def __init__ ( self , tup , hash = hash ) :", "token": ["def", "__init__", "(", "self", ",", "tup", ",", "hash", "=", "hash", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def __init__ ( self , tup , hash = hash ) :"}
{"src": ["substitute", "tup", "for", "elements", "of", "self", "."], "cano_code": "self [ : ] = tup", "decano_code": "self [ : ] = tup", "token": ["self", "[", ":", "]", "=", "tup"], "type": ["NAME", "OP", "OP", "OP", "OP", "NAME"], "raw_code": "self [ : ] = tup"}
{"src": ["get", "the", "hash", "value", "of", "the", "tup", ",", "substitute", "it", "for", "self.hashvalue", "[", "self", ".", "hashvalue", "]", "."], "cano_code": "self . hashvalue = hash ( tup )", "decano_code": "self . hashvalue = hash ( tup )", "token": ["self", ".", "hashvalue", "=", "hash", "(", "tup", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "self . hashvalue = hash ( tup )"}
{"src": ["define", "the", "method", "__hash__", "with", "an", "argument", "self", "."], "cano_code": "def __hash__ ( self ) :pass", "decano_code": "def __hash__ ( self ) :", "token": ["def", "__hash__", "(", "self", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def __hash__ ( self ) :"}
{"src": ["return", "self.hashvalue", "[", "self", ".", "hashvalue", "]", "."], "cano_code": "return self . hashvalue", "decano_code": "return self . hashvalue", "token": ["return", "self", ".", "hashvalue"], "type": ["KEYWORD", "NAME", "OP", "NAME"], "raw_code": "return self . hashvalue"}
{"src": ["define", "the", "function", "_make_key", "with", "9", "arguments", ":", "args", ",", "kwds", ",", "typed", ",", "kwd_mark", "as", "a", "tuple", "with", "an", "element", "result", "of", "the", "function", "object", ","], "cano_code": "def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :pass", "decano_code": "def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :", "token": ["def", "_make_key", "(", "args", ",", "kwds", ",", "typed", ",", "kwd_mark", "=", "(", "object", "(", ")", ",", ")", ",", "fasttypes", "=", "{", "int", ",", "str", ",", "frozenset", ",", "type", "(", "None", ")", "}", ",", "sorted", "=", "sorted", ",", "tuple", "=", "tuple", ",", "type", "=", "type", ",", "len", "=", "len", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "OP", "OP", "OP", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "OP", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :"}
{"src": ["substitute", "args", "for", "key", "."], "cano_code": "key = args", "decano_code": "key = args", "token": ["key", "=", "args"], "type": ["NAME", "OP", "NAME"], "raw_code": "key = args"}
{"src": ["if", "kwds", "is", "true", ","], "cano_code": "if kwds :pass", "decano_code": "if kwds :", "token": ["if", "kwds", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if kwds :"}
{"src": ["sort", "elements", "of", "kwds", ",", "substitute", "the", "result", "for", "sorted_items", "."], "cano_code": "sorted_items = sorted ( kwds . items ( ) )", "decano_code": "sorted_items = sorted ( kwds . items ( ) )", "token": ["sorted_items", "=", "sorted", "(", "kwds", ".", "items", "(", ")", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "sorted_items = sorted ( kwds . items ( ) )"}
{"src": ["increment", "key", "by", "kwd_mark", "."], "cano_code": "key += kwd_mark", "decano_code": "key += kwd_mark", "token": ["key", "+=", "kwd_mark"], "type": ["NAME", "OP", "NAME"], "raw_code": "key += kwd_mark"}
{"src": ["for", "every", "item", "in", "sorted_items", ","], "cano_code": "for item in sorted_items :pass", "decano_code": "for item in sorted_items :", "token": ["for", "item", "in", "sorted_items", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for item in sorted_items :"}
{"src": ["increment", "key", "by", "item", "."], "cano_code": "key += item", "decano_code": "key += item", "token": ["key", "+=", "item"], "type": ["NAME", "OP", "NAME"], "raw_code": "key += item"}
{"src": ["if", "typed", "is", "true", ","], "cano_code": "if typed :pass", "decano_code": "if typed :", "token": ["if", "typed", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if typed :"}
{"src": ["create", "a", "tuple", "out", "of", "types", "of", "v", ",", "for", "every", "v", "in", "args", ",", "extend", "key", "tuple", "with", "the", "result", "."], "cano_code": "key += tuple ( type ( v ) for v in args )", "decano_code": "key += tuple ( type ( v ) for v in args )", "token": ["key", "+=", "tuple", "(", "type", "(", "v", ")", "for", "v", "in", "args", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "NAME", "OP", "KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "key += tuple ( type ( v ) for v in args )"}
{"src": ["if", "kwds", "is", "true", ","], "cano_code": "if kwds :pass", "decano_code": "if kwds :", "token": ["if", "kwds", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if kwds :"}
{"src": ["create", "a", "tuple", "out", "of", "types", "of", "v", ",", "for", "every", "k", "and", "v", "in", "sorted_items", ",", "extend", "key", "tuple", "with", "the", "result", "."], "cano_code": "key += tuple ( type ( v ) for k , v in sorted_items )", "decano_code": "key += tuple ( type ( v ) for k , v in sorted_items )", "token": ["key", "+=", "tuple", "(", "type", "(", "v", ")", "for", "k", ",", "v", "in", "sorted_items", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP", "NAME", "OP", "KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "key += tuple ( type ( v ) for k , v in sorted_items )"}
{"src": ["otherwise", "if", "length", "of", "key", "equals", "integer", "1", "and", "type", "of", "first", "element", "of", "key", "is", "contained", "in", "fasttypes", ","], "cano_code": "if True: pass\nelif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :pass", "decano_code": "elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :", "token": ["elif", "len", "(", "key", ")", "==", "1", "and", "type", "(", "key", "[", "0", "]", ")", "in", "fasttypes", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "KEYWORD", "NAME", "OP"], "raw_code": "elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :"}
{"src": ["return", "first", "element", "of", "key", "."], "cano_code": "return key [ 0 ]", "decano_code": "return key [ 0 ]", "token": ["return", "key", "[", "0", "]"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "return key [ 0 ]"}
{"src": ["return", "instance", "of", "_HashedSeq", "class", ",", "created", "with", "an", "argument", "key", "."], "cano_code": "return _HashedSeq ( key )", "decano_code": "return _HashedSeq ( key )", "token": ["return", "_HashedSeq", "(", "key", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "return _HashedSeq ( key )"}
{"src": ["define", "the", "function", "lru_cache", "with", "2", "arguments", "maxsize", "set", "to", "integer", "100", "and", "typed", "set", "to", "boolean", "False", "."], "cano_code": "def lru_cache ( maxsize = 100 , typed = False ) :pass", "decano_code": "def lru_cache ( maxsize = 100 , typed = False ) :", "token": ["def", "lru_cache", "(", "maxsize", "=", "100", ",", "typed", "=", "False", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def lru_cache ( maxsize = 100 , typed = False ) :"}
{"src": ["define", "the", "function", "decorating_function", "with", "an", "argument", "user_function", "."], "cano_code": "def decorating_function ( user_function ) :pass", "decano_code": "def decorating_function ( user_function ) :", "token": ["def", "decorating_function", "(", "user_function", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def decorating_function ( user_function ) :"}
{"src": ["cache", "is", "an", "empty", "dictionary", "."], "cano_code": "cache = dict ( )", "decano_code": "cache = dict ( )", "token": ["cache", "=", "dict", "(", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "cache = dict ( )"}
{"src": ["stats", "is", "an", "list", "with", "2", "elements", ":", "2", "integers", "0", "."], "cano_code": "stats = [ 0 , 0 ]", "decano_code": "stats = [ 0 , 0 ]", "token": ["stats", "=", "[", "0", ",", "0", "]"], "type": ["NAME", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP"], "raw_code": "stats = [ 0 , 0 ]"}
{"src": ["HITS", "and", "MISSES", "are", "integer", "0", "and", "1", ",", "respectively", "."], "cano_code": "HITS , MISSES = 0 , 1", "decano_code": "HITS , MISSES = 0 , 1", "token": ["HITS", ",", "MISSES", "=", "0", ",", "1"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER", "OP", "NUMBER"], "raw_code": "HITS , MISSES = 0 , 1"}
{"src": ["substitute", "_make_key", "for", "make_key", "."], "cano_code": "make_key = _make_key", "decano_code": "make_key = _make_key", "token": ["make_key", "=", "_make_key"], "type": ["NAME", "OP", "NAME"], "raw_code": "make_key = _make_key"}
{"src": ["substitute", "cache.get", "[", "cache", ".", "get", "]", "for", "cache_get", "."], "cano_code": "cache_get = cache . get", "decano_code": "cache_get = cache . get", "token": ["cache_get", "=", "cache", ".", "get"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "cache_get = cache . get"}
{"src": ["substitute", "len", "for", "_len", "."], "cano_code": "_len = len", "decano_code": "_len = len", "token": ["_len", "=", "len"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "_len = len"}
{"src": ["lock", "is", "an", "instance", "of", "RLock", "class", "."], "cano_code": "lock = RLock ( )", "decano_code": "lock = RLock ( )", "token": ["lock", "=", "RLock", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP"], "raw_code": "lock = RLock ( )"}
{"src": ["root", "is", "an", "empty", "list", "."], "cano_code": "root = [ ]", "decano_code": "root = [ ]", "token": ["root", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "root = [ ]"}
{"src": ["root", "is", "a", "list", "with", "elements", ":", "root", ",", "root", ",", "None", "and", "None", "."], "cano_code": "root [ : ] = [ root , root , None , None ]", "decano_code": "root [ : ] = [ root , root , None , None ]", "token": ["root", "[", ":", "]", "=", "[", "root", ",", "root", ",", "None", ",", "None", "]"], "type": ["NAME", "OP", "OP", "OP", "OP", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP"], "raw_code": "root [ : ] = [ root , root , None , None ]"}
{"src": ["nonlocal_root", "is", "an", "list", "with", "an", "element", "root", "."], "cano_code": "nonlocal_root = [ root ]", "decano_code": "nonlocal_root = [ root ]", "token": ["nonlocal_root", "=", "[", "root", "]"], "type": ["NAME", "OP", "OP", "NAME", "OP"], "raw_code": "nonlocal_root = [ root ]"}
{"src": ["substitute", "integers", "0", ",", "1", ",", "2", "and", "3", "for", "PREV", ",", "NEXT", ",", "KEY", "and", "RESULT", ",", "respectivley", "."], "cano_code": "PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3", "decano_code": "PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3", "token": ["PREV", ",", "NEXT", ",", "KEY", ",", "RESULT", "=", "0", ",", "1", ",", "2", ",", "3"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP", "NUMBER", "OP", "NUMBER", "OP", "NUMBER"], "raw_code": "PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3"}
{"src": ["if", "maxsize", "equals", "integer", "0", ","], "cano_code": "if maxsize == 0 :pass", "decano_code": "if maxsize == 0 :", "token": ["if", "maxsize", "==", "0", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if maxsize == 0 :"}
{"src": ["define", "the", "function", "wrapper", "with", "2", "arguments", ":", "unpacked", "list", "args", "and", "unpacked", "dictionary", "kwds", "."], "cano_code": "def wrapper ( * args , ** kwds ) :pass", "decano_code": "def wrapper ( * args , ** kwds ) :", "token": ["def", "wrapper", "(", "*", "args", ",", "**", "kwds", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "def wrapper ( * args , ** kwds ) :"}
{"src": ["call", "the", "function", "user_function", "with", "2", "arguments", ":", "unpacked", "list", "args", "and", "unpacked", "dictionary", "kwds", ",", "substitute", "the", "result", "for", "result", "."], "cano_code": "result = user_function ( * args , ** kwds )", "decano_code": "result = user_function ( * args , ** kwds )", "token": ["result", "=", "user_function", "(", "*", "args", ",", "**", "kwds", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "result = user_function ( * args , ** kwds )"}
{"src": ["increment", "stats", "dictionary", "value", "under", "the", "MISSES", "key", "by", "integer", "1", "."], "cano_code": "stats [ MISSES ] += 1", "decano_code": "stats [ MISSES ] += 1", "token": ["stats", "[", "MISSES", "]", "+=", "1"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NUMBER"], "raw_code": "stats [ MISSES ] += 1"}
{"src": ["return", "result", "."], "cano_code": "return result", "decano_code": "return result", "token": ["return", "result"], "type": ["KEYWORD", "NAME"], "raw_code": "return result"}
{"src": ["otherwise", "if", "maxsize", "is", "None", ","], "cano_code": "if True: pass\nelif maxsize is None :pass", "decano_code": "elif maxsize is None :", "token": ["elif", "maxsize", "is", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP"], "raw_code": "elif maxsize is None :"}
{"src": ["define", "the", "function", "wrapper", "with", "2", "arguments", ":", "unpacked", "list", "args", "and", "unpacked", "dictionary", "kwds", "."], "cano_code": "def wrapper ( * args , ** kwds ) :pass", "decano_code": "def wrapper ( * args , ** kwds ) :", "token": ["def", "wrapper", "(", "*", "args", ",", "**", "kwds", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "def wrapper ( * args , ** kwds ) :"}
{"src": ["call", "the", "function", "make_key", "with", "3", "arguments", ":", "args", ",", "kwds", "and", "typed", ",", "substitute", "the", "result", "for", "key", "."], "cano_code": "key = make_key ( args , kwds , typed )", "decano_code": "key = make_key ( args , kwds , typed )", "token": ["key", "=", "make_key", "(", "args", ",", "kwds", ",", "typed", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "key = make_key ( args , kwds , typed )"}
{"src": ["call", "the", "function", "cache_get", "with", "2", "arguments", ":", "key", "and", "root", ",", "substitute", "the", "result", "for", "result", "."], "cano_code": "result = cache_get ( key , root )", "decano_code": "result = cache_get ( key , root )", "token": ["result", "=", "cache_get", "(", "key", ",", "root", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "result = cache_get ( key , root )"}
{"src": ["if", "result", "is", "not", "root", ","], "cano_code": "if result is not root :pass", "decano_code": "if result is not root :", "token": ["if", "result", "is", "not", "root", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if result is not root :"}
{"src": ["increment", "stats", "dictionary", "value", "under", "the", "HITS", "key", "by", "integer", "1", "."], "cano_code": "stats [ HITS ] += 1", "decano_code": "stats [ HITS ] += 1", "token": ["stats", "[", "HITS", "]", "+=", "1"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NUMBER"], "raw_code": "stats [ HITS ] += 1"}
{"src": ["return", "result", "."], "cano_code": "return result", "decano_code": "return result", "token": ["return", "result"], "type": ["KEYWORD", "NAME"], "raw_code": "return result"}
{"src": ["call", "the", "function", "user_function", "with", "2", "arguments", "unpacked", "list", "args", "and", "unpacked", "dictionary", "kwds", ",", "substitute", "the", "result", "for", "result", "."], "cano_code": "result = user_function ( * args , ** kwds )", "decano_code": "result = user_function ( * args , ** kwds )", "token": ["result", "=", "user_function", "(", "*", "args", ",", "**", "kwds", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "result = user_function ( * args , ** kwds )"}
{"src": ["substitute", "result", "for", "cache", "dictionary", "value", "under", "the", "key", "key", "."], "cano_code": "cache [ key ] = result", "decano_code": "cache [ key ] = result", "token": ["cache", "[", "key", "]", "=", "result"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "cache [ key ] = result"}
{"src": ["increment", "stats", "dictionary", "value", "under", "the", "MISSES", "key", "by", "integer", "1", "."], "cano_code": "stats [ MISSES ] += 1", "decano_code": "stats [ MISSES ] += 1", "token": ["stats", "[", "MISSES", "]", "+=", "1"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NUMBER"], "raw_code": "stats [ MISSES ] += 1"}
{"src": ["return", "result", "."], "cano_code": "return result", "decano_code": "return result", "token": ["return", "result"], "type": ["KEYWORD", "NAME"], "raw_code": "return result"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["define", "the", "function", "wrapper", "with", "2", "arguments", ":", "unpacked", "list", "args", "and", "unpacked", "dictionary", "kwds", "."], "cano_code": "def wrapper ( * args , ** kwds ) :pass", "decano_code": "def wrapper ( * args , ** kwds ) :", "token": ["def", "wrapper", "(", "*", "args", ",", "**", "kwds", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "def wrapper ( * args , ** kwds ) :"}
{"src": ["if", "kwds", "is", "true", "or", "typed", "is", "true", ",", "call", "the", "function", "make_key", "with", "3", "arguments", ":", "args", ",", "kwds", "and", "typed", ",", "substitute", "the", "result", "for", "key", ","], "cano_code": "key = make_key ( args , kwds , typed ) if kwds or typed else args", "decano_code": "key = make_key ( args , kwds , typed ) if kwds or typed else args", "token": ["key", "=", "make_key", "(", "args", ",", "kwds", ",", "typed", ")", "if", "kwds", "or", "typed", "else", "args"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "NAME", "KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "key = make_key ( args , kwds , typed ) if kwds or typed else args"}
{"src": ["otherwise", "substitute", "args", "for", "key", ".", "with", "lock", ","], "cano_code": "with lock :pass", "decano_code": "with lock :", "token": ["with", "lock", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "with lock :"}
{"src": ["call", "the", "function", "cache_get", "with", "an", "argument", "key", ",", "substitute", "the", "result", "for", "link", "."], "cano_code": "link = cache_get ( key )", "decano_code": "link = cache_get ( key )", "token": ["link", "=", "cache_get", "(", "key", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "link = cache_get ( key )"}
{"src": ["if", "link", "is", "not", "None", ","], "cano_code": "if link is not None :pass", "decano_code": "if link is not None :", "token": ["if", "link", "is", "not", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if link is not None :"}
{"src": ["substitute", "nonlocal_root", "for", "a", "tuple", "with", "an", "element", "root", "."], "cano_code": "root , = nonlocal_root", "decano_code": "root , = nonlocal_root", "token": ["root", ",", "=", "nonlocal_root"], "type": ["NAME", "OP", "OP", "NAME"], "raw_code": "root , = nonlocal_root"}
{"src": ["substitute", "link", "for", "link_prev", ",", "link_next", ",", "key", "and", "result", ",", "respectively", "."], "cano_code": "link_prev , link_next , key , result = link", "decano_code": "link_prev , link_next , key , result = link", "token": ["link_prev", ",", "link_next", ",", "key", ",", "result", "=", "link"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "link_prev , link_next , key , result = link"}
{"src": ["substitute", "link_next", "for", "value", "under", "the", "NEXT", "key", "of", "the", "link_prev", "dictionary", "."], "cano_code": "link_prev [ NEXT ] = link_next", "decano_code": "link_prev [ NEXT ] = link_next", "token": ["link_prev", "[", "NEXT", "]", "=", "link_next"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "link_prev [ NEXT ] = link_next"}
{"src": ["substitute", "link_prev", "for", "value", "under", "the", "PREV", "key", "of", "the", "link_next", "dictionary", "."], "cano_code": "link_next [ PREV ] = link_prev", "decano_code": "link_next [ PREV ] = link_prev", "token": ["link_next", "[", "PREV", "]", "=", "link_prev"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "link_next [ PREV ] = link_prev"}
{"src": ["substitute", "value", "under", "the", "PREV", "key", "of", "the", "root", "dictionary", "for", "last", "."], "cano_code": "last = root [ PREV ]", "decano_code": "last = root [ PREV ]", "token": ["last", "=", "root", "[", "PREV", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "last = root [ PREV ]"}
{"src": ["substitute", "link", "for", "values", "under", "the", "NEXT", "key", "of", "the", "last", "dictionary", "and", "PREV", "key", "of", "the", "root", "dictionary", "."], "cano_code": "last [ NEXT ] = root [ PREV ] = link", "decano_code": "last [ NEXT ] = root [ PREV ] = link", "token": ["last", "[", "NEXT", "]", "=", "root", "[", "PREV", "]", "=", "link"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "last [ NEXT ] = root [ PREV ] = link"}
{"src": ["substitute", "last", "for", "value", "under", "the", "PREV", "key", "of", "the", "link", "dictionary", "."], "cano_code": "link [ PREV ] = last", "decano_code": "link [ PREV ] = last", "token": ["link", "[", "PREV", "]", "=", "last"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "link [ PREV ] = last"}
{"src": ["substitute", "root", "for", "value", "under", "the", "NEXT", "key", "of", "the", "link", "dictionary", "."], "cano_code": "link [ NEXT ] = root", "decano_code": "link [ NEXT ] = root", "token": ["link", "[", "NEXT", "]", "=", "root"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "link [ NEXT ] = root"}
{"src": ["increment", "stats", "dictionary", "value", "under", "the", "HITS", "key", "by", "integer", "1", "."], "cano_code": "stats [ HITS ] += 1", "decano_code": "stats [ HITS ] += 1", "token": ["stats", "[", "HITS", "]", "+=", "1"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NUMBER"], "raw_code": "stats [ HITS ] += 1"}
{"src": ["return", "result", "."], "cano_code": "return result", "decano_code": "return result", "token": ["return", "result"], "type": ["KEYWORD", "NAME"], "raw_code": "return result"}
{"src": ["call", "the", "function", "user_function", "with", "2", "arguments", ":", "unpacked", "list", "args", "and", "unpacked", "dictionary", "kwds", ",", "substitute", "the", "result", "for", "result", "."], "cano_code": "result = user_function ( * args , ** kwds )", "decano_code": "result = user_function ( * args , ** kwds )", "token": ["result", "=", "user_function", "(", "*", "args", ",", "**", "kwds", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "result = user_function ( * args , ** kwds )"}
{"src": ["with", "lock", ","], "cano_code": "with lock :pass", "decano_code": "with lock :", "token": ["with", "lock", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "with lock :"}
{"src": ["substitute", "nonlocal_root", "for", "tuple", "root", "."], "cano_code": "root , = nonlocal_root", "decano_code": "root , = nonlocal_root", "token": ["root", ",", "=", "nonlocal_root"], "type": ["NAME", "OP", "OP", "NAME"], "raw_code": "root , = nonlocal_root"}
{"src": ["if", "key", "is", "contained", "in", "cache", ","], "cano_code": "if key in cache :pass", "decano_code": "if key in cache :", "token": ["if", "key", "in", "cache", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "if key in cache :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["otherwise", "if", "result", "of", "the", "call", "to", "the", "function", "_len", "with", "an", "argument", "cache", "is", "greater", "than", "or", "equal", "to", "maxsize", ","], "cano_code": "if True: pass\nelif _len ( cache ) >= maxsize :pass", "decano_code": "elif _len ( cache ) >= maxsize :", "token": ["elif", "_len", "(", "cache", ")", ">=", "maxsize", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "elif _len ( cache ) >= maxsize :"}
{"src": ["substitute", "root", "for", "oldroot", "."], "cano_code": "oldroot = root", "decano_code": "oldroot = root", "token": ["oldroot", "=", "root"], "type": ["NAME", "OP", "NAME"], "raw_code": "oldroot = root"}
{"src": ["substitute", "key", "for", "value", "under", "the", "KEY", "key", "of", "the", "oldroot", "dictionary", "."], "cano_code": "oldroot [ KEY ] = key", "decano_code": "oldroot [ KEY ] = key", "token": ["oldroot", "[", "KEY", "]", "=", "key"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "oldroot [ KEY ] = key"}
{"src": ["substitute", "result", "for", "value", "under", "the", "RESULT", "key", "of", "the", "oldroot", "dictionary", "."], "cano_code": "oldroot [ RESULT ] = result", "decano_code": "oldroot [ RESULT ] = result", "token": ["oldroot", "[", "RESULT", "]", "=", "result"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "oldroot [ RESULT ] = result"}
{"src": ["substitute", "value", "under", "the", "NEXT", "key", "of", "the", "oldroot", "dictionary", "for", "root", "and", "first", "element", "of", "nonlocal_root", "."], "cano_code": "root = nonlocal_root [ 0 ] = oldroot [ NEXT ]", "decano_code": "root = nonlocal_root [ 0 ] = oldroot [ NEXT ]", "token": ["root", "=", "nonlocal_root", "[", "0", "]", "=", "oldroot", "[", "NEXT", "]"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "root = nonlocal_root [ 0 ] = oldroot [ NEXT ]"}
{"src": ["substitute", "value", "under", "the", "KEY", "key", "of", "the", "root", "dictionary", "for", "oldkey", "."], "cano_code": "oldkey = root [ KEY ]", "decano_code": "oldkey = root [ KEY ]", "token": ["oldkey", "=", "root", "[", "KEY", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "oldkey = root [ KEY ]"}
{"src": ["substitute", "value", "under", "the", "RESULT", "key", "of", "the", "root", "dictionary", "for", "oldvalue", "."], "cano_code": "oldvalue = root [ RESULT ]", "decano_code": "oldvalue = root [ RESULT ]", "token": ["oldvalue", "=", "root", "[", "RESULT", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "oldvalue = root [ RESULT ]"}
{"src": ["root", "dictionary", "values", "under", "the", "KEY", "and", "RESULT", "keys", "are", "both", "None", "."], "cano_code": "root [ KEY ] = root [ RESULT ] = None", "decano_code": "root [ KEY ] = root [ RESULT ] = None", "token": ["root", "[", "KEY", "]", "=", "root", "[", "RESULT", "]", "=", "None"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "KEYWORD"], "raw_code": "root [ KEY ] = root [ RESULT ] = None"}
{"src": ["delete", "entry", "under", "the", "oldkey", "key", "of", "the", "cache", "dictionary", "."], "cano_code": "del cache [ oldkey ]", "decano_code": "del cache [ oldkey ]", "token": ["del", "cache", "[", "oldkey", "]"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "del cache [ oldkey ]"}
{"src": ["substitute", "oldroot", "for", "value", "under", "the", "key", "key", "of", "the", "cache", "dictionary", "."], "cano_code": "cache [ key ] = oldroot", "decano_code": "cache [ key ] = oldroot", "token": ["cache", "[", "key", "]", "=", "oldroot"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "cache [ key ] = oldroot"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["substitute", "value", "under", "the", "PREV", "key", "of", "the", "root", "dictionary", "for", "last", "."], "cano_code": "last = root [ PREV ]", "decano_code": "last = root [ PREV ]", "token": ["last", "=", "root", "[", "PREV", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "last = root [ PREV ]"}
{"src": ["link", "is", "a", "list", "with", "4", "elements", ":", "last", ",", "root", ",", "key", "and", "result", "."], "cano_code": "link = [ last , root , key , result ]", "decano_code": "link = [ last , root , key , result ]", "token": ["link", "=", "[", "last", ",", "root", ",", "key", ",", "result", "]"], "type": ["NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "link = [ last , root , key , result ]"}
{"src": ["substitute", "link", "for", "value", "under", "the", "NEXT", "key", "of", "the", "last", "dictionary", ",", "for", "value", "under", "the", "PREV", "key", "of", "the", "root", "dictionary", ","], "cano_code": "last [ NEXT ] = root [ PREV ] = cache [ key ] = link", "decano_code": "last [ NEXT ] = root [ PREV ] = cache [ key ] = link", "token": ["last", "[", "NEXT", "]", "=", "root", "[", "PREV", "]", "=", "cache", "[", "key", "]", "=", "link"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME"], "raw_code": "last [ NEXT ] = root [ PREV ] = cache [ key ] = link"}
{"src": ["for", "value", "under", "the", "key", "key", "of", "the", "cache", "dictionary", ".", "increment", "stats", "dictionary", "value", "under", "the", "MISSES", "key", "by", "integer", "1", "."], "cano_code": "stats [ MISSES ] += 1", "decano_code": "stats [ MISSES ] += 1", "token": ["stats", "[", "MISSES", "]", "+=", "1"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NUMBER"], "raw_code": "stats [ MISSES ] += 1"}
{"src": ["return", "result", "."], "cano_code": "return result", "decano_code": "return result", "token": ["return", "result"], "type": ["KEYWORD", "NAME"], "raw_code": "return result"}
{"src": ["define", "the", "function", "cache_info", "."], "cano_code": "def cache_info ( ) :pass", "decano_code": "def cache_info ( ) :", "token": ["def", "cache_info", "(", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "OP"], "raw_code": "def cache_info ( ) :"}
{"src": ["with", "lock", ","], "cano_code": "with lock :pass", "decano_code": "with lock :", "token": ["with", "lock", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "with lock :"}
{"src": ["return", "an", "instance", "of", "_CacheInfo", "class", ",", "created", "with", "4", "arguments", ":", "value", "under", "the", "HITS", "key", "of", "the", "stats", "dictionary", ","], "cano_code": "return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )", "decano_code": "return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )", "token": ["return", "_CacheInfo", "(", "stats", "[", "HITS", "]", ",", "stats", "[", "MISSES", "]", ",", "maxsize", ",", "len", "(", "cache", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP"], "raw_code": "return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )"}
{"src": ["value", "under", "the", "MISSES", "key", "of", "the", "stats", "dictionary", ",", "maxsize", "and", "length", "of", "cache", ".", "define", "the", "function", "cache_clear", "."], "cano_code": "def cache_clear ( ) :pass", "decano_code": "def cache_clear ( ) :", "token": ["def", "cache_clear", "(", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "OP"], "raw_code": "def cache_clear ( ) :"}
{"src": ["with", "lock", ","], "cano_code": "with lock :pass", "decano_code": "with lock :", "token": ["with", "lock", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "with lock :"}
{"src": ["call", "the", "method", "cache.clear", "[", "cache", ".", "clear", "]", "."], "cano_code": "cache . clear ( )", "decano_code": "cache . clear ( )", "token": ["cache", ".", "clear", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP"], "raw_code": "cache . clear ( )"}
{"src": ["substitute", "first", "element", "of", "nonlocal_root", "for", "root", "."], "cano_code": "root = nonlocal_root [ 0 ]", "decano_code": "root = nonlocal_root [ 0 ]", "token": ["root", "=", "nonlocal_root", "[", "0", "]"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER", "OP"], "raw_code": "root = nonlocal_root [ 0 ]"}
{"src": ["root", "is", "an", "list", "with", "4", "elements", ":", "root", ",", "root", ",", "None", "and", "None", "."], "cano_code": "root [ : ] = [ root , root , None , None ]", "decano_code": "root [ : ] = [ root , root , None , None ]", "token": ["root", "[", ":", "]", "=", "[", "root", ",", "root", ",", "None", ",", "None", "]"], "type": ["NAME", "OP", "OP", "OP", "OP", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "KEYWORD", "OP"], "raw_code": "root [ : ] = [ root , root , None , None ]"}
{"src": ["stats", "is", "a", "list", "with", "2", "elements", ":", "2", "integers", "0", "."], "cano_code": "stats [ : ] = [ 0 , 0 ]", "decano_code": "stats [ : ] = [ 0 , 0 ]", "token": ["stats", "[", ":", "]", "=", "[", "0", ",", "0", "]"], "type": ["NAME", "OP", "OP", "OP", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP"], "raw_code": "stats [ : ] = [ 0 , 0 ]"}
{"src": ["substitute", "user_function", "for", "wrapper.__wrapped__", "[", "wrapper", ".", "__wrapped__", "]", "."], "cano_code": "wrapper . __wrapped__ = user_function", "decano_code": "wrapper . __wrapped__ = user_function", "token": ["wrapper", ".", "__wrapped__", "=", "user_function"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "wrapper . __wrapped__ = user_function"}
{"src": ["substitute", "cache_info", "for", "wrapper.cache_info", "[", "wrapper", ".", "cache_info", "]", "."], "cano_code": "wrapper . cache_info = cache_info", "decano_code": "wrapper . cache_info = cache_info", "token": ["wrapper", ".", "cache_info", "=", "cache_info"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "wrapper . cache_info = cache_info"}
{"src": ["substitute", "cache_clear", "for", "wrapper.cache_clear", "[", "wrapper", ".", "cache_clear", "]", "."], "cano_code": "wrapper . cache_clear = cache_clear", "decano_code": "wrapper . cache_clear = cache_clear", "token": ["wrapper", ".", "cache_clear", "=", "cache_clear"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "wrapper . cache_clear = cache_clear"}
{"src": ["call", "the", "function", "update_wrapper", "with", "2", "arguments", ":", "wrapper", "and", "user_function", ",", "return", "the", "result", "."], "cano_code": "return update_wrapper ( wrapper , user_function )", "decano_code": "return update_wrapper ( wrapper , user_function )", "token": ["return", "update_wrapper", "(", "wrapper", ",", "user_function", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return update_wrapper ( wrapper , user_function )"}
{"src": ["return", "decorating_function", "."], "cano_code": "return decorating_function", "decano_code": "return decorating_function", "token": ["return", "decorating_function"], "type": ["KEYWORD", "NAME"], "raw_code": "return decorating_function"}
{"src": ["from", "__future__", "import", "absolute_import", "into", "default", "name", "space", "."], "cano_code": "from __future__ import absolute_import", "decano_code": "from __future__ import absolute_import", "token": ["from", "__future__", "import", "absolute_import"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from __future__ import absolute_import"}
{"src": ["import", "module", "copy", "."], "cano_code": "import copy", "decano_code": "import copy", "token": ["import", "copy"], "type": ["KEYWORD", "NAME"], "raw_code": "import copy"}
{"src": ["from", "importlib", "import", "import_module", "into", "default", "name", "space", "."], "cano_code": "from importlib import import_module", "decano_code": "from importlib import import_module", "token": ["from", "importlib", "import", "import_module"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from importlib import import_module"}
{"src": ["import", "module", "os", "."], "cano_code": "import os", "decano_code": "import os", "token": ["import", "os"], "type": ["KEYWORD", "NAME"], "raw_code": "import os"}
{"src": ["import", "module", "sys", "."], "cano_code": "import sys", "decano_code": "import sys", "token": ["import", "sys"], "type": ["KEYWORD", "NAME"], "raw_code": "import sys"}
{"src": ["import", "module", "warnings", "."], "cano_code": "import warnings", "decano_code": "import warnings", "token": ["import", "warnings"], "type": ["KEYWORD", "NAME"], "raw_code": "import warnings"}
{"src": ["from", "django.core.exceptions", "[", "django", ".", "core", ".", "exceptions", "]", "import", "ImproperlyConfigured", "into", "default", "name", "space", "."], "cano_code": "from django . core . exceptions import ImproperlyConfigured", "decano_code": "from django . core . exceptions import ImproperlyConfigured", "token": ["from", "django", ".", "core", ".", "exceptions", "import", "ImproperlyConfigured"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . core . exceptions import ImproperlyConfigured"}
{"src": ["from", "django.utils", "[", "django", ".", "utils", "]", "import", "six", "into", "default", "name", "space", "."], "cano_code": "from django . utils import six", "decano_code": "from django . utils import six", "token": ["from", "django", ".", "utils", "import", "six"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils import six"}
{"src": ["from", "django.utils.deprecation", "[", "django", ".", "utils", ".", "deprecation", "]", "import", "RemovedInDjango19Warning", "into", "default", "name", "space", "."], "cano_code": "from django . utils . deprecation import RemovedInDjango19Warning", "decano_code": "from django . utils . deprecation import RemovedInDjango19Warning", "token": ["from", "django", ".", "utils", ".", "deprecation", "import", "RemovedInDjango19Warning"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . deprecation import RemovedInDjango19Warning"}
{"src": ["define", "the", "function", "import_string", "with", "an", "argument", "dotted_path", "."], "cano_code": "def import_string ( dotted_path ) :pass", "decano_code": "def import_string ( dotted_path ) :", "token": ["def", "import_string", "(", "dotted_path", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def import_string ( dotted_path ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["split", "dotted_path", "into", "two", "parts", "from", "the", "right", "at", "the", "_STR:0_", "character", ",", "assign", "the", "result", "to", "module_path", "and", "class_name", ",", "respectively", "."], "cano_code": "module_path , class_name = dotted_path . rsplit ( '_STR:0_' , 1 )", "decano_code": "module_path , class_name = dotted_path . rsplit ( '_STR:0_' , 1 )", "token": ["module_path", ",", "class_name", "=", "dotted_path", ".", "rsplit", "(", "\" _STR:0_ \"", ",", "1", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "NUMBER", "OP"], "raw_code": "module_path , class_name = dotted_path . rsplit ( '.' , 1 )"}
{"src": ["if", "ValueError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ValueError :pass", "decano_code": "except ValueError :", "token": ["except", "ValueError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ValueError :"}
{"src": ["msg", "is", "a", "string", "_STR:0_", "formated", "with", "dotted_path", "."], "cano_code": "msg = '_STR:0_' % dotted_path", "decano_code": "msg = '_STR:0_' % dotted_path", "token": ["msg", "=", "\" _STR:0_ \"", "%", "dotted_path"], "type": ["NAME", "OP", "STRING", "OP", "NAME"], "raw_code": "msg = \"%s doesn't look like a module path\" % dotted_path"}
{"src": ["call", "the", "function", "six.reraise", "[", "six", ".", "reraise", "]", "with", "3", "arguments", ":", "ImportError", ",", "instance", "of", "ImportError", "class", "created", "with", "an", "argument", "msg", ","], "cano_code": "six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )", "decano_code": "six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )", "token": ["six", ".", "reraise", "(", "ImportError", ",", "ImportError", "(", "msg", ")", ",", "sys", ".", "exc_info", "(", ")", "[", "2", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )"}
{"src": ["and", "third", "element", "of", "result", "of", "the", "function", "sys.exc_info", "[", "sys", ".", "exc_info", "]", ".", "call", "the", "function", "import_module", "with", "an", "argument", "module_path", ",", "substitute", "the", "result", "for", "module", "."], "cano_code": "module = import_module ( module_path )", "decano_code": "module = import_module ( module_path )", "token": ["module", "=", "import_module", "(", "module_path", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "module = import_module ( module_path )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["get", "attribute", "class_name", "form", "the", "module", "object", ",", "return", "it", "."], "cano_code": "return getattr ( module , class_name )", "decano_code": "return getattr ( module , class_name )", "token": ["return", "getattr", "(", "module", ",", "class_name", ")"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "return getattr ( module , class_name )"}
{"src": ["if", "AttributeError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept AttributeError :pass", "decano_code": "except AttributeError :", "token": ["except", "AttributeError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except AttributeError :"}
{"src": ["msg", "is", "a", "string", "_STR:0_", "formated", "with", "dotted_path", "and", "class_name", ",", "respectively", "."], "cano_code": "msg = '_STR:0_' % (  dotted_path , class_name )", "decano_code": "msg = '_STR:0_' % (  dotted_path , class_name )", "token": ["msg", "=", "\" _STR:0_ \"", "%", "(", "dotted_path", ",", "class_name", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "msg = 'Module \"%s\" does not define a \"%s\" attribute/class' % (  dotted_path , class_name )"}
{"src": ["call", "the", "function", "six.reraise", "[", "six", ".", "reraise", "]", "with", "3", "arguments", ":", "ImportError", ",", "instance", "of", "ImportError", "class", "created", "with", "an", "argument", "msg", ","], "cano_code": "six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )", "decano_code": "six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )", "token": ["six", ".", "reraise", "(", "ImportError", ",", "ImportError", "(", "msg", ")", ",", "sys", ".", "exc_info", "(", ")", "[", "2", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )"}
{"src": ["and", "third", "element", "of", "result", "of", "the", "function", "sys.exc_info", "[", "sys", ".", "exc_info", "]", ".", "define", "the", "function", "import_by_path", "with", "2", "arguments", "dotted_path", "and", "error_prefix", "set", "to", "an", "empty", "string..", "[", "string", ".", "", ".", "", "]"], "cano_code": "def import_by_path ( dotted_path , error_prefix = '' ) :pass", "decano_code": "def import_by_path ( dotted_path , error_prefix = '' ) :", "token": ["def", "import_by_path", "(", "dotted_path", ",", "error_prefix", "=", "''", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP", "OP"], "raw_code": "def import_by_path ( dotted_path , error_prefix = '' ) :"}
{"src": ["call", "the", "function", "warnings.warn", "[", "warnings", ".", "warn", "]", "with", "3", "arguments", ":", "string", "_STR:0_", ","], "cano_code": "warnings . warn (  '_STR:0_' ,  RemovedInDjango19Warning , stacklevel = 2 )", "decano_code": "warnings . warn (  '_STR:0_' ,  RemovedInDjango19Warning , stacklevel = 2 )", "token": ["warnings", ".", "warn", "(", "\" _STR:0_ \"", ",", "RemovedInDjango19Warning", ",", "stacklevel", "=", "2", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "NUMBER", "OP"], "raw_code": "warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )"}
{"src": ["RemovedInDjango19Warning", "and", "stacklevel", "as", "integer", "2.", "try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "function", "import_string", "with", "an", "argument", "dotted_path", ",", "substitute", "the", "result", "for", "attr", "."], "cano_code": "attr = import_string ( dotted_path )", "decano_code": "attr = import_string ( dotted_path )", "token": ["attr", "=", "import_string", "(", "dotted_path", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "attr = import_string ( dotted_path )"}
{"src": ["if", "ImportError", ",", "renamed", "to", "e", ",", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ImportError as e :pass", "decano_code": "except ImportError as e :", "token": ["except", "ImportError", "as", "e", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "except ImportError as e :"}
{"src": ["msg", "is", "a", "string", "_STR:0_", ",", "where", "'", "%", "s", "'", "is", "replaced", "with", "error_prefix", ",", "dotted_path", "and", "e", ",", "respectively", "."], "cano_code": "msg = '_STR:0_' % (  error_prefix , dotted_path , e )", "decano_code": "msg = '_STR:0_' % (  error_prefix , dotted_path , e )", "token": ["msg", "=", "\" _STR:0_ \"", "%", "(", "error_prefix", ",", "dotted_path", ",", "e", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "msg = '%sError importing module %s: \"%s\"' % (  error_prefix , dotted_path , e )"}
{"src": ["call", "the", "function", "six.reraise", "[", "six", ".", "reraise", "]", "with", "3", "arguments", ":", "ImproperlyConfigured", ",", "instance", "of", "ImproperlyConfigured", "class", "created", "with", "msg", ","], "cano_code": "six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )", "decano_code": "six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )", "token": ["six", ".", "reraise", "(", "ImproperlyConfigured", ",", "ImproperlyConfigured", "(", "msg", ")", ",", "sys", ".", "exc_info", "(", ")", "[", "2", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "NUMBER", "OP", "OP"], "raw_code": "six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )"}
{"src": ["and", "third", "element", "of", "the", "function", "sys.exc_info", "[", "sys", ".", "exc_info", "]", "result", ".", "return", "attr", "."], "cano_code": "return attr", "decano_code": "return attr", "token": ["return", "attr"], "type": ["KEYWORD", "NAME"], "raw_code": "return attr"}
{"src": ["define", "the", "function", "autodiscover_modules", "with", "2", "arguments", "unpacked", "list", "args", "and", "unpacked", "dictionary", "kwargs", "."], "cano_code": "def autodiscover_modules ( * args , ** kwargs ) :pass", "decano_code": "def autodiscover_modules ( * args , ** kwargs ) :", "token": ["def", "autodiscover_modules", "(", "*", "args", ",", "**", "kwargs", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "def autodiscover_modules ( * args , ** kwargs ) :"}
{"src": ["from", "django.apps", "[", "django", ".", "apps", "]", "import", "apps", "."], "cano_code": "from django . apps import apps", "decano_code": "from django . apps import apps", "token": ["from", "django", ".", "apps", "import", "apps"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . apps import apps"}
{"src": ["get", "value", "under", "the", "_STR:0_", "key", "of", "the", "kwargs", "dictionary", ",", "substitute", "it", "for", "register_to", "."], "cano_code": "register_to = kwargs . get ( '_STR:0_' )", "decano_code": "register_to = kwargs . get ( '_STR:0_' )", "token": ["register_to", "=", "kwargs", ".", "get", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "register_to = kwargs . get ( 'register_to' )"}
{"src": ["call", "the", "method", "apps.get_app_configs", "[", "apps", ".", "get_app_configs", "]", ",", "for", "every", "app_config", "in", "the", "result", ","], "cano_code": "for app_config in apps . get_app_configs ( ) :pass", "decano_code": "for app_config in apps . get_app_configs ( ) :", "token": ["for", "app_config", "in", "apps", ".", "get_app_configs", "(", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "for app_config in apps . get_app_configs ( ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["if", "register_to", "is", "true", ","], "cano_code": "if register_to :pass", "decano_code": "if register_to :", "token": ["if", "register_to", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if register_to :"}
{"src": ["call", "the", "method", "copy.copy", "[", "copy", ".", "copy", "]", "with", "an", "argument", "register_to._registry", "[", "register_to", ".", "_registry", "]", ",", "substitute", "the", "result", "for", "before_import_registry", "."], "cano_code": "before_import_registry = copy . copy ( register_to . _registry )", "decano_code": "before_import_registry = copy . copy ( register_to . _registry )", "token": ["before_import_registry", "=", "copy", ".", "copy", "(", "register_to", ".", "_registry", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "before_import_registry = copy . copy ( register_to . _registry )"}
{"src": ["for", "every", "module_to_search", "in", "args", ","], "cano_code": "for module_to_search in args :pass", "decano_code": "for module_to_search in args :", "token": ["for", "module_to_search", "in", "args", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for module_to_search in args :"}
{"src": ["call", "the", "function", "import_module", "with", "an", "argument", "string", "_STR:0_", ",", "where", "'", "%", "s", "'", "is", "replaced", "with", "app_config.name", "[", "app_config", ".", "name", "]", "and", "module_to_search", "."], "cano_code": "import_module ( '_STR:0_' % ( app_config . name , module_to_search ) )", "decano_code": "import_module ( '_STR:0_' % ( app_config . name , module_to_search ) )", "token": ["import_module", "(", "\" _STR:0_ \"", "%", "(", "app_config", ".", "name", ",", "module_to_search", ")", ")"], "type": ["NAME", "OP", "STRING", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "import_module ( '%s.%s' % ( app_config . name , module_to_search ) )"}
{"src": ["is", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept :pass", "decano_code": "except :", "token": ["except", ":"], "type": ["KEYWORD", "OP"], "raw_code": "except :"}
{"src": ["if", "register_to", "is", "true", ","], "cano_code": "if register_to :pass", "decano_code": "if register_to :", "token": ["if", "register_to", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if register_to :"}
{"src": ["substitute", "before_import_registry", "for", "register_to._registry", "[", "register_to", ".", "_registry", "]", "."], "cano_code": "register_to . _registry = before_import_registry", "decano_code": "register_to . _registry = before_import_registry", "token": ["register_to", ".", "_registry", "=", "before_import_registry"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "register_to . _registry = before_import_registry"}
{"src": ["if", "call", "to", "the", "function", "module_has_submodule", "with", "2", "arguments", ":", "app_config.module", "[", "app_config", ".", "module", "]", "and", "module_to_search", "evaluates", "to", "true", ","], "cano_code": "if module_has_submodule ( app_config . module , module_to_search ) :pass", "decano_code": "if module_has_submodule ( app_config . module , module_to_search ) :", "token": ["if", "module_has_submodule", "(", "app_config", ".", "module", ",", "module_to_search", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if module_has_submodule ( app_config . module , module_to_search ) :"}
{"src": ["raise", "an", "exception", ","], "cano_code": "raise", "decano_code": "raise", "token": ["raise"], "type": ["NAME"], "raw_code": "raise"}
{"src": ["if", "first", "and", "second", "element", "of", "sys.version_info", "[", "sys", ".", "version_info", "]", "are", "both", "equal", "to", "integer", "3", ","], "cano_code": "if sys . version_info [ : 2 ] >= ( 3 , 3 ) :pass", "decano_code": "if sys . version_info [ : 2 ] >= ( 3 , 3 ) :", "token": ["if", "sys", ".", "version_info", "[", ":", "2", "]", ">=", "(", "3", ",", "3", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP"], "raw_code": "if sys . version_info [ : 2 ] >= ( 3 , 3 ) :"}
{"src": ["if", "first", "and", "second", "element", "of", "sys.version_info", "[", "sys", ".", "version_info", "]", "are", "equal", "to", "integers", "3", "and", "4", ",", "respectively", ","], "cano_code": "if sys . version_info [ : 2 ] >= ( 3 , 4 ) :pass", "decano_code": "if sys . version_info [ : 2 ] >= ( 3 , 4 ) :", "token": ["if", "sys", ".", "version_info", "[", ":", "2", "]", ">=", "(", "3", ",", "4", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "OP", "NUMBER", "OP", "NUMBER", "OP", "OP"], "raw_code": "if sys . version_info [ : 2 ] >= ( 3 , 4 ) :"}
{"src": ["from", "importlib.util", "[", "importlib", ".", "util", "]", "import", "find_spec", "as", "importlib_find", "."], "cano_code": "from importlib . util import find_spec as importlib_find", "decano_code": "from importlib . util import find_spec as importlib_find", "token": ["from", "importlib", ".", "util", "import", "find_spec", "as", "importlib_find"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from importlib . util import find_spec as importlib_find"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["from", "importlib", "import", "find_loader", "as", "importlib_find", "."], "cano_code": "from importlib import find_loader as importlib_find", "decano_code": "from importlib import find_loader as importlib_find", "token": ["from", "importlib", "import", "find_loader", "as", "importlib_find"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from importlib import find_loader as importlib_find"}
{"src": ["define", "the", "function", "module_has_submodule", "with", "2", "arguments", ":", "package", "and", "module_name", "."], "cano_code": "def module_has_submodule ( package , module_name ) :pass", "decano_code": "def module_has_submodule ( package , module_name ) :", "token": ["def", "module_has_submodule", "(", "package", ",", "module_name", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def module_has_submodule ( package , module_name ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["substitute", "package.__name__", "[", "package", ".", "__name__", "]", "for", "package_name", "."], "cano_code": "package_name = package . __name__", "decano_code": "package_name = package . __name__", "token": ["package_name", "=", "package", ".", "__name__"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "package_name = package . __name__"}
{"src": ["substitute", "package.__path__", "[", "package", ".", "__path__", "]", "for", "package_path", "."], "cano_code": "package_path = package . __path__", "decano_code": "package_path = package . __path__", "token": ["package_path", "=", "package", ".", "__path__"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "package_path = package . __path__"}
{"src": ["if", "AttributeError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept AttributeError :pass", "decano_code": "except AttributeError :", "token": ["except", "AttributeError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except AttributeError :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["concatenate", "package_name", ",", "string", "_STR:0_", "and", "module_name", ",", "substitute", "it", "for", "full_module_name", "."], "cano_code": "full_module_name = package_name + '_STR:0_' + module_name", "decano_code": "full_module_name = package_name + '_STR:0_' + module_name", "token": ["full_module_name", "=", "package_name", "+", "\" _STR:0_ \"", "+", "module_name"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP", "NAME"], "raw_code": "full_module_name = package_name + '.' + module_name"}
{"src": ["call", "the", "function", "importlib_find", "with", "2", "arguments", ":", "full_module_name", "and", "package_path", ",", "if", "the", "result", "is", "not", "None", ",", "return", "boolean", "True", ","], "cano_code": "return importlib_find ( full_module_name , package_path ) is not None", "decano_code": "return importlib_find ( full_module_name , package_path ) is not None", "token": ["return", "importlib_find", "(", "full_module_name", ",", "package_path", ")", "is", "not", "None"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "KEYWORD", "KEYWORD"], "raw_code": "return importlib_find ( full_module_name , package_path ) is not None"}
{"src": ["otherwise", "return", "boolean", "False", ".", "if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["import", "imp", "."], "cano_code": "import imp", "decano_code": "import imp", "token": ["import", "imp"], "type": ["KEYWORD", "NAME"], "raw_code": "import imp"}
{"src": ["define", "the", "function", "module_has_submodule", "with", "2", "arguments", ":", "package", "and", "module_name", "."], "cano_code": "def module_has_submodule ( package , module_name ) :pass", "decano_code": "def module_has_submodule ( package , module_name ) :", "token": ["def", "module_has_submodule", "(", "package", ",", "module_name", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def module_has_submodule ( package , module_name ) :"}
{"src": ["join", "package.__name__", "[", "package", ".", "__name__", "]", "and", "module_name", "into", "a", "string", "separated", "with", "_STR:0_", ",", "substitute", "it", "for", "name", "."], "cano_code": "name = \".\" . join ( [ package . __name__ , module_name ] )", "decano_code": "name = \".\" . join ( [ package . __name__ , module_name ] )", "token": ["name", "=", "\" . \"", ".", "join", "(", "[", "package", ".", "__name__", ",", "module_name", "]", ")"], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "name = \".\" . join ( [ package . __name__ , module_name ] )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["if", "value", "under", "the", "name", "key", "of", "the", "sys.modules", "[", "sys", ".", "modules", "]", "dictionary", "is", "not", "None", ",", "return", "boolean", "True", ",", "otherwise", "return", "boolean", "False", "."], "cano_code": "return sys . modules [ name ] is not None", "decano_code": "return sys . modules [ name ] is not None", "token": ["return", "sys", ".", "modules", "[", "name", "]", "is", "not", "None"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "KEYWORD", "KEYWORD"], "raw_code": "return sys . modules [ name ] is not None"}
{"src": ["if", "KeyError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept KeyError :pass", "decano_code": "except KeyError :", "token": ["except", "KeyError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except KeyError :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["substitute", "package.__path__", "[", "package", ".", "__path__", "]", "for", "package_path", "."], "cano_code": "package_path = package . __path__", "decano_code": "package_path = package . __path__", "token": ["package_path", "=", "package", ".", "__path__"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "package_path = package . __path__"}
{"src": ["if", "AttributeError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept AttributeError :pass", "decano_code": "except AttributeError :", "token": ["except", "AttributeError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except AttributeError :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["for", "every", "finder", "in", "sys.meta_path", "[", "sys", ".", "meta_path", "]", ","], "cano_code": "for finder in sys . meta_path :pass", "decano_code": "for finder in sys . meta_path :", "token": ["for", "finder", "in", "sys", ".", "meta_path", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "for finder in sys . meta_path :"}
{"src": ["if", "call", "to", "the", "method", "finder.find_module", "[", "finder", ".", "find_module", "]", "with", "2", "arguments", ":", "name", "and", "package_path", "evaluates", "to", "true", ","], "cano_code": "if finder . find_module ( name , package_path ) :pass", "decano_code": "if finder . find_module ( name , package_path ) :", "token": ["if", "finder", ".", "find_module", "(", "name", ",", "package_path", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if finder . find_module ( name , package_path ) :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["for", "every", "entry", "in", "package_path", ","], "cano_code": "for entry in package_path :pass", "decano_code": "for entry in package_path :", "token": ["for", "entry", "in", "package_path", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for entry in package_path :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["substitute", "the", "value", "under", "the", "entry", "key", "of", "the", "sys.path_importer_cache", "[", "sys", ".", "path_importer_cache", "]", "dictionary", "for", "finder", "."], "cano_code": "finder = sys . path_importer_cache [ entry ]", "decano_code": "finder = sys . path_importer_cache [ entry ]", "token": ["finder", "=", "sys", ".", "path_importer_cache", "[", "entry", "]"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "finder = sys . path_importer_cache [ entry ]"}
{"src": ["if", "finder", "is", "None", ","], "cano_code": "if finder is None :pass", "decano_code": "if finder is None :", "token": ["if", "finder", "is", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if finder is None :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "method", "imp.find_module", "[", "imp", ".", "find_module", "]", "with", "2", "arguments", ":", "module_name", "and", "list", "containing", "element", "entry", ",", "assign", "the", "result", "to", "file_", ",", "_", ","], "cano_code": "file_ , _ , _ = imp . find_module ( module_name , [ entry ] )", "decano_code": "file_ , _ , _ = imp . find_module ( module_name , [ entry ] )", "token": ["file_", ",", "_", ",", "_", "=", "imp", ".", "find_module", "(", "module_name", ",", "[", "entry", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "file_ , _ , _ = imp . find_module ( module_name , [ entry ] )"}
{"src": ["and", "_", ",", "respectively", ".", "if", "file_", "is", "true", ","], "cano_code": "if file_ :pass", "decano_code": "if file_ :", "token": ["if", "file_", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if file_ :"}
{"src": ["close", "file_", "file", "descriptor", "."], "cano_code": "file_ . close ( )", "decano_code": "file_ . close ( )", "token": ["file_", ".", "close", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP"], "raw_code": "file_ . close ( )"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["if", "ImportError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ImportError :pass", "decano_code": "except ImportError :", "token": ["except", "ImportError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ImportError :"}
{"src": ["skip", "this", "loop", "iteration", ","], "cano_code": "continue", "decano_code": "continue", "token": ["continue"], "type": ["NAME"], "raw_code": "continue"}
{"src": ["otherwise", "if", "call", "to", "the", "method", "finder.find_module", "[", "finder", ".", "find_module", "]", "with", "an", "argument", "name", "evaluates", "to", "true", ","], "cano_code": "if True: pass\nelif finder . find_module ( name ) :pass", "decano_code": "elif finder . find_module ( name ) :", "token": ["elif", "finder", ".", "find_module", "(", "name", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "elif finder . find_module ( name ) :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["skip", "this", "loop", "iteration", ","], "cano_code": "continue", "decano_code": "continue", "token": ["continue"], "type": ["NAME"], "raw_code": "continue"}
{"src": ["if", "KeyError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept KeyError :pass", "decano_code": "except KeyError :", "token": ["except", "KeyError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except KeyError :"}
{"src": ["for", "every", "hook", "in", "sys.path_hooks", "[", "sys", ".", "path_hooks", "]", ","], "cano_code": "for hook in sys . path_hooks :pass", "decano_code": "for hook in sys . path_hooks :", "token": ["for", "hook", "in", "sys", ".", "path_hooks", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "for hook in sys . path_hooks :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "function", "hook", "with", "an", "argument", "entry", ",", "substitute", "the", "result", "for", "finder", "."], "cano_code": "finder = hook ( entry )", "decano_code": "finder = hook ( entry )", "token": ["finder", "=", "hook", "(", "entry", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "finder = hook ( entry )"}
{"src": ["if", "call", "to", "the", "method", "finder.find_module", "[", "finder", ".", "find_module", "]", "with", "an", "argument", "name", "evaluates", "to", "true", ","], "cano_code": "if finder . find_module ( name ) :pass", "decano_code": "if finder . find_module ( name ) :", "token": ["if", "finder", ".", "find_module", "(", "name", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if finder . find_module ( name ) :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["break", "from", "the", "loop", "execution", ","], "cano_code": "break", "decano_code": "break", "token": ["break"], "type": ["NAME"], "raw_code": "break"}
{"src": ["if", "ImportError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ImportError :pass", "decano_code": "except ImportError :", "token": ["except", "ImportError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ImportError :"}
{"src": ["skip", "this", "loop", "iteration", ","], "cano_code": "continue", "decano_code": "continue", "token": ["continue"], "type": ["NAME"], "raw_code": "continue"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["if", "entry", "is", "a", "directory", ","], "cano_code": "if os . path . isdir ( entry ) :pass", "decano_code": "if os . path . isdir ( entry ) :", "token": ["if", "os", ".", "path", ".", "isdir", "(", "entry", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if os . path . isdir ( entry ) :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["call", "the", "method", "imp.find_module", "[", "imp", ".", "find_module", "]", "with", "2", "arguments", ":", "module_name", "and", "list", "containing", "element", "entry", ",", "assign", "the", "result", "to", "file_", ",", "_", ","], "cano_code": "file_ , _ , _ = imp . find_module ( module_name , [ entry ] )", "decano_code": "file_ , _ , _ = imp . find_module ( module_name , [ entry ] )", "token": ["file_", ",", "_", ",", "_", "=", "imp", ".", "find_module", "(", "module_name", ",", "[", "entry", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "file_ , _ , _ = imp . find_module ( module_name , [ entry ] )"}
{"src": ["and", "_", ",", "respectively", ".", "if", "file_", "is", "true", ","], "cano_code": "if file_ :pass", "decano_code": "if file_ :", "token": ["if", "file_", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if file_ :"}
{"src": ["close", "file_", "file", "descriptor", "."], "cano_code": "file_ . close ( )", "decano_code": "file_ . close ( )", "token": ["file_", ".", "close", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP"], "raw_code": "file_ . close ( )"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["if", "ImportError", "exception", "is", "caught", ","], "cano_code": "try: pass\nexcept ImportError :pass", "decano_code": "except ImportError :", "token": ["except", "ImportError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except ImportError :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["from", "django.conf", "[", "django", ".", "conf", "]", "import", "settings", "into", "default", "name", "space", "."], "cano_code": "from django . conf import settings", "decano_code": "from django . conf import settings", "token": ["from", "django", ".", "conf", "import", "settings"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . conf import settings"}
{"src": ["from", "django.utils.safestring", "[", "django", ".", "utils", ".", "safestring", "]", "import", "mark_safe", "into", "default", "name", "space", "."], "cano_code": "from django . utils . safestring import mark_safe", "decano_code": "from django . utils . safestring import mark_safe", "token": ["from", "django", ".", "utils", ".", "safestring", "import", "mark_safe"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils . safestring import mark_safe"}
{"src": ["from", "django.utils", "[", "django", ".", "utils", "]", "import", "six", "into", "default", "name", "space", "."], "cano_code": "from django . utils import six", "decano_code": "from django . utils import six", "token": ["from", "django", ".", "utils", "import", "six"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils import six"}
{"src": ["define", "the", "function", "format", "with", "6", "arguments", ":", "number", ",", "decimal_sep", ",", "decimal_pos", "set", "to", "None", ",", "grouping", "set", "to", "integer", "0", ","], "cano_code": "def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = '' ,  force_grouping = False ) :pass", "decano_code": "def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = '' ,  force_grouping = False ) :", "token": ["def", "format", "(", "number", ",", "decimal_sep", ",", "decimal_pos", "=", "None", ",", "grouping", "=", "0", ",", "thousand_sep", "=", "\"  \"", ",", "force_grouping", "=", "False", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "NAME", "OP", "STRING", "OP", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = '' ,  force_grouping = False ) :"}
{"src": ["if", "settings.USE_L10N", "[", "settings", ".", "USE_L10N", "]", "is", "true", ",", "substitute", "settings.USE_THOUSAND_SEPARATOR", "[", "settings", ".", "USE_THOUSAND_SEPARATOR", "]", "for", "use_grouping", ","], "cano_code": "use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR", "decano_code": "use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR", "token": ["use_grouping", "=", "settings", ".", "USE_L10N", "and", "settings", ".", "USE_THOUSAND_SEPARATOR"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NAME"], "raw_code": "use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR"}
{"src": ["otherwise", "substitute", "settings.USE_L10N", "[", "settings", ".", "USE_L10N", "]", "for", "use_grouping", ".", "if", "use_grouping", "is", "true", "substitute", "it", "for", "use_grouping", ",", "otherwise", "substitute", "force_grouping", "for", "use_grouping", "."], "cano_code": "use_grouping = use_grouping or force_grouping", "decano_code": "use_grouping = use_grouping or force_grouping", "token": ["use_grouping", "=", "use_grouping", "or", "force_grouping"], "type": ["NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "use_grouping = use_grouping or force_grouping"}
{"src": ["if", "use_grouping", "is", "true", "and", "grouping", "is", "greater", "than", "integer", "0", ",", "use_grouping", "is", "boolean", "True", ",", "otherwise", "it", "is", "boolean", "False", "."], "cano_code": "use_grouping = use_grouping and grouping > 0", "decano_code": "use_grouping = use_grouping and grouping > 0", "token": ["use_grouping", "=", "use_grouping", "and", "grouping", ">", "0"], "type": ["NAME", "OP", "NAME", "KEYWORD", "NAME", "OP", "NUMBER"], "raw_code": "use_grouping = use_grouping and grouping > 0"}
{"src": ["if", "number", "is", "an", "integer", "and", "use_grouping", "is", "false", "and", "decimal_pos", "is", "false", ","], "cano_code": "if isinstance ( number , int ) and not use_grouping and not decimal_pos :pass", "decano_code": "if isinstance ( number , int ) and not use_grouping and not decimal_pos :", "token": ["if", "isinstance", "(", "number", ",", "int", ")", "and", "not", "use_grouping", "and", "not", "decimal_pos", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "KEYWORD", "OP", "KEYWORD", "KEYWORD", "NAME", "KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if isinstance ( number , int ) and not use_grouping and not decimal_pos :"}
{"src": ["call", "the", "function", "six.text_type", "[", "six", ".", "text_type", "]", "with", "an", "argument", "number", ",", "use", "the", "result", "as", "an", "argument", "for", "the", "call", "to", "the", "function", "mark_safe", ","], "cano_code": "return mark_safe ( six . text_type ( number ) )", "decano_code": "return mark_safe ( six . text_type ( number ) )", "token": ["return", "mark_safe", "(", "six", ".", "text_type", "(", "number", ")", ")"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "return mark_safe ( six . text_type ( number ) )"}
{"src": ["return", "the", "result", ".", "sign", "is", "an", "empty", "string", "."], "cano_code": "sign = ''", "decano_code": "sign = ''", "token": ["sign", "=", "\"  \""], "type": ["NAME", "OP", "STRING"], "raw_code": "sign = ''"}
{"src": ["call", "the", "function", "six.text_type", "[", "six", ".", "text_type", "]", "with", "an", "argument", "number", ",", "substitute", "the", "result", "for", "str_number", "."], "cano_code": "str_number = six . text_type ( number )", "decano_code": "str_number = six . text_type ( number )", "token": ["str_number", "=", "six", ".", "text_type", "(", "number", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "str_number = six . text_type ( number )"}
{"src": ["if", "first", "element", "of", "str_number", "equals", "a", "string", "_STR:0_", "."], "cano_code": "if str_number [ 0 ] == '_STR:0_' :pass", "decano_code": "if str_number [ 0 ] == '_STR:0_' :", "token": ["if", "str_number", "[", "0", "]", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP", "OP", "STRING", "OP"], "raw_code": "if str_number [ 0 ] == '-' :"}
{"src": ["sign", "is", "a", "string", "_STR:0_", "."], "cano_code": "sign = '_STR:0_'", "decano_code": "sign = '_STR:0_'", "token": ["sign", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "sign = '-'"}
{"src": ["remove", "the", "first", "element", "from", "str_number", "."], "cano_code": "str_number = str_number [ 1 : ]", "decano_code": "str_number = str_number [ 1 : ]", "token": ["str_number", "=", "str_number", "[", "1", ":", "]"], "type": ["NAME", "OP", "NAME", "OP", "NUMBER", "OP", "OP"], "raw_code": "str_number = str_number [ 1 : ]"}
{"src": ["if", "_STR:0_", "is", "not", "contained", "in", "str_number", ","], "cano_code": "if '_STR:0_' in str_number :pass", "decano_code": "if '_STR:0_' in str_number :", "token": ["if", "\" _STR:0_ \"", "in", "str_number", ":"], "type": ["KEYWORD", "STRING", "KEYWORD", "NAME", "OP"], "raw_code": "if '.' in str_number :"}
{"src": ["split", "str_number", "by", "_STR:0_", ",", "substitute", "the", "result", "for", "int_part", "and", "dec_part", ",", "respectively", "."], "cano_code": "int_part , dec_part = str_number . split ( '_STR:0_' )", "decano_code": "int_part , dec_part = str_number . split ( '_STR:0_' )", "token": ["int_part", ",", "dec_part", "=", "str_number", ".", "split", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "int_part , dec_part = str_number . split ( '.' )"}
{"src": ["if", "decimal_pos", "is", "not", "None", ","], "cano_code": "if decimal_pos is not None :pass", "decano_code": "if decimal_pos is not None :", "token": ["if", "decimal_pos", "is", "not", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if decimal_pos is not None :"}
{"src": ["substitute", "first", "decimal_pos", "elements", "of", "dec_part", "for", "dec_part", "."], "cano_code": "dec_part = dec_part [ : decimal_pos ]", "decano_code": "dec_part = dec_part [ : decimal_pos ]", "token": ["dec_part", "=", "dec_part", "[", ":", "decimal_pos", "]"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP"], "raw_code": "dec_part = dec_part [ : decimal_pos ]"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["substitute", "str_number", "and", "an", "empty", "string", "for", "int_part", "and", "dec_part", "."], "cano_code": "int_part , dec_part = str_number , ''", "decano_code": "int_part , dec_part = str_number , ''", "token": ["int_part", ",", "dec_part", "=", "str_number", ",", "\"  \""], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "STRING"], "raw_code": "int_part , dec_part = str_number , ''"}
{"src": ["if", "decimal_pos", "is", "not", "None"], "cano_code": "if decimal_pos is not None :pass", "decano_code": "if decimal_pos is not None :", "token": ["if", "decimal_pos", "is", "not", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if decimal_pos is not None :"}
{"src": ["subtract", "length", "of", "dec_part", "from", "decimal_pos", ",", "multiply", "the", "number", "of", "character", "_STR:0_", "by", "the", "result", ","], "cano_code": "dec_part = dec_part + ( '_STR:0_' * ( decimal_pos - len ( dec_part ) ) )", "decano_code": "dec_part = dec_part + ( '_STR:0_' * ( decimal_pos - len ( dec_part ) ) )", "token": ["dec_part", "=", "dec_part", "+", "(", "\" _STR:0_ \"", "*", "(", "decimal_pos", "-", "len", "(", "dec_part", ")", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "STRING", "OP", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "dec_part = dec_part + ( '0' * ( decimal_pos - len ( dec_part ) ) )"}
{"src": ["append", "the", "resulting", "string", "to", "dec_part", ",", "substitute", "it", "for", "dec_part", ".", "if", "dec_part", "is", "true", ","], "cano_code": "if dec_part :pass", "decano_code": "if dec_part :", "token": ["if", "dec_part", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if dec_part :"}
{"src": ["add", "decimal_sep", "and", "dec_part", ",", "substitute", "the", "result", "for", "dec_part", "."], "cano_code": "dec_part = decimal_sep + dec_part", "decano_code": "dec_part = decimal_sep + dec_part", "token": ["dec_part", "=", "decimal_sep", "+", "dec_part"], "type": ["NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "dec_part = decimal_sep + dec_part"}
{"src": ["if", "use_grouping", "is", "true", ","], "cano_code": "if use_grouping :pass", "decano_code": "if use_grouping :", "token": ["if", "use_grouping", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if use_grouping :"}
{"src": ["int_part_gd", "is", "an", "empty", "string", "."], "cano_code": "int_part_gd = ''", "decano_code": "int_part_gd = ''", "token": ["int_part_gd", "=", "\"  \""], "type": ["NAME", "OP", "STRING"], "raw_code": "int_part_gd = ''"}
{"src": ["for", "every", "cnt", "and", "digit", "in", "enumerated", "list", "int_part", "with", "reversed", "ordering", "of", "elements", ","], "cano_code": "for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :pass", "decano_code": "for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :", "token": ["for", "cnt", ",", "digit", "in", "enumerate", "(", "int_part", "[", ":", ":", "-", "1", "]", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "KEYWORD", "OP", "NAME", "OP", "OP", "OP", "OP", "NUMBER", "OP", "OP", "OP"], "raw_code": "for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :"}
{"src": ["if", "cnt", "is", "true", "and", "remained", "of", "dividing", "cnt", "with", "grouping", "is", "zero", ","], "cano_code": "if cnt and not cnt % grouping :pass", "decano_code": "if cnt and not cnt % grouping :", "token": ["if", "cnt", "and", "not", "cnt", "%", "grouping", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "if cnt and not cnt % grouping :"}
{"src": ["increment", "int_part_gd", "by", "thousand_sep", "."], "cano_code": "int_part_gd += thousand_sep", "decano_code": "int_part_gd += thousand_sep", "token": ["int_part_gd", "+=", "thousand_sep"], "type": ["NAME", "OP", "NAME"], "raw_code": "int_part_gd += thousand_sep"}
{"src": ["append", "digit", "to", "int_part_gd", "."], "cano_code": "int_part_gd += digit", "decano_code": "int_part_gd += digit", "token": ["int_part_gd", "+=", "digit"], "type": ["NAME", "OP", "NAME"], "raw_code": "int_part_gd += digit"}
{"src": ["invert", "the", "ordering", "of", "elements", "of", "int_part_gd", ",", "substitute", "it", "for", "int_part", "."], "cano_code": "int_part = int_part_gd [ : : - 1 ]", "decano_code": "int_part = int_part_gd [ : : - 1 ]", "token": ["int_part", "=", "int_part_gd", "[", ":", ":", "-", "1", "]"], "type": ["NAME", "OP", "NAME", "OP", "OP", "OP", "OP", "NUMBER", "OP"], "raw_code": "int_part = int_part_gd [ : : - 1 ]"}
{"src": ["sum", "sign", ",", "int_part", "and", "dec_part", ",", "return", "the", "result", "."], "cano_code": "return sign + int_part + dec_part", "decano_code": "return sign + int_part + dec_part", "token": ["return", "sign", "+", "int_part", "+", "dec_part"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME"], "raw_code": "return sign + int_part + dec_part"}
{"src": ["from", "__future__", "import", "unicode_literals", "into", "default", "name", "space", "."], "cano_code": "from __future__ import unicode_literals", "decano_code": "from __future__ import unicode_literals", "token": ["from", "__future__", "import", "unicode_literals"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME"], "raw_code": "from __future__ import unicode_literals"}
{"src": ["from", "django.utils", "[", "django", ".", "utils", "]", "import", "six", "into", "default", "name", "space", "."], "cano_code": "from django . utils import six", "decano_code": "from django . utils import six", "token": ["from", "django", ".", "utils", "import", "six"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME"], "raw_code": "from django . utils import six"}
{"src": ["from", "django.utils.six.moves", "[", "django", ".", "utils", ".", "six", ".", "moves", "]", "import", "zip", "into", "default", "name", "space", "."], "cano_code": "from django . utils . six . moves import zip", "decano_code": "from django . utils . six . moves import zip", "token": ["from", "django", ".", "utils", ".", "six", ".", "moves", "import", "zip"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "KEYWORD", "KEYWORD"], "raw_code": "from django . utils . six . moves import zip"}
{"src": ["ESCAPE_MAPPINGS", "is", "an", "dictionary", "with", "10", "initial", "entries", ":", "None", "for", "_STR:0_", ",", "None", "for", "_STR:1_", ",", "None", "for", "_STR:2_", ",", "_STR:3_", "for", "_STR:4_", ",", "_STR:5_", "for", "_STR:6_", ","], "cano_code": "ESCAPE_MAPPINGS = {  \"A\" : None ,  \"b\" : None ,  \"B\" : None ,  \"d\" : \"0\" ,  \"D\" : \"x\" ,  \"s\" : \" \" ,  \"S\" : \"x\" ,  \"w\" : \"x\" ,  \"W\" : \"!\" ,  \"Z\" : None ,  }", "decano_code": "ESCAPE_MAPPINGS = {  \"A\" : None ,  \"b\" : None ,  \"B\" : None ,  \"d\" : \"0\" ,  \"D\" : \"x\" ,  \"s\" : \" \" ,  \"S\" : \"x\" ,  \"w\" : \"x\" ,  \"W\" : \"!\" ,  \"Z\" : None ,  }", "token": ["ESCAPE_MAPPINGS", "=", "{", "\" A \"", ":", "None", ",", "\" b \"", ":", "None", ",", "\" B \"", ":", "None", ",", "\" d \"", ":", "\" 0 \"", ",", "\" D \"", ":", "\" x \"", ",", "\" s \"", ":", "\"   \"", ",", "\" S \"", ":", "\" x \"", ",", "\" w \"", ":", "\" x \"", ",", "\" W \"", ":", "\" ! \"", ",", "\" Z \"", ":", "None", ",", "}"], "type": ["NAME", "OP", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "KEYWORD", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "STRING", "OP", "KEYWORD", "OP", "OP"], "raw_code": "ESCAPE_MAPPINGS = {  \"A\" : None ,  \"b\" : None ,  \"B\" : None ,  \"d\" : \"0\" ,  \"D\" : \"x\" ,  \"s\" : \" \" ,  \"S\" : \"x\" ,  \"w\" : \"x\" ,  \"W\" : \"!\" ,  \"Z\" : None ,  }"}
{"src": ["_STR:0_", "for", "_STR:1_", ",", "_STR:2_", "for", "_STR:3_", ",", "_STR:2_", "for", "_STR:4_", ",", "_STR:5_", "for", "_STR:4_", "and", "None", "for", "_STR:6_", ".", "derive", "the", "class", "Choice", "from", "list", "base", "class", "."], "cano_code": "class Choice ( list ) :pass", "decano_code": "class Choice ( list ) :", "token": ["class", "Choice", "(", "list", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "class Choice ( list ) :"}
{"src": ["derive", "the", "class", "Group", "from", "list", "base", "class", "."], "cano_code": "class Group ( list ) :pass", "decano_code": "class Group ( list ) :", "token": ["class", "Group", "(", "list", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "class Group ( list ) :"}
{"src": ["derive", "the", "class", "NonCapture", "from", "list", "base", "class", "."], "cano_code": "class NonCapture ( list ) :pass", "decano_code": "class NonCapture ( list ) :", "token": ["class", "NonCapture", "(", "list", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD", "OP", "OP"], "raw_code": "class NonCapture ( list ) :"}
{"src": ["define", "the", "function", "normalize", "with", "an", "argument", "pattern", "."], "cano_code": "def normalize ( pattern ) :pass", "decano_code": "def normalize ( pattern ) :", "token": ["def", "normalize", "(", "pattern", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def normalize ( pattern ) :"}
{"src": ["result", "is", "an", "empty", "list", "."], "cano_code": "result = [ ]", "decano_code": "result = [ ]", "token": ["result", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "result = [ ]"}
{"src": ["non_capturing_groups", "is", "an", "empty", "list", "."], "cano_code": "non_capturing_groups = [ ]", "decano_code": "non_capturing_groups = [ ]", "token": ["non_capturing_groups", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "non_capturing_groups = [ ]"}
{"src": ["consume_next", "is", "boolean", "True", "."], "cano_code": "consume_next = True", "decano_code": "consume_next = True", "token": ["consume_next", "=", "True"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "consume_next = True"}
{"src": ["call", "the", "function", "next_char", "with", "an", "argument", "iterator", "pattern", ",", "substitute", "the", "result", "for", "pattern_iter", "."], "cano_code": "pattern_iter = next_char ( iter ( pattern ) )", "decano_code": "pattern_iter = next_char ( iter ( pattern ) )", "token": ["pattern_iter", "=", "next_char", "(", "iter", "(", "pattern", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP"], "raw_code": "pattern_iter = next_char ( iter ( pattern ) )"}
{"src": ["num_args", "is", "an", "integer", "0", "."], "cano_code": "num_args = 0", "decano_code": "num_args = 0", "token": ["num_args", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "num_args = 0"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["if", "StopIteration", "exception", ","], "cano_code": "try: pass\nexcept StopIteration :pass", "decano_code": "except StopIteration :", "token": ["except", "StopIteration", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except StopIteration :"}
{"src": ["return", "a", "list", "with", "an", "element", "tuple", "with", "2", "elements", ":", "an", "empty", "string", "and", "an", "empty", "list", "."], "cano_code": "return [ ( '' , [ ] ) ]", "decano_code": "return [ ( '' , [ ] ) ]", "token": ["return", "[", "(", "\"  \"", ",", "[", "]", ")", "]"], "type": ["KEYWORD", "OP", "OP", "STRING", "OP", "OP", "OP", "OP", "OP"], "raw_code": "return [ ( '' , [ ] ) ]"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["endless", "loop", ","], "cano_code": "while True :pass", "decano_code": "while True :", "token": ["while", "True", ":"], "type": ["KEYWORD", "KEYWORD", "OP"], "raw_code": "while True :"}
{"src": ["if", "escaped", "is", "true", ","], "cano_code": "if escaped :pass", "decano_code": "if escaped :", "token": ["if", "escaped", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if escaped :"}
{"src": ["append", "ch", "to", "result", "."], "cano_code": "result . append ( ch )", "decano_code": "result . append ( ch )", "token": ["result", ".", "append", "(", "ch", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "result . append ( ch )"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == '.' :"}
{"src": ["append", "string", "_STR:0_", "to", "result", "."], "cano_code": "result . append ( \".\" )", "decano_code": "result . append ( \".\" )", "token": ["result", ".", "append", "(", "\" . \"", ")"], "type": ["NAME", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "result . append ( \".\" )"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == '|' :"}
{"src": ["raise", "an", "NotImplementedError", "exception", "with", "an", "argument", "string", "_STR:0_", "."], "cano_code": "raise NotImplementedError ( '_STR:0_' )", "decano_code": "raise NotImplementedError ( '_STR:0_' )", "token": ["raise", "NotImplementedError", "(", "\" _STR:0_ \"", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "raise NotImplementedError ( 'Awaiting Implementation' )"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == \"^\" :pass", "decano_code": "elif ch == \"^\" :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == \"^\" :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == '$' :"}
{"src": ["skip", "this", "loop", "iteration", "."], "cano_code": "break", "decano_code": "break", "token": ["continue"], "type": ["NAME"], "raw_code": "break"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == ')' :"}
{"src": ["remove", "first", "element", "from", "non_capturing_groups", ",", "substitute", "it", "for", "start", "."], "cano_code": "start = non_capturing_groups . pop ( )", "decano_code": "start = non_capturing_groups . pop ( )", "token": ["start", "=", "non_capturing_groups", ".", "pop", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "start = non_capturing_groups . pop ( )"}
{"src": ["inner", "is", "an", "instance", "of", "NonCapture", ",", "created", "with", "elements", "of", "result", "from", "start", "index", "to", "the", "end", "."], "cano_code": "inner = NonCapture ( result [ start : ] )", "decano_code": "inner = NonCapture ( result [ start : ] )", "token": ["inner", "=", "NonCapture", "(", "result", "[", "start", ":", "]", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "inner = NonCapture ( result [ start : ] )"}
{"src": ["append", "list", "with", "element", "inner", "to", "list", "containing", "first", "start", "elements", "of", "result", ",", "substitute", "it", "for", "result", "."], "cano_code": "result = result [ : start ] + [ inner ]", "decano_code": "result = result [ : start ] + [ inner ]", "token": ["result", "=", "result", "[", ":", "start", "]", "+", "[", "inner", "]"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "OP", "NAME", "OP"], "raw_code": "result = result [ : start ] + [ inner ]"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == '[' :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["append", "ch", "to", "result", "."], "cano_code": "result . append ( ch )", "decano_code": "result . append ( ch )", "token": ["result", ".", "append", "(", "ch", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "result . append ( ch )"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["while", "escaped", "is", "true", "or", "ch", "is", "not", "equal", "to", "a", "string", "_STR:0_", ","], "cano_code": "while escaped or ch != '_STR:0_' :pass", "decano_code": "while escaped or ch != '_STR:0_' :", "token": ["while", "escaped", "or", "ch", "!=", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "while escaped or ch != ']' :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == '(' :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["if", "ch", "is", "not", "equal", "to", "a", "sring", "_STR:0_", "or", "escaped", "is", "true", ","], "cano_code": "if ch != '_STR:0_' or escaped :pass", "decano_code": "if ch != '_STR:0_' or escaped :", "token": ["if", "ch", "!=", "\" _STR:0_ \"", "or", "escaped", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "KEYWORD", "NAME", "OP"], "raw_code": "if ch != '?' or escaped :"}
{"src": ["name", "is", "a", "string", "_STR:0_", "formated", "with", "num_args", "."], "cano_code": "name = '_STR:0_' % num_args", "decano_code": "name = '_STR:0_' % num_args", "token": ["name", "=", "\" _STR:0_ \"", "%", "num_args"], "type": ["NAME", "OP", "STRING", "OP", "NAME"], "raw_code": "name = \"_%d\" % num_args"}
{"src": ["increment", "num_args", "by", "one", "."], "cano_code": "num_args += 1", "decano_code": "num_args += 1", "token": ["num_args", "+=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "num_args += 1"}
{"src": ["instantiate", "a", "class", "Group", "with", "2", "arguments", ":", "string", "_STR:0_", "formated", "with", "name", ",", "and", "name", ",", "append", "it", "to", "result", "."], "cano_code": "result . append ( Group ( ( ( '_STR:0_' % name ) , name ) ) )", "decano_code": "result . append ( Group ( ( ( '_STR:0_' % name ) , name ) ) )", "token": ["result", ".", "append", "(", "Group", "(", "(", "(", "\" _STR:0_ \"", "%", "name", ")", ",", "name", ")", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "STRING", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "result . append ( Group ( ( ( \"%%(%s)s\" % name ) , name ) ) )"}
{"src": ["call", "the", "function", "walk_to_end", "with", "2", "arguments", ":", "ch", "and", "pattern_iter", "."], "cano_code": "walk_to_end ( ch , pattern_iter )", "decano_code": "walk_to_end ( ch , pattern_iter )", "token": ["walk_to_end", "(", "ch", ",", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "walk_to_end ( ch , pattern_iter )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["if", "ch", "is", "contained", "in", "string", "_STR:0_", ","], "cano_code": "if ch in '_STR:0_' :pass", "decano_code": "if ch in '_STR:0_' :", "token": ["if", "ch", "in", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "STRING", "OP"], "raw_code": "if ch in \"iLmsu#\" :"}
{"src": ["call", "the", "function", "walk_to_end", "with", "2", "arguments", ":", "ch", "and", "pattern_iter", "."], "cano_code": "walk_to_end ( ch , pattern_iter )", "decano_code": "walk_to_end ( ch , pattern_iter )", "token": ["walk_to_end", "(", "ch", ",", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "walk_to_end ( ch , pattern_iter )"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == ':' :"}
{"src": ["append", "length", "of", "result", "to", "non_capturing_groups", "."], "cano_code": "non_capturing_groups . append ( len ( result ) )", "decano_code": "non_capturing_groups . append ( len ( result ) )", "token": ["non_capturing_groups", ".", "append", "(", "len", "(", "result", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP", "OP"], "raw_code": "non_capturing_groups . append ( len ( result ) )"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch != '_STR:0_' :pass", "decano_code": "elif ch != '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch != 'P' :"}
{"src": ["raise", "an", "ValueError", "with", "an", "argument", "string", "_STR:0_", "formated", "with", "ch", "."], "cano_code": "raise ValueError ( '_STR:0_' % ch )", "decano_code": "raise ValueError ( '_STR:0_' % ch )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", "%", "ch", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "raise ValueError ( \"Non-reversible reg-exp portion: '(?%s'\" % ch )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["if", "ch", "is", "not", "equal", "to", "string", "_STR:0_", "or", "string", "_STR:1_", ","], "cano_code": "if ch not in ( '_STR:0_' , '_STR:1_' ) :pass", "decano_code": "if ch not in ( '_STR:0_' , '_STR:1_' ) :", "token": ["if", "ch", "not", "in", "(", "\" _STR:0_ \"", ",", "\" _STR:1_ \"", ")", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP", "STRING", "OP", "STRING", "OP", "OP"], "raw_code": "if ch not in ( '<' , '=' ) :"}
{"src": ["raise", "an", "ValueError", "with", "an", "argument", "string", "_STR:0_", "formated", "with", "ch", "."], "cano_code": "raise ValueError ( '_STR:0_' % ch )", "decano_code": "raise ValueError ( '_STR:0_' % ch )", "token": ["raise", "ValueError", "(", "\" _STR:0_ \"", "%", "ch", ")"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP", "NAME", "OP"], "raw_code": "raise ValueError ( \"Non-reversible reg-exp portion: '(?P%s'\" % ch )"}
{"src": ["if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if ch == '_STR:0_' :pass", "decano_code": "if ch == '_STR:0_' :", "token": ["if", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if ch == '<' :"}
{"src": ["terminal_char", "is", "an", "string", "_STR:0_", "."], "cano_code": "terminal_char = '_STR:0_'", "decano_code": "terminal_char = '_STR:0_'", "token": ["terminal_char", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "terminal_char = '>'"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["terminal_char", "is", "an", "string", "_STR:0_", "."], "cano_code": "terminal_char = '_STR:0_'", "decano_code": "terminal_char = '_STR:0_'", "token": ["terminal_char", "=", "\" _STR:0_ \""], "type": ["NAME", "OP", "STRING"], "raw_code": "terminal_char = ')'"}
{"src": ["name", "is", "an", "empty", "list", "."], "cano_code": "name = [ ]", "decano_code": "name = [ ]", "token": ["name", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "name = [ ]"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["while", "ch", "is", "not", "equal", "to", "terminal_char", ","], "cano_code": "while ch != terminal_char :pass", "decano_code": "while ch != terminal_char :", "token": ["while", "ch", "!=", "terminal_char", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP"], "raw_code": "while ch != terminal_char :"}
{"src": ["append", "ch", "to", "result", "."], "cano_code": "name . append ( ch )", "decano_code": "name . append ( ch )", "token": ["result", ".", "append", "(", "ch", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "name . append ( ch )"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["join", "elements", "of", "name", "into", "a", "string", ",", "substitute", "it", "for", "param", "."], "cano_code": "param = '' . join ( name )", "decano_code": "param = '' . join ( name )", "token": ["param", "=", "\"  \"", ".", "join", "(", "name", ")"], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "param = '' . join ( name )"}
{"src": ["if", "terminal_char", "is", "not", "equal", "to", "string", "_STR:0_", ","], "cano_code": "if terminal_char != '_STR:0_' :pass", "decano_code": "if terminal_char != '_STR:0_' :", "token": ["if", "terminal_char", "!=", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if terminal_char != ')' :"}
{"src": ["instantiate", "a", "class", "Group", "with", "2", "arguments", ":", "string", "_STR:0_", "formated", "with", "param", ",", "and", "param", ",", "append", "it", "to", "result", "."], "cano_code": "result . append ( Group ( ( ( '_STR:0_' % param ) , param ) ) )", "decano_code": "result . append ( Group ( ( ( '_STR:0_' % param ) , param ) ) )", "token": ["result", ".", "append", "(", "Group", "(", "(", "(", "\" _STR:0_ \"", "%", "param", ")", ",", "param", ")", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "STRING", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "result . append ( Group ( ( ( \"%%(%s)s\" % param ) , param ) ) )"}
{"src": ["call", "the", "function", "walk_to_end", "with", "2", "arguments", ":", "ch", "and", "pattern_iter", "."], "cano_code": "walk_to_end ( ch , pattern_iter )", "decano_code": "walk_to_end ( ch , pattern_iter )", "token": ["walk_to_end", "(", "ch", ",", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "walk_to_end ( ch , pattern_iter )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["instantiate", "a", "class", "Group", "with", "2", "arguments", ":", "string", "_STR:0_", "formated", "with", "param", ",", "and", "None", ",", "append", "it", "to", "result", "."], "cano_code": "result . append ( Group ( ( ( '_STR:0_' % param ) , None ) ) )", "decano_code": "result . append ( Group ( ( ( '_STR:0_' % param ) , None ) ) )", "token": ["result", ".", "append", "(", "Group", "(", "(", "(", "\" _STR:0_ \"", "%", "param", ")", ",", "None", ")", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP", "STRING", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "OP", "OP"], "raw_code": "result . append ( Group ( ( ( \"%%(%s)s\" % param ) , None ) ) )"}
{"src": ["otherwise", "if", "ch", "is", "contained", "in", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch in '_STR:0_' :pass", "decano_code": "elif ch in '_STR:0_' :", "token": ["elif", "ch", "in", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "STRING", "OP"], "raw_code": "elif ch in \"*?+{\" :"}
{"src": ["call", "the", "function", "get_quantifier", "with", "2", "arguments", ":", "ch", "and", "pattern_iter", ",", "substitute", "the", "result", "for", "count", "and", "ch", ",", "respectively", "."], "cano_code": "count , ch = get_quantifier ( ch , pattern_iter )", "decano_code": "count , ch = get_quantifier ( ch , pattern_iter )", "token": ["count", ",", "ch", "=", "get_quantifier", "(", "ch", ",", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "count , ch = get_quantifier ( ch , pattern_iter )"}
{"src": ["if", "ch", "is", "true", ","], "cano_code": "if ch :pass", "decano_code": "if ch :", "token": ["if", "ch", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if ch :"}
{"src": ["consume_next", "is", "boolean", "False", "."], "cano_code": "consume_next = False", "decano_code": "consume_next = False", "token": ["consume_next", "=", "False"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "consume_next = False"}
{"src": ["if", "count", "is", "equal", "to", "integer", "0", "."], "cano_code": "if count == 0 :pass", "decano_code": "if count == 0 :", "token": ["if", "count", "==", "0", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "if count == 0 :"}
{"src": ["if", "call", "to", "the", "function", "contains", "with", "2", "arguments", ":", "last", "element", "of", "result", "and", "Group", ",", "evaluates", "to", "true", ","], "cano_code": "if contains ( result [ - 1 ] , Group ) :pass", "decano_code": "if contains ( result [ - 1 ] , Group ) :", "token": ["if", "contains", "(", "result", "[", "-", "1", "]", ",", "Group", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "OP"], "raw_code": "if contains ( result [ - 1 ] , Group ) :"}
{"src": ["last", "element", "of", "result", "is", "an", "instance", "of", "Choice", "class", ",", "created", "with", "an", "argument", "list", "with", "2", "elements", ":", "None", "and", "last", "element", "of", "result", "."], "cano_code": "result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )", "decano_code": "result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )", "token": ["result", "[", "-", "1", "]", "=", "Choice", "(", "[", "None", ",", "result", "[", "-", "1", "]", "]", ")"], "type": ["NAME", "OP", "OP", "NUMBER", "OP", "OP", "NAME", "OP", "OP", "KEYWORD", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "OP"], "raw_code": "result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["remove", "the", "first", "element", "from", "result", "."], "cano_code": "result . pop ( )", "decano_code": "result . pop ( )", "token": ["result", ".", "pop", "(", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP"], "raw_code": "result . pop ( )"}
{"src": ["otherwise", "if", "count", "is", "greater", "than", "integer", "1", ","], "cano_code": "if True: pass\nelif count > 1 :pass", "decano_code": "elif count > 1 :", "token": ["elif", "count", ">", "1", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP"], "raw_code": "elif count > 1 :"}
{"src": ["create", "a", "list", "with", "count", "decremented", "by", "1", "number", "of", "last", "element", "of", "result", "elements", ",", "extend", "list", "result", "with", "it", "."], "cano_code": "result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )", "decano_code": "result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )", "token": ["result", ".", "extend", "(", "[", "result", "[", "-", "1", "]", "]", "*", "(", "count", "-", "1", ")", ")"], "type": ["NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "OP", "NUMBER", "OP", "OP", "OP", "OP", "NAME", "OP", "NUMBER", "OP", "OP"], "raw_code": "result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["append", "ch", "to", "result", "."], "cano_code": "result . append ( ch )", "decano_code": "result . append ( ch )", "token": ["result", ".", "append", "(", "ch", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "result . append ( ch )"}
{"src": ["if", "consume_next", "is", "true", ","], "cano_code": "if consume_next :pass", "decano_code": "if consume_next :", "token": ["if", "consume_next", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if consume_next :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( pattern_iter )", "decano_code": "ch , escaped = next ( pattern_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( pattern_iter )"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["consume_next", "is", "boolean", "True", "."], "cano_code": "consume_next = True", "decano_code": "consume_next = True", "token": ["consume_next", "=", "True"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "consume_next = True"}
{"src": ["if", "StopIteration", "exception", ","], "cano_code": "try: pass\nexcept StopIteration :pass", "decano_code": "except StopIteration :", "token": ["except", "StopIteration", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except StopIteration :"}
{"src": ["do", "nothing", "."], "cano_code": "pass", "decano_code": "pass", "token": ["pass"], "type": ["NAME"], "raw_code": "pass"}
{"src": ["if", "NotImplementedError", "exception", ","], "cano_code": "try: pass\nexcept NotImplementedError :pass", "decano_code": "except NotImplementedError :", "token": ["except", "NotImplementedError", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except NotImplementedError :"}
{"src": ["return", "a", "list", "with", "an", "element", "tuple", "with", "2", "elements", ":", "an", "empty", "string", "and", "an", "empty", "list", "."], "cano_code": "return [ ( '' , [ ] ) ]", "decano_code": "return [ ( '' , [ ] ) ]", "token": ["return", "[", "(", "\"  \"", ",", "[", "]", ")", "]"], "type": ["KEYWORD", "OP", "OP", "STRING", "OP", "OP", "OP", "OP", "OP"], "raw_code": "return [ ( '' , [ ] ) ]"}
{"src": ["call", "the", "function", "flatten_result", "with", "an", "argument", "result", ",", "unpack", "the", "resulting", "list", "and", "zip", "it", "in", "the", "list", "of", "tuples", ",", "return", "the", "result", "."], "cano_code": "return list ( zip ( * flatten_result ( result ) ) )", "decano_code": "return list ( zip ( * flatten_result ( result ) ) )", "token": ["return", "list", "(", "zip", "(", "*", "flatten_result", "(", "result", ")", ")", ")"], "type": ["KEYWORD", "KEYWORD", "OP", "KEYWORD", "OP", "OP", "NAME", "OP", "NAME", "OP", "OP", "OP"], "raw_code": "return list ( zip ( * flatten_result ( result ) ) )"}
{"src": ["define", "the", "function", "next_char", "with", "an", "argument", "input_iter", "."], "cano_code": "def next_char ( input_iter ) :pass", "decano_code": "def next_char ( input_iter ) :", "token": ["def", "next_char", "(", "input_iter", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def next_char ( input_iter ) :"}
{"src": ["for", "every", "ch", "in", "input_iter", ","], "cano_code": "for ch in input_iter :pass", "decano_code": "for ch in input_iter :", "token": ["for", "ch", "in", "input_iter", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for ch in input_iter :"}
{"src": ["if", "ch", "is", "not", "equal", "to", "string", "'\\\\", "'", "."], "cano_code": "if ch != '\\\\' :pass", "decano_code": "if ch != '\\\\' :", "token": ["if", "ch", "!=", "\" \\\\ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if ch != '\\\\' :"}
{"src": ["yield", "ch", "and", "boolean", "False", "."], "cano_code": "yield ch , False", "decano_code": "yield ch , False", "token": ["yield", "ch", ",", "False"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD"], "raw_code": "yield ch , False"}
{"src": ["skip", "this", "loop", "iteration", "."], "cano_code": "continue", "decano_code": "continue", "token": ["continue"], "type": ["NAME"], "raw_code": "continue"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "."], "cano_code": "ch = next ( input_iter )", "decano_code": "ch = next ( input_iter )", "token": ["ch", "=", "next", "(", "input_iter", ")"], "type": ["NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch = next ( input_iter )"}
{"src": ["get", "the", "value", "under", "ch", "key", "of", "the", "ESCAPE_MAPPINGS", "dictionary", ",", "if", "it", "exists", "substitute", "it", "for", "representative", ",", "if", "not", "substitute", "ch", "for", "representative", "."], "cano_code": "representative = ESCAPE_MAPPINGS . get ( ch , ch )", "decano_code": "representative = ESCAPE_MAPPINGS . get ( ch , ch )", "token": ["representative", "=", "ESCAPE_MAPPINGS", ".", "get", "(", "ch", ",", "ch", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "representative = ESCAPE_MAPPINGS . get ( ch , ch )"}
{"src": ["if", "representative", "is", "None", ","], "cano_code": "if representative is None :pass", "decano_code": "if representative is None :", "token": ["if", "representative", "is", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if representative is None :"}
{"src": ["skip", "this", "loop", "iteration", "."], "cano_code": "continue", "decano_code": "continue", "token": ["continue"], "type": ["NAME"], "raw_code": "continue"}
{"src": ["yield", "representative", "and", "boolean", "True", "."], "cano_code": "yield representative , True", "decano_code": "yield representative , True", "token": ["yield", "representative", ",", "True"], "type": ["KEYWORD", "NAME", "OP", "KEYWORD"], "raw_code": "yield representative , True"}
{"src": ["define", "the", "function", "walk_to_end", "with", "2", "arguments", "ch", "and", "input_iter", "."], "cano_code": "def walk_to_end ( ch , input_iter ) :pass", "decano_code": "def walk_to_end ( ch , input_iter ) :", "token": ["def", "walk_to_end", "(", "ch", ",", "input_iter", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def walk_to_end ( ch , input_iter ) :"}
{"src": ["if", "ch", "equal", "a", "string", "_STR:0_", ","], "cano_code": "if ch == '_STR:0_' :pass", "decano_code": "if ch == '_STR:0_' :", "token": ["if", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if ch == '(' :"}
{"src": ["nesting", "is", "integer", "1", "."], "cano_code": "nesting = 1", "decano_code": "nesting = 1", "token": ["nesting", "=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "nesting = 1"}
{"src": ["if", "not", ","], "cano_code": "if True: pass\nelse :pass", "decano_code": "else :", "token": ["else", ":"], "type": ["KEYWORD", "OP"], "raw_code": "else :"}
{"src": ["nesting", "is", "integer", "0", "."], "cano_code": "nesting = 0", "decano_code": "nesting = 0", "token": ["nesting", "=", "0"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "nesting = 0"}
{"src": ["for", "every", "ch", "and", "escaped", "in", "input_iter", ","], "cano_code": "for ch , escaped in input_iter :pass", "decano_code": "for ch , escaped in input_iter :", "token": ["for", "ch", ",", "escaped", "in", "input_iter", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for ch , escaped in input_iter :"}
{"src": ["if", "escaped", "is", "true", ","], "cano_code": "if escaped :pass", "decano_code": "if escaped :", "token": ["if", "escaped", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "if escaped :"}
{"src": ["skip", "this", "loop", "iteration", "."], "cano_code": "continue", "decano_code": "continue", "token": ["continue"], "type": ["NAME"], "raw_code": "continue"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == '(' :"}
{"src": ["increment", "nesting", "by", "one", "."], "cano_code": "nesting += 1", "decano_code": "nesting += 1", "token": ["nesting", "+=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "nesting += 1"}
{"src": ["otherwise", "if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if True: pass\nelif ch == '_STR:0_' :pass", "decano_code": "elif ch == '_STR:0_' :", "token": ["elif", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "elif ch == ')' :"}
{"src": ["if", "nesting", "is", "false", ","], "cano_code": "if not nesting :pass", "decano_code": "if not nesting :", "token": ["if", "not", "nesting", ":"], "type": ["KEYWORD", "KEYWORD", "NAME", "OP"], "raw_code": "if not nesting :"}
{"src": ["return", "nothing", "."], "cano_code": "return", "decano_code": "return", "token": ["return"], "type": ["NAME"], "raw_code": "return"}
{"src": ["decrement", "nesting", "by", "one", "."], "cano_code": "nesting -= 1", "decano_code": "nesting -= 1", "token": ["nesting", "-=", "1"], "type": ["NAME", "OP", "NUMBER"], "raw_code": "nesting -= 1"}
{"src": ["define", "the", "function", "get_quantifier", "with", "2", "arguments", "ch", "and", "input_iter", "."], "cano_code": "def get_quantifier ( ch , input_iter ) :pass", "decano_code": "def get_quantifier ( ch , input_iter ) :", "token": ["def", "get_quantifier", "(", "ch", ",", "input_iter", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def get_quantifier ( ch , input_iter ) :"}
{"src": ["if", "ch", "is", "contained", "in", "string", "_STR:0_", ","], "cano_code": "if ch in '_STR:0_' :pass", "decano_code": "if ch in '_STR:0_' :", "token": ["if", "ch", "in", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "STRING", "OP"], "raw_code": "if ch in '*?+' :"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch2", "and", "escaped", ",", "respectively", "."], "cano_code": "ch2 , escaped = next ( input_iter )", "decano_code": "ch2 , escaped = next ( input_iter )", "token": ["ch2", ",", "escaped", "=", "next", "(", "input_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch2 , escaped = next ( input_iter )"}
{"src": ["if", "StopIteration", "exception", ","], "cano_code": "try: pass\nexcept StopIteration :pass", "decano_code": "except StopIteration :", "token": ["except", "StopIteration", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except StopIteration :"}
{"src": ["ch2", "is", "None", "."], "cano_code": "ch2 = None", "decano_code": "ch2 = None", "token": ["ch2", "=", "None"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "ch2 = None"}
{"src": ["if", "ch2", "equals", "string", "_STR:0_", ","], "cano_code": "if ch2 == '_STR:0_' :pass", "decano_code": "if ch2 == '_STR:0_' :", "token": ["if", "ch2", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if ch2 == '?' :"}
{"src": ["ch2", "is", "None", "."], "cano_code": "ch2 = None", "decano_code": "ch2 = None", "token": ["ch2", "=", "None"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "ch2 = None"}
{"src": ["if", "ch", "equals", "string", "_STR:0_", ","], "cano_code": "if ch == '_STR:0_' :pass", "decano_code": "if ch == '_STR:0_' :", "token": ["if", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if ch == '+' :"}
{"src": ["return", "integer", "1", "and", "ch2", "."], "cano_code": "return 1 , ch2", "decano_code": "return 1 , ch2", "token": ["return", "1", ",", "ch2"], "type": ["KEYWORD", "NUMBER", "OP", "NAME"], "raw_code": "return 1 , ch2"}
{"src": ["return", "integer", "0", "and", "ch2", "."], "cano_code": "return 0 , ch2", "decano_code": "return 0 , ch2", "token": ["return", "0", ",", "ch2"], "type": ["KEYWORD", "NUMBER", "OP", "NAME"], "raw_code": "return 0 , ch2"}
{"src": ["quant", "is", "an", "empty", "list", "."], "cano_code": "quant = [ ]", "decano_code": "quant = [ ]", "token": ["quant", "=", "[", "]"], "type": ["NAME", "OP", "OP", "OP"], "raw_code": "quant = [ ]"}
{"src": ["while", "ch", "is", "not", "equal", "to", "a", "string", "_STR:0_", ","], "cano_code": "while ch != '_STR:0_' :pass", "decano_code": "while ch != '_STR:0_' :", "token": ["while", "ch", "!=", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "while ch != '}' :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( input_iter )", "decano_code": "ch , escaped = next ( input_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( input_iter )"}
{"src": ["append", "ch", "to", "quant", "."], "cano_code": "quant . append ( ch )", "decano_code": "quant . append ( ch )", "token": ["quant", ".", "append", "(", "ch", ")"], "type": ["NAME", "OP", "NAME", "OP", "NAME", "OP"], "raw_code": "quant . append ( ch )"}
{"src": ["remove", "last", "element", "for", "quant", "."], "cano_code": "quant = quant [ : - 1 ]", "decano_code": "quant = quant [ : - 1 ]", "token": ["quant", "=", "quant", "[", ":", "-", "1", "]"], "type": ["NAME", "OP", "NAME", "OP", "OP", "OP", "NUMBER", "OP"], "raw_code": "quant = quant [ : - 1 ]"}
{"src": ["join", "elements", "of", "quant", "into", "a", "string", ",", "split", "it", "by", "string", "_STR:0_", ",", "substitute", "the", "result", "for", "values", "."], "cano_code": "values = '' . join ( quant ) . split ( '_STR:0_' )", "decano_code": "values = '' . join ( quant ) . split ( '_STR:0_' )", "token": ["values", "=", "\"  \"", ".", "join", "(", "quant", ")", ".", "split", "(", "\" _STR:0_ \"", ")"], "type": ["NAME", "OP", "STRING", "OP", "NAME", "OP", "NAME", "OP", "OP", "NAME", "OP", "STRING", "OP"], "raw_code": "values = '' . join ( quant ) . split ( ',' )"}
{"src": ["try", ","], "cano_code": "try :pass\nexcept: pass", "decano_code": "try :", "token": ["try", ":"], "type": ["KEYWORD", "OP"], "raw_code": "try :"}
{"src": ["get", "the", "next", "element", "of", "the", "iterable", "pattern_iter", ",", "assign", "the", "result", "for", "ch", "and", "escaped", ",", "respectively", "."], "cano_code": "ch , escaped = next ( input_iter )", "decano_code": "ch , escaped = next ( input_iter )", "token": ["ch", ",", "escaped", "=", "next", "(", "pattern_iter", ")"], "type": ["NAME", "OP", "NAME", "OP", "KEYWORD", "OP", "NAME", "OP"], "raw_code": "ch , escaped = next ( input_iter )"}
{"src": ["if", "StopIteration", "exception", ","], "cano_code": "try: pass\nexcept StopIteration :pass", "decano_code": "except StopIteration :", "token": ["except", "StopIteration", ":"], "type": ["KEYWORD", "NAME", "OP"], "raw_code": "except StopIteration :"}
{"src": ["ch", "is", "None", "."], "cano_code": "ch = None", "decano_code": "ch = None", "token": ["ch", "=", "None"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "ch = None"}
{"src": ["if", "ch", "equals", "a", "string", "_STR:0_", ","], "cano_code": "if ch == '_STR:0_' :pass", "decano_code": "if ch == '_STR:0_' :", "token": ["if", "ch", "==", "\" _STR:0_ \"", ":"], "type": ["KEYWORD", "NAME", "OP", "STRING", "OP"], "raw_code": "if ch == '?' :"}
{"src": ["ch", "is", "None", "."], "cano_code": "ch = None", "decano_code": "ch = None", "token": ["ch", "=", "None"], "type": ["NAME", "OP", "KEYWORD"], "raw_code": "ch = None"}
{"src": ["convert", "first", "element", "of", "values", "into", "a", "integer", ",", "return", "the", "result", "and", "ch", "."], "cano_code": "return int ( values [ 0 ] ) , ch", "decano_code": "return int ( values [ 0 ] ) , ch", "token": ["return", "int", "(", "values", "[", "0", "]", ")", ",", "ch"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NUMBER", "OP", "OP", "OP", "NAME"], "raw_code": "return int ( values [ 0 ] ) , ch"}
{"src": ["define", "the", "function", "contains", "with", "2", "arguments", "source", "and", "inst", "."], "cano_code": "def contains ( source , inst ) :pass", "decano_code": "def contains ( source , inst ) :", "token": ["def", "contains", "(", "source", ",", "inst", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def contains ( source , inst ) :"}
{"src": ["if", "source", "is", "an", "instance", "of", "inst", "class", ","], "cano_code": "if isinstance ( source , inst ) :pass", "decano_code": "if isinstance ( source , inst ) :", "token": ["if", "isinstance", "(", "source", ",", "inst", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if isinstance ( source , inst ) :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["if", "source", "is", "an", "instance", "of", "NonCapture", "class", ","], "cano_code": "if isinstance ( source , NonCapture ) :pass", "decano_code": "if isinstance ( source , NonCapture ) :", "token": ["if", "isinstance", "(", "source", ",", "NonCapture", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if isinstance ( source , NonCapture ) :"}
{"src": ["for", "every", "elt", "in", "source", ","], "cano_code": "for elt in source :pass", "decano_code": "for elt in source :", "token": ["for", "elt", "in", "source", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "NAME", "OP"], "raw_code": "for elt in source :"}
{"src": ["call", "the", "function", "contains", "with", "2", "arguments", ":", "elt", "and", "inst", ",", "if", "it", "evaluates", "to", "true", ","], "cano_code": "if contains ( elt , inst ) :pass", "decano_code": "if contains ( elt , inst ) :", "token": ["if", "contains", "(", "elt", ",", "inst", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if contains ( elt , inst ) :"}
{"src": ["return", "boolean", "True", "."], "cano_code": "return True", "decano_code": "return True", "token": ["return", "True"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return True"}
{"src": ["return", "boolean", "False", "."], "cano_code": "return False", "decano_code": "return False", "token": ["return", "False"], "type": ["KEYWORD", "KEYWORD"], "raw_code": "return False"}
{"src": ["define", "the", "function", "flatten_result", "with", "an", "argument", "source", "."], "cano_code": "def flatten_result ( source ) :pass", "decano_code": "def flatten_result ( source ) :", "token": ["def", "flatten_result", "(", "source", ")", ":"], "type": ["KEYWORD", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "def flatten_result ( source ) :"}
{"src": ["if", "source", "is", "None", ","], "cano_code": "if source is None :pass", "decano_code": "if source is None :", "token": ["if", "source", "is", "None", ":"], "type": ["KEYWORD", "NAME", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if source is None :"}
{"src": ["return", "a", "list", "containing", "an", "empty", "string", "and", "a", "list", "containing", "an", "empty", "list", "."], "cano_code": "return [ '' ] , [ [ ] ]", "decano_code": "return [ '' ] , [ [ ] ]", "token": ["return", "[", "\"  \"", "]", ",", "[", "[", "]", "]"], "type": ["KEYWORD", "OP", "STRING", "OP", "OP", "OP", "OP", "OP", "OP"], "raw_code": "return [ '' ] , [ [ ] ]"}
{"src": ["if", "source", "is", "an", "instance", "of", "Group", "class", ","], "cano_code": "if isinstance ( source , Group ) :pass", "decano_code": "if isinstance ( source , Group ) :", "token": ["if", "isinstance", "(", "source", ",", "Group", ")", ":"], "type": ["KEYWORD", "KEYWORD", "OP", "NAME", "OP", "NAME", "OP", "OP"], "raw_code": "if isinstance ( source , Group ) :"}
{"src": ["if", "second", "element", "of", "source", "is", "None", ","], "cano_code": "if source [ 1 ] is None :pass", "decano_code": "if source [ 1 ] is None :", "token": ["if", "source", "[", "1", "]", "is", "None", ":"], "type": ["KEYWORD", "NAME", "OP", "NUMBER", "OP", "KEYWORD", "KEYWORD", "OP"], "raw_code": "if source [ 1 ] is None :"}
